---
title: 搜索旋转排序数组
date: 2025-02-08
---

## 题目描述

**🔗 题目**：[搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)  
**🏷️ 标签**：`数组` `二分查找`  
**🟡 难度**：`中等`  

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

**示例 1：**
```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**
```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**
```
输入：nums = [1], target = 0
输出：-1
```

**提示：**
- 1 <= nums.length <= 5000
- -10⁴ <= nums[i] <= 10⁴
- nums 中的每个值都 独一无二
- 题目数据保证 nums 在预先未知的某个下标上进行了旋转
- -10⁴ <= target <= 10⁴

---

## 解题思路

### 二分查找

#### 📝 核心思想

本题的核心思想是利用二分查找的思路，但需要考虑数组旋转的特点。虽然数组经过旋转，但我们可以发现一个重要特性：数组在任意位置分成两半后，至少有一半是有序的。基于这个特性，我们可以：

1. 先判断哪一半是有序的
2. 再判断目标值是否在有序的那一半范围内
3. 根据判断结果选择在哪一半继续搜索

#### 🛠️ 实现步骤

1. 初始化左右指针 left 和 right
2. 进行二分查找，计算中间位置 mid
3. 如果 nums[mid] 就是目标值，直接返回 mid
4. 判断左半部分是否有序（通过比较 nums[left] 和 nums[mid]）
5. 如果左半部分有序：
   - 判断 target 是否在左半部分的范围内
   - 如果在，则在左半部分继续搜索
   - 如果不在，则在右半部分继续搜索
6. 如果右半部分有序：
   - 判断 target 是否在右半部分的范围内
   - 如果在，则在右半部分继续搜索
   - 如果不在，则在左半部分继续搜索
7. 如果未找到目标值，返回 -1

#### 🧩 示例分析

以示例 1 为例，nums = [4,5,6,7,0,1,2], target = 0：

1. 初始状态：
   ```
   数组：[4, 5, 6, 7, 0, 1, 2]
   目标值：0
   left = 0, right = 6, mid = 3
   ```

2. 第一次迭代：
   ```
   mid = 3，nums[mid] = 7
   左半部分 [4,5,6,7] 有序
   target = 0 不在左半部分范围 [4,7] 内
   → 在右半部分继续查找
   ```

3. 第二次迭代：
   ```
   left = 4, right = 6, mid = 5
   nums[mid] = 1
   右半部分 [1,2] 有序
   target = 0 不在右半部分范围 [1,2] 内
   → 在左半部分继续查找
   ```

4. 第三次迭代：
   ```
   left = 4, right = 4
   nums[mid] = 0
   找到目标值，返回 4
   ```

---

### 代码实现

```java
public int search(int[] nums, int target) {
    // 特殊情况处理
    if (nums == null || nums.length == 0) {
        return -1;
    }
    
    int left = 0;
    int right = nums.length - 1;
    
    // 二分查找
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        // 找到目标值
        if (nums[mid] == target) {
            return mid;
        }
        
        // 判断哪部分是有序的
        if (nums[left] <= nums[mid]) {
            // 左半部分有序
            if (target >= nums[left] && target < nums[mid]) {
                // target 在左半部分
                right = mid - 1;
            } else {
                // target 在右半部分
                left = mid + 1;
            }
        } else {
            // 右半部分有序
            if (target > nums[mid] && target <= nums[right]) {
                // target 在右半部分
                left = mid + 1;
            } else {
                // target 在左半部分
                right = mid - 1;
            }
        }
    }
    
    return -1;
}
```

---

### 复杂度分析

- **时间复杂度**：O(log n)，其中 n 是数组的长度。二分查找的时间复杂度为 O(log n)。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 