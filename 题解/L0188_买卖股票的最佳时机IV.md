---
title: 买卖股票的最佳时机 IV
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)  
**🏷️ 标签**：`数组` `动态规划`  
**🔴 难度**：`困难`  

给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1：
```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

示例 2：
```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

提示：
- 0 <= k <= 100
- 0 <= prices.length <= 1000
- 0 <= prices[i] <= 1000

---

## 解题思路

### 动态规划

#### 📝 核心思想

这道题是股票买卖系列中最通用的版本，限制交易次数为 k 次。我们需要用动态规划来解决，关键是设计好状态转移方程。

核心思路是：
1. 使用三维 dp 数组，分别表示天数、交易次数和是否持有股票
2. 对于每一天，我们都有"不操作"、"买入"或"卖出"三种选择
3. 特殊处理 k 大于数组长度一半的情况，此时相当于无限次交易

#### 🛠️ 实现步骤

1. 定义状态：
   - dp[i][j][0] 表示第 i 天，已进行 j 次交易，手上没有股票的最大利润
   - dp[i][j][1] 表示第 i 天，已进行 j 次交易，手上持有股票的最大利润

2. 状态转移方程：
   - dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])
   - dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])

3. 初始化：
   - dp[0][j][0] = 0
   - dp[0][j][1] = -prices[0]

4. 特殊情况处理：
   - 如果 k >= prices.length/2，转换为无限次交易问题

#### 🧩 示例分析

以示例 2 为例：prices = [3,2,6,5,0,3], k = 2

1. 初始状态：
   | 天数 | 交易次数 | 不持有股票 | 持有股票 |
   |-----|---------|-----------|----------|
   | 0   | 0       | 0         | -3       |
   | 0   | 1       | 0         | -3       |
   | 0   | 2       | 0         | -3       |

2. 第 1 天（价格 = 2）：
   | 天数 | 交易次数 | 不持有股票 | 持有股票 |
   |-----|---------|-----------|----------|
   | 1   | 0       | 0         | -2       |
   | 1   | 1       | 0         | -2       |
   | 1   | 2       | 0         | -2       |

3. 第 2 天（价格 = 6）：
   | 天数 | 交易次数 | 不持有股票 | 持有股票 |
   |-----|---------|-----------|----------|
   | 2   | 0       | 0         | -2       |
   | 2   | 1       | 4         | -2       |
   | 2   | 2       | 4         | -2       |

4. 最终状态：
   | 天数 | 交易次数 | 不持有股票 | 持有股票 |
   |-----|---------|-----------|----------|
   | 5   | 0       | 0         | -2       |
   | 5   | 1       | 4         | 1        |
   | 5   | 2       | 7         | 4        |

最终答案为 dp[5][2][0] = 7，表示进行两次交易后的最大利润。

---

## 代码实现

完整的可运行代码：[L0188_BestTimeToBuyAndSellStockIV.java](../src/main/java/L0188_BestTimeToBuyAndSellStockIV.java)

```java
public int maxProfit(int k, int[] prices) {
    if (prices == null || prices.length <= 1 || k <= 0) {
        return 0;
    }
    
    // 如果 k 超过了最大可能的交易次数，相当于无限次交易
    if (k >= prices.length / 2) {
        return maxProfitUnlimited(prices);
    }
    
    // dp[天数][交易次数][是否持有股票]
    int[][][] dp = new int[prices.length][k + 1][2];
    
    // 初始化第一天的状态
    for (int j = 0; j <= k; j++) {
        dp[0][j][0] = 0;
        dp[0][j][1] = -prices[0];
    }
    
    // 遍历每一天
    for (int i = 1; i < prices.length; i++) {
        for (int j = k; j >= 1; j--) {
            // 第 i 天不持有股票：
            // 1. 前一天也不持有
            // 2. 前一天持有，今天卖出
            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
            
            // 第 i 天持有股票：
            // 1. 前一天就持有
            // 2. 前一天不持有，今天买入（这种情况要减少一次交易次数）
            dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
        }
    }
    
    return dp[prices.length - 1][k][0];
}
```

---

## 复杂度分析

- **时间复杂度**：O(n × k)，其中 n 是数组的长度，k 是最大交易次数。需要遍历整个数组，对于每一天都需要计算 k 次交易的状态。
- **空间复杂度**：O(n × k)，需要一个三维数组来存储状态。如果优化状态转移，可以将空间复杂度降到 O(k)。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 