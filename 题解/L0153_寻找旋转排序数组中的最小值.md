---
title: 寻找旋转排序数组中的最小值
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)  
**🏷️ 标签**：`数组` `二分查找`  
**🟡 难度**：`中等`  

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
- 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
- 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

**示例 1：**
```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

**示例 2：**
```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```

**示例 3：**
```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

**提示：**
- n == nums.length
- 1 <= n <= 5000
- -5000 <= nums[i] <= 5000
- nums 中的所有整数 互不相同
- nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转

---

## 解题思路

### 二分查找

#### 📝 核心思想
旋转排序数组的一个重要特性是：它可以被分成两个有序的部分。最小值就是这两个有序部分的分界点。我们可以使用二分查找来找到这个分界点：

1. 如果中间值大于右边界的值，说明最小值在右半部分
2. 如果中间值小于等于右边界的值，说明最小值在左半部分（包括中间值）
3. 特殊情况：如果数组没有旋转或旋转了 n 次（相当于没旋转），直接返回第一个元素

#### 🛠️ 实现步骤
1. 特殊情况处理：
   - 如果数组为空，返回 -1
   - 如果数组首元素小于等于末元素，说明数组是有序的，返回首元素

2. 二分查找：
   - 初始化左右指针 left 和 right
   - 当 left < right 时：
     * 计算中间位置 mid
     * 如果 nums[mid] > nums[right]，说明最小值在右边
     * 否则最小值在左边（包括 mid）

3. 返回 nums[left]，此时 left 指向最小值

#### 🧩 示例分析
以示例 2 为例：nums = [4,5,6,7,0,1,2]

| 步骤 | left | right | mid | nums[mid] | nums[right] | 操作 | 说明 |
|-----|------|-------|-----|-----------|-------------|------|------|
| 1 | 0 | 6 | 3 | 7 | 2 | left = mid + 1 | 7 > 2，最小值在右边 |
| 2 | 4 | 6 | 5 | 1 | 2 | right = mid | 1 < 2, 最小值在左边 |
| 3 | 4 | 5 | 4 | 0 | 1 | right = mid | 0 < 1, 最小值在左边 |
| 4 | 4 | 4 | - | - | - | 结束循环 | nums[4] = 0 是最小值 |

图解过程：
```
初始数组：[4, 5, 6, 7, 0, 1, 2]
第一步：  [4, 5, 6, 7, 0, 1, 2]
                  ↑
                 mid=7 > 2，搜索右半部分
第二步：  [4, 5, 6, 7, 0, 1, 2]
                     ↑
                    mid=1 < 2，搜索左半部分
第三步：  [4, 5, 6, 7, 0, 1, 2]
                    ↑
                   mid=0 是最小值
```

---

## 代码实现

完整的可运行代码：[L0153_FindMinimumInRotatedSortedArray.java](../src/main/java/L0153_FindMinimumInRotatedSortedArray.java)

```java
public int findMin(int[] nums) {
    if (nums == null || nums.length == 0) {
        return -1;
    }
    
    int left = 0;
    int right = nums.length - 1;
    
    // 如果数组没有旋转或旋转了 n 次（相当于没旋转）
    if (nums[left] <= nums[right]) {
        return nums[left];
    }
    
    // 使用二分查找
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        // 如果中间值大于右边值，说明最小值在右半部分
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        }
        // 否则最小值在左半部分（包括 mid）
        else {
            right = mid;
        }
    }
    
    return nums[left];
}
```

---

## 复杂度分析

- **时间复杂度**：O(log n)，其中 n 是数组的长度
  - 使用二分查找，每次将搜索范围缩小一半
  - 最多需要 log n 次比较就能找到最小值

- **空间复杂度**：O(1)
  - 只使用了几个变量来存储指针和临时值
  - 不需要额外的数组空间

---

## 优化思路

1. **处理重复元素**
   - 当前算法假设数组中的元素互不相同
   - 如果允许重复元素，需要额外的处理
   - 可以参考 "寻找旋转排序数组中的最小值 II" 题目

2. **优化边界条件**
   - 可以在开始时判断更多的特殊情况
   - 例如数组长度为 1 或 2 的情况
   - 可以减少一些不必要的计算

3. **使用左边界比较**
   - 当前算法使用右边界进行比较
   - 也可以使用左边界进行比较
   - 两种方法都是可行的，可以根据具体情况选择

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 