---
title: 字符串转换整数 (atoi)
date: 2024-02-06
---

## 题目描述

**🔗 题目**：[字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)  
**🏷️ 标签**：`字符串` `数学`  
**🟡 难度**：`中等`  

请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数。

函数 `myAtoi(string s)` 的算法如下：

1. 读入字符串并丢弃无用的前导空格
2. 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
3. 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
4. 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
5. 如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。
6. 返回整数作为最终结果。

**示例 1：**
```
输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
第 3 步："42"（读入 "42"）
解析得到整数 42 。
由于 "42" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 42 。
```

**示例 2：**
```
输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
第 3 步："   -42"（读入 "42"）
解析得到整数 -42 。
由于 "-42" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 -42 。
```

**示例 3：**
```
输入：s = "4193 with words"
输出：4193
解释：
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
解析得到整数 4193 。
由于 "4193" 在范围 [-2^31, 2^31 - 1] 内，最终结果为 4193 。
```

**提示：**
- `0 <= s.length <= 200`
- `s` 由英文字母（大写和小写）、数字（0-9）、`' '`、`'+'`、`'-'` 和 `'.'` 组成

---

## 解题思路

### 模拟法

#### 📝 核心思想
按照题目要求的步骤，模拟整个字符串转整数的过程，需要特别注意边界条件和溢出处理。

#### 🛠️ 实现步骤
1. 处理特殊情况：
   - 如果字符串为空或长度为 0，返回 0
   - 去除前导空格，如果去除后为空，返回 0
2. 处理符号：
   - 检查第一个字符是否是 '+' 或 '-'
   - 记录符号并移动索引
3. 处理数字：
   - 遍历字符串，直到遇到非数字字符或到达字符串末尾
   - 将每个数字字符转换为对应的数值
   - 检查是否溢出
   - 累加到结果中
4. 返回带符号的最终结果

#### 🧩 示例分析
以 `s = "   -42"` 为例：

| 步骤 | 当前字符 | 状态 | 结果 | 说明 |
|------|----------|------|------|------|
| 初始状态 | - | 开始 | 0 | 准备处理字符串 |
| Step 1 | [' '] | 跳过空格 | 0 | 跳过前导空格 |
| Step 2 | ['-'] | 处理符号 | 0 | 记录负号，sign = -1 |
| Step 3 | ['4'] | 处理数字 | 4 | result = 4 |
| Step 4 | ['2'] | 处理数字 | 42 | result = 42 |

**状态转换图**：
```
开始 ──[空格]──> 跳过空格 ──[+/-]──> 处理符号 ──[0-9]──> 处理数字
  │                  │                  │               │
  │                  │                  │               └──[0-9]──┐
  │                  │                  └──[0-9]──> 处理数字 <───┘
  │                  └──[0-9]──> 处理数字
  └──[其他]──> 结束
```

**详细分析**：
1. 处理空格：
   ```
   输入：[   ]-42
   状态：跳过空格
   结果：0
   ```

2. 处理符号：
   ```
   输入：   [-]42
   状态：处理符号
   结果：0，sign = -1
   ```

3. 处理数字：
   ```
   输入：   -[4]2
   状态：处理数字
   结果：4 * -1 = -4

   输入：   -4[2]
   状态：处理数字
   结果：(-4 * 10 - 2) = -42
   ```

**特殊情况示例**：
1. 溢出情况：
以 `s = "2147483648"` 为例：

| 步骤 | 当前字符 | 当前值 | 溢出检查 | 说明 |
|------|----------|--------|-----------|------|
| Step 1 | ['2'] | 2 | 通过 | 处理第一位 |
| Step 2 | ['1'] | 21 | 通过 | 继续处理 |
| Step 3 | ['4'] | 214 | 通过 | 继续处理 |
| Step 4 | ['7'] | 2147 | 通过 | 继续处理 |
| Step 5 | ['4'] | 21474 | 通过 | 继续处理 |
| Step 6 | ['8'] | 214748 | 通过 | 继续处理 |
| Step 7 | ['3'] | 2147483 | 通过 | 继续处理 |
| Step 8 | ['6'] | 21474836 | 通过 | 继续处理 |
| Step 9 | ['4'] | 214748364 | 通过 | 继续处理 |
| Step 10 | ['8'] | 溢出 | 不通过 | 返回 MAX_VALUE |

2. 非法输入：
以 `s = "4193 with words"` 为例：

| 步骤 | 当前字符 | 状态 | 结果 | 说明 |
|------|----------|------|------|------|
| Step 1 | ['4'] | 处理数字 | 4 | 开始处理数字 |
| Step 2 | ['1'] | 处理数字 | 41 | 继续处理数字 |
| Step 3 | ['9'] | 处理数字 | 419 | 继续处理数字 |
| Step 4 | ['3'] | 处理数字 | 4193 | 继续处理数字 |
| Step 5 | [' '] | 结束 | 4193 | 遇到非数字字符，停止处理 |

#### 溢出处理
在处理数字时，需要检查是否会溢出：
1. 如果 result > Integer.MAX_VALUE/10，必定溢出
2. 如果 result == Integer.MAX_VALUE/10，则需要检查当前数字是否大于 Integer.MAX_VALUE%10
3. 根据符号返回相应的最大值或最小值

---

## 代码实现

完整的可运行代码：[L0008_StringToInteger.java](../src/main/java/L0008_StringToInteger.java)

```java
public int myAtoi(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    
    // 去除前导空格
    s = s.trim();
    if (s.length() == 0) {
        return 0;
    }
    
    // 记录结果
    int result = 0;
    // 记录符号，1 表示正数，-1 表示负数
    int sign = 1;
    // 当前处理的字符位置
    int index = 0;
    
    // 处理符号
    if (s.charAt(index) == '+' || s.charAt(index) == '-') {
        sign = s.charAt(index) == '+' ? 1 : -1;
        index++;
    }
    
    // 处理数字
    while (index < s.length() && Character.isDigit(s.charAt(index))) {
        int digit = s.charAt(index) - '0';
        
        // 判断是否溢出
        if (result > Integer.MAX_VALUE / 10 || 
            (result == Integer.MAX_VALUE / 10 && digit > Integer.MAX_VALUE % 10)) {
            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
        }
        
        result = result * 10 + digit;
        index++;
    }
    
    return sign * result;
}
```

---

## 复杂度分析

- **时间复杂度**：`O(n)`，其中 n 是字符串的长度。我们最多需要遍历字符串一次。
- **空间复杂度**：`O(1)`，我们只需要常数级别的额外空间来存储变量。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。