---
title: 戳气球
date: 2025-02-10
---

## 题目描述

**🔗 题目**：[戳气球](https://leetcode.cn/problems/burst-balloons/)  
**🏷️ 标签**：`数组` `动态规划`  
**🔴 难度**：`困难`  

有 n 个气球，编号为 0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1 或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。

求所能获得硬币的最大数量。

示例 1：
```
输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 15 + 120 + 24 + 8 = 167
```

示例 2：
```
输入：nums = [1,5]
输出：10
```

提示：
- n == nums.length
- 1 <= n <= 300
- 0 <= nums[i] <= 100

---

## 解题思路
### 区间动态规划

#### 📝 核心思想
这道题的关键在于理解：我们应该从"最后一个戳破的气球"的角度来思考，而不是"第一个戳破的气球"。原因是：
1. 如果我们考虑第一个戳破的气球，那么戳破后，原来相邻的气球变成新的相邻气球，状态很难转移
2. 如果我们考虑最后一个戳破的气球，那么这个气球的左右两边已经被戳破，形成了两个独立的子问题

因此，我们可以使用区间动态规划，定义状态 dp[i][j] 表示戳破开区间 (i,j) 内所有气球能得到的最大硬币数。

#### 🛠️ 实现步骤
1. 数组预处理：
   - 在原数组首尾各添加一个 1，简化边界处理
   - 新数组 newNums 长度为 n+2

2. 定义状态：
   - dp[i][j] 表示戳破开区间 (i,j) 内所有气球能得到的最大硬币数
   - i 和 j 是开区间，即不包含 i 和 j

3. 状态转移：
   - 枚举区间长度 len，从小到大
   - 枚举区间左端点 i
   - 计算区间右端点 j = i + len - 1
   - 枚举最后一个戳破的气球 k，k 的范围为 [i+1, j]
   - 状态转移方程：
     dp[i][j] = max(dp[i][j], dp[i][k-1] + dp[k+1][j] + nums[i] * nums[k] * nums[j])

4. 返回结果：
   - 最终结果为 dp[1][n]，表示戳破开区间 (1,n) 内所有气球的最大硬币数

#### 🧩 示例分析
以示例 1：nums = [3,1,5,8] 为例，让我们看看算法是如何工作的：

1. 预处理数组：
```
原数组：[3,1,5,8]
处理后：[1,3,1,5,8,1]  // 首尾添加 1
```

2. 动态规划过程：

| 区间长度 | 区间 | 最后戳破的气球 | 获得的硬币 | 说明 |
|---------|-----|--------------|-----------|-----|
| 1 | (1,2) | 2 | 3 | 1×3×1 = 3 |
| 1 | (2,3) | 3 | 5 | 1×1×5 = 5 |
| 1 | (3,4) | 4 | 40 | 1×5×8 = 40 |
| 1 | (4,5) | 5 | 8 | 5×8×1 = 40 |
| 2 | (1,3) | 2 | 15 | 1×3×5 = 15 |
| 2 | (2,4) | 3 | 40 | 1×1×8 = 8 |
| 2 | (3,5) | 4 | 120 | 1×5×1 = 5 |
| 3 | (1,4) | 3 | 135 | 包含多种情况 |
| 3 | (2,5) | 4 | 48 | 包含多种情况 |
| 4 | (1,5) | 3 | 167 | 最终结果 |

让我们详细分析一个具体的状态转移过程。以区间 (1,4) 为例：
1. 可以选择的最后一个气球是 2、3
2. 如果选择 3 作为最后戳破的气球：
   - 左边区间 (1,2) 的最大值：3
   - 右边区间 (3,4) 的最大值：40
   - 戳破 3 获得的硬币：1×1×8 = 8
   - 总和：3 + 40 + 8 = 51

3. 通过枚举所有可能的最后一个气球，我们可以找到最优解。

---

## 代码实现

完整的可运行代码：[L0312_BurstBalloons.java](../src/main/java/L0312_BurstBalloons.java)

```java
public class L0312_BurstBalloons {
    
    public int maxCoins(int[] nums) {
        int n = nums.length;
        // 创建一个新的数组，在首尾各添加一个 1
        int[] newNums = new int[n + 2];
        newNums[0] = 1;
        newNums[n + 1] = 1;
        for (int i = 0; i < n; i++) {
            newNums[i + 1] = nums[i];
        }
        
        // dp[i][j] 表示戳破 (i,j) 开区间内的所有气球能得到的最大硬币数
        int[][] dp = new int[n + 2][n + 2];
        
        // len 表示开区间的长度
        for (int len = 1; len <= n; len++) {
            // i 表示开区间的左端点
            for (int i = 1; i <= n - len + 1; i++) {
                int j = i + len - 1;  // j 表示开区间的右端点
                // k 表示最后一个被戳破的气球
                for (int k = i; k <= j; k++) {
                    // 计算戳破气球 k 时获得的硬币数
                    int coins = newNums[i - 1] * newNums[k] * newNums[j + 1];
                    // 加上戳破左右两边气球能得到的最大硬币数
                    coins += dp[i][k - 1] + dp[k + 1][j];
                    dp[i][j] = Math.max(dp[i][j], coins);
                }
            }
        }
        
        return dp[1][n];
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(n³)，其中 n 是气球的数量。我们需要计算 O(n²) 个状态，每个状态需要 O(n) 的时间枚举最后一个戳破的气球。

- **空间复杂度**：O(n²)。我们需要一个 n×n 的二维数组来存储所有状态。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 