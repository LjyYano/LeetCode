---
title: 分发糖果
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[分发糖果](https://leetcode.cn/problems/candy/)  
**🏷️ 标签**：`贪心` `数组`  
**🔴 难度**：`困难`  

n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：
- 每个孩子至少分配到 1 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。

**示例 1：**
```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

**示例 2：**
```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

**提示：**
- n == ratings.length
- 1 <= n <= 2 * 10⁴
- 0 <= ratings[i] <= 2 * 10⁴

---

## 解题思路

### 贪心算法

#### 📝 核心思想
这道题可以使用贪心算法来解决。关键在于将问题分解为两个规则：
1. 从左到右：如果右边孩子的评分比左边高，右边孩子的糖果数要比左边多一个
2. 从右到左：如果左边孩子的评分比右边高，左边孩子的糖果数要比右边多一个

通过两次遍历，我们可以同时满足这两个规则，从而得到最优解。

#### 🛠️ 实现步骤
1. 初始化：
   - 每个孩子至少分配 1 个糖果
   - 创建一个数组 candies 记录每个孩子的糖果数

2. 从左向右遍历：
   - 如果当前孩子的评分比左边高
   - 当前孩子的糖果数 = 左边孩子的糖果数 + 1

3. 从右向左遍历：
   - 如果当前孩子的评分比右边高
   - 当前孩子的糖果数 = max(当前糖果数, 右边孩子的糖果数 + 1)

4. 计算总糖果数：
   - 将所有孩子的糖果数相加

#### 🧩 示例分析
以示例 1 为例，ratings = [1,0,2]：

1. 初始状态：
```
位置：     0  1  2
评分：     1  0  2
糖果数：   1  1  1
```

2. 从左向右遍历：
```
位置：     0  1  2
评分：     1  0  2
糖果数：   1  1  2  (位置 2 的评分比位置 1 高)
```

3. 从右向左遍历：
```
位置：     0  1  2
评分：     1  0  2
糖果数：   2  1  2  (位置 0 的评分比位置 1 高)
```

4. 最终结果：2 + 1 + 2 = 5 个糖果

以示例 2 为例，ratings = [1,2,2]：

1. 初始状态：
```
位置：     0  1  2
评分：     1  2  2
糖果数：   1  1  1
```

2. 从左向右遍历：
```
位置：     0  1  2
评分：     1  2  2
糖果数：   1  2  1  (位置 1 的评分比位置 0 高)
```

3. 从右向左遍历：
```
位置：     0  1  2
评分：     1  2  2
糖果数：   1  2  1  (无需更改)
```

4. 最终结果：1 + 2 + 1 = 4 个糖果

---

## 代码实现

完整的可运行代码：[L0135_Candy.java](../src/main/java/L0135_Candy.java)

```java
public int candy(int[] ratings) {
    int n = ratings.length;
    // 每个孩子至少分配 1 个糖果
    int[] candies = new int[n];
    for (int i = 0; i < n; i++) {
        candies[i] = 1;
    }
    
    // 从左向右遍历，如果右边评分高于左边，右边的糖果数要多一个
    for (int i = 1; i < n; i++) {
        if (ratings[i] > ratings[i - 1]) {
            candies[i] = candies[i - 1] + 1;
        }
    }
    
    // 从右向左遍历，如果左边评分高于右边，左边的糖果数要多一个
    for (int i = n - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) {
            candies[i] = Math.max(candies[i], candies[i + 1] + 1);
        }
    }
    
    // 计算总糖果数
    int totalCandies = 0;
    for (int candy : candies) {
        totalCandies += candy;
    }
    
    return totalCandies;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)
  - 需要遍历数组三次
  - 第一次初始化
  - 第二次从左向右遍历
  - 第三次从右向左遍历
  - n 是数组的长度

- **空间复杂度**：O(n)
  - 需要一个额外的数组存储每个孩子的糖果数
  - n 是数组的长度

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 