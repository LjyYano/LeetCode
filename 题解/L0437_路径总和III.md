---
title: 路径总和 III
date: 2024-03-27
---

## 题目描述

**🔗 题目**：[路径总和 III](https://leetcode.cn/problems/path-sum-iii/description/)  
**🏷️ 标签**：`树` `深度优先搜索` `二叉树`  
**🟡 难度**：`中等`  

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的路径的数目。

路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

示例 1：
![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)
```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

示例 2：
```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```

---

## 解题思路
### 双重递归

#### 📝 核心思想
1. 对于每个节点，我们都需要考虑两种情况：
   - 以该节点为起点的路径
   - 不以该节点为起点，而是以其子节点为起点的路径

2. 这就需要我们使用双重递归：
   - 外层递归：遍历每个节点，将其作为潜在的路径起点
   - 内层递归：以当前节点为起点，搜索所有可能的路径

3. 在搜索路径时，我们需要：
   - 记录当前路径和
   - 判断是否找到一条满足条件的路径
   - 继续向下搜索可能的路径

#### 🛠️ 实现步骤
1. 实现外层递归函数 `pathSum`：
   - 处理空节点的边界情况
   - 统计以当前节点为起点的路径数量
   - 递归处理左右子树
   - 返回路径总数

2. 实现内层递归函数 `dfs`：
   - 处理空节点的边界情况
   - 判断当前节点值是否等于目标值
   - 递归搜索左右子树，更新目标值
   - 返回找到的路径数量

3. 注意处理整数溢出：
   - 使用 long 类型存储路径和
   - 避免大数相加减时的溢出问题

#### 🧩 示例分析
以示例 1 为例，分析查找路径和为 8 的过程：

```
       10
      /  \
     5   -3
    / \    \
   3   2   11
  / \   \
 3  -2   1
```

1. 从根节点 10 开始搜索：
   | 节点路径 | 路径和 | 是否满足 |
   |---------|--------|----------|
   | [10] | 10 | ❌ |
   | [10,5] | 15 | ❌ |
   | [10,5,3] | 18 | ❌ |
   | [10,5,2] | 17 | ❌ |
   | [10,-3] | 7 | ❌ |
   | [10,-3,11] | 18 | ❌ |

2. 从节点 5 开始搜索：
   | 节点路径 | 路径和 | 是否满足 |
   |---------|--------|----------|
   | [5] | 5 | ❌ |
   | [5,3] | 8 | ✅ |
   | [5,2] | 7 | ❌ |
   | [5,3,3] | 11 | ❌ |
   | [5,3,-2] | 6 | ❌ |
   | [5,2,1] | 8 | ✅ |

3. 从节点 3 开始搜索：
   | 节点路径 | 路径和 | 是否满足 |
   |---------|--------|----------|
   | [3] | 3 | ❌ |
   | [3,3] | 6 | ❌ |
   | [3,-2] | 1 | ❌ |

4. 从其他节点开始搜索：
   | 节点路径 | 路径和 | 是否满足 |
   |---------|--------|----------|
   | [2] | 2 | ❌ |
   | [2,1] | 3 | ❌ |
   | [-3] | -3 | ❌ |
   | [-3,11] | 8 | ✅ |

最终找到 3 条路径：
1. [5,3]：和为 8
2. [5,2,1]：和为 8
3. [-3,11]：和为 8

---

## 代码实现

完整的可运行代码：[L0437_PathSumIII.java](../src/main/java/L0437_PathSumIII.java)

```java
public int pathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return 0;
    }
    
    // 以当前节点为起点的路径数量
    int count = dfs(root, targetSum);
    
    // 递归统计左右子树中的路径数量
    count += pathSum(root.left, targetSum);
    count += pathSum(root.right, targetSum);
    
    return count;
}

/**
 * 统计以当前节点为起点，和为 targetSum 的路径数量
 */
private int dfs(TreeNode node, long targetSum) {
    if (node == null) {
        return 0;
    }
    
    int count = 0;
    // 如果当前节点值等于目标值，找到一条路径
    if (node.val == targetSum) {
        count++;
    }
    
    // 继续搜索左右子树，注意更新目标值
    count += dfs(node.left, targetSum - node.val);
    count += dfs(node.right, targetSum - node.val);
    
    return count;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n²)
  - 对于每个节点，我们都需要遍历其所有子节点来寻找路径
  - 最坏情况下（树呈链状），每个节点都需要遍历其下方的所有节点
  - 因此总时间复杂度为 O(n²)，其中 n 为树中节点的数量

- **空间复杂度**：O(n)
  - 递归调用栈的深度最大为树的高度
  - 最坏情况下（树呈链状），空间复杂度为 O(n)
  - 除递归栈外，不需要额外的存储空间

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 