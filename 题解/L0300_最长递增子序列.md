---
title: 最长递增子序列
date: 2024-03-27
---

## 题目描述

**🔗 题目**：[最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)  
**🏷️ 标签**：`数组` `二分查找` `动态规划`  
**🟡 难度**：`中等`  

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

**示例 1：**
```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**
```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**
```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**提示：**
- 1 <= nums.length <= 2500
- -10⁴ <= nums[i] <= 10⁴

**进阶：**
你能将算法的时间复杂度降低到 O(n log(n)) 吗?

---

## 解题思路

### 动态规划

#### 📝 核心思想
这是一个经典的动态规划问题。我们定义 dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度。对于每个位置 i，我们需要查看它前面的所有元素 j，如果 nums[i] > nums[j]，那么可以将 nums[i] 接在以 nums[j] 结尾的子序列后面，从而形成一个更长的递增子序列。

#### 🛠️ 实现步骤
1. 初始化：
   - 创建长度为 n 的 dp 数组
   - 将 dp 数组的所有元素初始化为 1（每个元素自身可以构成长度为 1 的子序列）

2. 状态转移：
   - 对于每个位置 i，遍历它前面的所有位置 j
   - 如果 nums[i] > nums[j]，说明可以将 nums[i] 接在以 nums[j] 结尾的子序列后面
   - 此时 dp[i] = max(dp[i], dp[j] + 1)

3. 结果：
   - 遍历 dp 数组，找到最大值，即为最长递增子序列的长度

#### 🧩 示例分析
以示例 1：nums = [10,9,2,5,3,7,101,18] 为例：

| 索引 i | 数字 nums[i] | dp[i] 的计算过程 | 最终 dp[i] | 当前最大长度 |
|-------|-------------|-----------------|------------|------------|
| 0 | 10 | 初始值 | 1 | 1 |
| 1 | 9 | 小于前面的数，保持初始值 | 1 | 1 |
| 2 | 2 | 小于前面的数，保持初始值 | 1 | 1 |
| 3 | 5 | 大于 2，dp[3] = max(1, dp[2] + 1) = 2 | 2 | 2 |
| 4 | 3 | 大于 2，dp[4] = max(1, dp[2] + 1) = 2 | 2 | 2 |
| 5 | 7 | 大于 2,3,5，dp[5] = max(1, dp[2] + 1, dp[3] + 1, dp[4] + 1) = 3 | 3 | 3 |
| 6 | 101 | 大于所有前面的数，dp[6] = max(1, dp[0..5] + 1) = 4 | 4 | 4 |
| 7 | 18 | 大于 2,3,5,7，dp[7] = max(1, dp[2..5] + 1) = 4 | 4 | 4 |

通过表格可以看到：
1. 每个位置的 dp 值依赖于前面所有小于当前数字的位置的 dp 值
2. 最终的最长递增子序列长度为 4，对应的序列可以是 [2,3,7,101] 或 [2,3,7,18]

### 进阶解法：二分查找

虽然动态规划解法直观易懂，但时间复杂度为 O(n²)。我们可以使用二分查找优化到 O(n log n)：

1. 维护一个数组 tails，其中 tails[i] 表示长度为 i+1 的所有递增子序列中，结尾最小的数字
2. 对于每个 nums[i]，在 tails 数组中二分查找，找到第一个大于 nums[i] 的位置
3. 如果找不到，说明 nums[i] 可以接在当前最长的子序列后面
4. 如果找到了，就用 nums[i] 替换那个位置的数字

这种方法不仅可以得到最长递增子序列的长度，而且 tails 数组中的数字一定是递增的，这保证了二分查找的正确性。

---

## 代码实现

完整的可运行代码：[L0300_LongestIncreasingSubsequence.java](../src/main/java/L0300_LongestIncreasingSubsequence.java)

```java
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    
    int n = nums.length;
    // dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度
    int[] dp = new int[n];
    // 初始化 dp 数组，每个元素自身可以构成长度为 1 的子序列
    for (int i = 0; i < n; i++) {
        dp[i] = 1;
    }
    
    // 最长递增子序列的长度
    int maxLength = 1;
    
    // 对于每个位置，查看它前面的所有元素
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            // 如果当前元素大于前面的元素，可以将当前元素接在前面的子序列后面
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        // 更新最长递增子序列的长度
        maxLength = Math.max(maxLength, dp[i]);
    }
    
    return maxLength;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n²)
  - 需要两层循环遍历数组
  - 外层循环遍历每个位置，内层循环遍历当前位置前面的所有元素
  - 进阶解法（二分查找）可以将时间复杂度优化到 O(n log n)

- **空间复杂度**：O(n)
  - 需要一个长度为 n 的 dp 数组来存储中间状态

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 