---
title: 组合总和 III
date: 2024-03-27
---

## 题目描述

**🔗 题目**：[组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)  
**🏷️ 标签**：`数组` `回溯`  
**🟡 难度**：`中等`  

找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：

- 只使用数字 1 到 9
- 每个数字 最多使用一次

返回 所有可能的有效组合的列表。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

示例 1：
```
输入: k = 3, n = 7
输出: [[1,2,4]]
解释:
1 + 2 + 4 = 7
没有其他符合的组合了。
```

示例 2：
```
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
解释:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
没有其他符合的组合了。
```

示例 3：
```
输入: k = 4, n = 1
输出: []
解释: 不存在有效的组合。
在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。
```

提示:
- 2 <= k <= 9
- 1 <= n <= 60

---

## 解题思路

### 回溯算法

#### 📝 核心思想
这道题是一个典型的组合问题，我们需要从 1-9 中选择 k 个不同的数字，使它们的和为 n。由于每个数字只能使用一次，且需要找出所有可能的组合，这非常适合使用回溯算法来解决。

回溯算法的核心思想是：在搜索过程中，通过不断地选择和撤销选择，来遍历所有可能的组合。我们需要维护一个当前已选择的数字列表，每次选择一个新的数字时，都要确保：
1. 这个数字大于之前选择的所有数字（保证不重复）
2. 选择这个数字后，剩余和不会小于 0
3. 剩余可选的数字数量足够凑成 k 个数

#### 🛠️ 实现步骤
1. 定义回溯函数，参数包括：
   - 结果列表 result
   - 当前组合 current
   - 需要的数字个数 k
   - 剩余和 remain
   - 当前可选的起始数字 start

2. 在回溯函数中：
   - 如果当前组合大小等于 k，检查剩余和是否为 0
   - 如果剩余和为 0，将当前组合加入结果列表
   - 否则直接返回

3. 剪枝优化：
   - 如果剩余和小于 0，直接返回
   - 如果剩余可选数字不够凑成 k 个，直接返回

4. 从 start 到 9 遍历每个可能的数字：
   - 将当前数字加入组合
   - 递归调用回溯函数，更新参数
   - 将当前数字从组合中移除（回溯）

#### 🧩 示例分析
以 k = 3, n = 7 为例，展示回溯过程：

1. 初始状态：
   ```
   当前组合：[]
   剩余和：7
   可选数字：[1,2,3,4,5,6,7,8,9]
   ```

2. 选择数字 1：
   ```
   当前组合：[1]
   剩余和：6
   可选数字：[2,3,4,5,6,7,8,9]
   ```

3. 选择数字 2：
   ```
   当前组合：[1,2]
   剩余和：4
   可选数字：[3,4,5,6,7,8,9]
   ```

4. 选择数字 4：
   ```
   当前组合：[1,2,4]
   剩余和：0
   ✅ 找到有效组合！
   ```

5. 回溯，尝试其他可能性：
   ```
   [1,2] → [1,3] → [1,4] → ...
   [1] → [2] → [3] → ...
   ```

最终只找到一个有效组合 [1,2,4]。

---

## 代码实现

完整的可运行代码：[L0216_CombinationSumIII.java](../src/main/java/L0216_CombinationSumIII.java)

```java
public List<List<Integer>> combinationSum3(int k, int n) {
    List<List<Integer>> result = new ArrayList<>();
    backtrack(result, new ArrayList<>(), k, n, 1);
    return result;
}

private void backtrack(List<List<Integer>> result, List<Integer> current, int k, int remain, int start) {
    // 如果当前组合已经有 k 个数字
    if (current.size() == k) {
        // 如果剩余和为 0，说明找到了一个有效组合
        if (remain == 0) {
            result.add(new ArrayList<>(current));
        }
        return;
    }
    
    // 剪枝：如果剩余数字不够凑成 k 个，或者剩余和小于 0，直接返回
    if (remain < 0 || 9 - start + 1 < k - current.size()) {
        return;
    }
    
    // 尝试选择每个可能的数字
    for (int i = start; i <= 9; i++) {
        // 选择当前数字
        current.add(i);
        // 继续递归，寻找下一个数字
        backtrack(result, current, k, remain - i, i + 1);
        // 回溯，移除最后选择的数字
        current.remove(current.size() - 1);
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(C(9,k))，其中 C(9,k) 表示从 9 个数字中选择 k 个数字的组合数。
  - 在最坏情况下，我们需要遍历所有可能的组合。
  - 剪枝优化可以减少实际的遍历次数，但不影响渐进时间复杂度。

- **空间复杂度**：O(k)
  - 递归调用栈的深度最大为 k。
  - 存储当前组合的列表 current 的空间为 O(k)。
  - 注意：不考虑存储最终结果所需的空间。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 