---
title: 最小好进制
date: 2024-02-12
---

## 题目描述

**🔗 题目**：[483. 最小好进制](https://leetcode.cn/problems/smallest-good-base/)  
**🏷️ 标签**：`数学` `二分查找`  
**🔴 难度**：`困难`  

对于给定的整数 `n`, 如果n的k（k>=2）进制数的所有数位全为1，则称 k（k>=2）是 n 的一个好进制。

以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。

**示例 1：**
```
输入：n = "13"
输出："3"
解释：13 的 3 进制是 111。
```

**示例 2：**
```
输入：n = "4681"
输出："8"
解释：4681 的 8 进制是 11111。
```

**示例 3：**
```
输入：n = "1000000000000000000"
输出："999999999999999999"
解释：1000000000000000000 的 999999999999999999 进制是 11。
```

**提示：**
- `n` 的取值范围是 `[3, 10^18]`

---

## 解题思路

### 数学+二分查找法

#### 📝 核心思想
如果 n 在 k 进制下表示为 m 个 1，那么有：
```
n = k^(m-1) + k^(m-2) + ... + k + 1 = (k^m - 1) / (k - 1)
```

关键观察：
1. m 的最大值约为 log₂(n)，因为当 k=2 时，m 个 1 最小
2. 对于固定的 m，k 的值是确定的（或不存在）
3. 我们从大的 m 开始枚举（希望得到小的 k），对每个 m 用二分查找找到对应的 k

#### 🛠️ 实现步骤
1. 计算 m 的最大值：max_m = log₂(n)
2. 从 m = max_m 开始向下枚举到 m = 2
3. 对于每个 m，使用二分查找找到满足条件的 k
4. 检查 k^(m-1) + ... + k + 1 是否等于 n
5. 找到第一个满足条件的 k 即为答案
6. 如果所有 m 都不满足，返回 n-1（因为 n 在 n-1 进制下一定是 11）

#### 🧩 示例分析
以示例 1 为例：`n = 13`

```
max_m = log₂(13) ≈ 3

m = 3 时：
  k^2 + k + 1 = 13
  二分查找找 k: k ∈ [2, 12]
  k = 3: 9 + 3 + 1 = 13 ✓
  
答案：3
```

---

## 代码实现

```java
public class L0483_SmallestGoodBase {
    public String smallestGoodBase(String n) {
        long num = Long.parseLong(n);
        
        // m 的最大值
        int maxM = (int) (Math.log(num) / Math.log(2)) + 1;
        
        // 从大的 m 开始枚举（希望得到小的 k）
        for (int m = maxM; m >= 2; m--) {
            // 二分查找 k
            long left = 2;
            long right = (long) Math.pow(num, 1.0 / (m - 1)) + 1;
            
            while (left <= right) {
                long mid = left + (right - left) / 2;
                long sum = calculateSum(mid, m);
                
                if (sum == num) {
                    return String.valueOf(mid);
                } else if (sum < num) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        
        // 如果没有找到，返回 n-1
        return String.valueOf(num - 1);
    }
    
    // 计算 k^(m-1) + k^(m-2) + ... + k + 1
    private long calculateSum(long k, int m) {
        long sum = 0;
        long term = 1;
        
        for (int i = 0; i < m; i++) {
            // 防止溢出
            if (sum > Long.MAX_VALUE - term) {
                return Long.MAX_VALUE;
            }
            sum += term;
            
            // 防止溢出
            if (i < m - 1) {
                if (term > Long.MAX_VALUE / k) {
                    return Long.MAX_VALUE;
                }
                term *= k;
            }
        }
        
        return sum;
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(log²n)，需要枚举 O(logn) 个 m 值，每个 m 需要 O(logn) 的二分查找。
- **空间复杂度**：O(1)，只使用了常数额外空间。

---

## 相关题目

- [🔗 504. 七进制数](https://leetcode.cn/problems/base-7/)
- [🔗 168. Excel表列名称](https://leetcode.cn/problems/excel-sheet-column-title/)

---

## 总结

这道题是数学和二分查找的综合应用。解题的关键在于：
1. 理解好进制的数学定义
2. 观察到 m 的取值范围有限
3. 对于每个 m，使用二分查找找 k
4. 注意处理大数溢出问题

通过这道题，我们可以学习到：
1. 如何将问题转化为数学公式
2. 二分查找在数学问题中的应用
3. 大数运算中的溢出处理技巧

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 