---
title: 螺旋矩阵 II
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)  
**🏷️ 标签**：`数组` `矩阵` `模拟`  
**🟡 难度**：`中等`  

给你一个正整数 n ，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

示例 1：
```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]

图示：
1 → 2 → 3
        ↓
8   9   4
↑       ↓
7 ← 6 ← 5

矩阵生成过程：
步骤1:    步骤2:    步骤3:    步骤4:    最终:
1 2 3     1 2 3     1 2 3     1 2 3     1 2 3
. . .  →  . . 4  →  8 9 4  →  8 9 4  →  8 9 4
. . .     . . 5     7 6 5     7 6 5     7 6 5
```

示例 2：
```
输入：n = 1
输出：[[1]]

图示：
[1]
```

提示：
- 1 <= n <= 20

---

## 解题思路
### 边界模拟法

#### 📝 核心思想
使用四个变量分别记录上、下、左、右边界，按照顺时针方向遍历矩阵。每遍历完一条边，就将对应的边界向内收缩，直到所有元素都被填充完。与第 54 题（螺旋矩阵）类似，但本题是生成矩阵而不是读取矩阵。

#### 🛠️ 实现步骤
1. 创建一个 n × n 的矩阵
2. 定义四个边界变量：top、bottom、left、right
3. 定义要填入的数字 num，初始值为 1
4. 按照顺时针顺序填充矩阵：
   - 从左到右填充上边界，然后上边界下移
   - 从上到下填充右边界，然后右边界左移
   - 从右到左填充下边界，然后下边界上移
   - 从下到上填充左边界，然后左边界右移
5. 每完成一条边的填充，检查边界是否交叉，如果交叉则结束填充

#### 🧩 示例分析
以 n = 3 为例，演示矩阵的生成过程：

初始状态：
```
边界：top=0, bottom=2, left=0, right=2
num=1

.  .  .
.  .  .
.  .  .
```

第一轮填充：
```
1. 填充上边界（→）：
1→2→3
.  .  .
.  .  .

2. 填充右边界（↓）：
1  2  3
.  .  4↓
.  .  5

3. 填充下边界（←）：
1  2  3
.  .  4
7←6←5

4. 填充左边界（↑）：
1  2  3
8↑ .  4
7  6  5
```

第二轮填充：
```
更新边界：top=1, bottom=1, left=1, right=1
只剩中心点：
1  2  3
8  9  4
7  6  5
```

填充过程表：
| 步骤 | 当前数字 | 边界变化 | 填充方向 | 矩阵状态 |
|-----|---------|---------|----------|----------|
| 初始 | 1 | t=0,b=2,l=0,r=2 | - | ... |
| 1 | 1 | → | 右 | 1.. |
| 2 | 2 | → | 右 | 12. |
| 3 | 3 | → | 右 | 123 |
| 4 | 4 | ↓ | 下 | 123,..4 |
| 5 | 5 | ↓ | 下 | 123,..4,..5 |
| 6 | 6 | ← | 左 | 123,..4,765 |
| 7 | 7 | ← | 左 | 123,8.4,765 |
| 8 | 8 | ↑ | 上 | 123,8.4,765 |
| 9 | 9 | - | 中心 | 123,894,765 |

边界收缩示意图：
```
第一轮：           第二轮：
┌─────────┐       ┌─────────┐
│ 1  2  3 │       │ 1  2  3 │
│ .  .  4 │  →    │ 8 [9] 4 │
│ 7  6  5 │       │ 7  6  5 │
└─────────┘       └─────────┘
```

---

## 代码实现

完整的可运行代码：[L0059_SpiralMatrixII.java](../src/main/java/L0059_SpiralMatrixII.java)

```java
public int[][] generateMatrix(int n) {
    // 创建 n x n 的矩阵
    int[][] matrix = new int[n][n];
    
    // 定义四个边界
    int top = 0;
    int bottom = n - 1;
    int left = 0;
    int right = n - 1;
    
    // 要填入的数字，从 1 开始
    int num = 1;
    
    while (true) {
        // 从左到右填充上边界
        for (int i = left; i <= right; i++) {
            matrix[top][i] = num++;
        }
        // 上边界向下移动
        top++;
        if (top > bottom) break;
        
        // 从上到下填充右边界
        for (int i = top; i <= bottom; i++) {
            matrix[i][right] = num++;
        }
        // 右边界向左移动
        right--;
        if (left > right) break;
        
        // 从右到左填充下边界
        for (int i = right; i >= left; i--) {
            matrix[bottom][i] = num++;
        }
        // 下边界向上移动
        bottom--;
        if (top > bottom) break;
        
        // 从下到上填充左边界
        for (int i = bottom; i >= top; i--) {
            matrix[i][left] = num++;
        }
        // 左边界向右移动
        left++;
        if (left > right) break;
    }
    
    return matrix;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n²)，其中 n 是矩阵的边长。需要填充 n² 个格子。
- **空间复杂度**：O(1)，除了用于存储结果的矩阵外，只使用了常数级别的额外空间。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 