---
title: 最大连续1的个数 II
date: 2024-02-12
---

## 题目描述

**🔗 题目**：[481. 最大连续1的个数 II](https://leetcode.cn/problems/max-consecutive-ones-ii/)  
**🏷️ 标签**：`数组` `动态规划` `滑动窗口`  
**🟡 难度**：`中等`  

给定一个二进制数组 `nums`，如果最多可以翻转一个 `0`，则返回数组中连续 `1` 的最大个数。

**示例 1：**
```
输入：nums = [1,0,1,1,0]
输出：4
解释：翻转第一个 0 可以得到最长的连续 1。
     当翻转以后，最大长度为 4。
```

**示例 2：**
```
输入：nums = [1,0,1,1,0,1]
输出：4
解释：翻转第一个 0 可以得到最长的连续 1。
     翻转第二个 0 可以得到最长的连续 1。
```

**提示：**
- `1 <= nums.length <= 10^5`
- `nums[i]` 不是 `0` 就是 `1`

**进阶：**
如果输入的数字是作为无限流逐个输入如何处理？换句话说，内存不能存储所有数字。您能否想出一个时间复杂度为 `O(n)` 的解决方案？

---

## 解题思路

### 滑动窗口法

#### 📝 核心思想
使用滑动窗口维护一个最多包含一个 0 的区间。当窗口内的 0 的个数超过 1 个时，需要移动左边界。

#### 🛠️ 实现步骤
1. 使用两个指针 left 和 right 表示窗口的左右边界
2. right 指针不断右移，扩大窗口
3. 记录窗口内 0 的个数
4. 当 0 的个数超过 1 时，移动 left 指针直到窗口内只有一个 0
5. 在每一步更新最大长度

#### 🧩 示例分析
以示例 1 为例：`nums = [1,0,1,1,0]`

```
初始：left=0, right=0, zeros=0, maxLen=0

right=0: nums[0]=1, zeros=0, maxLen=1
right=1: nums[1]=0, zeros=1, maxLen=2
right=2: nums[2]=1, zeros=1, maxLen=3
right=3: nums[3]=1, zeros=1, maxLen=4
right=4: nums[4]=0, zeros=2 (超过1)
  移动left: left=0, nums[0]=1
  移动left: left=1, nums[1]=0, zeros=1
  此时区间[2,4]，长度=3
  但之前记录的maxLen=4

答案：4
```

### 动态规划法

#### 📝 核心思想
维护两个状态：
- `noFlip`: 不使用翻转机会时的最长连续1
- `oneFlip`: 使用一次翻转机会时的最长连续1

---

## 代码实现

```java
public class L0481_MaxConsecutiveOnesII {
    // 方法一：滑动窗口
    public int findMaxConsecutiveOnes(int[] nums) {
        int left = 0;
        int zeros = 0;
        int maxLen = 0;
        
        for (int right = 0; right < nums.length; right++) {
            if (nums[right] == 0) {
                zeros++;
            }
            
            // 当窗口内的0超过1个时，移动左边界
            while (zeros > 1) {
                if (nums[left] == 0) {
                    zeros--;
                }
                left++;
            }
            
            maxLen = Math.max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
    
    // 方法二：动态规划
    public int findMaxConsecutiveOnesDP(int[] nums) {
        int noFlip = 0;  // 不使用翻转机会
        int oneFlip = 0; // 使用一次翻转机会
        int maxLen = 0;
        
        for (int num : nums) {
            if (num == 1) {
                noFlip++;
                oneFlip++;
            } else {
                // 遇到0，使用翻转机会
                oneFlip = noFlip + 1;
                noFlip = 0;
            }
            maxLen = Math.max(maxLen, oneFlip);
        }
        
        return maxLen;
    }
}
```

---

## 复杂度分析

### 滑动窗口法
- **时间复杂度**：O(n)，每个元素最多被访问两次。
- **空间复杂度**：O(1)，只使用了常数额外空间。

### 动态规划法
- **时间复杂度**：O(n)，遍历一次数组。
- **空间复杂度**：O(1)，只使用了常数额外空间。

---

## 相关题目

- [🔗 485. 最大连续1的个数](https://leetcode.cn/problems/max-consecutive-ones/)
- [🔗 1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

---

## 总结

这道题是滑动窗口的经典应用。解题的关键在于：
1. 理解"最多翻转一个0"等价于"窗口内最多有一个0"
2. 使用滑动窗口维护满足条件的区间
3. 动态规划方法更加简洁，但滑动窗口更加直观

通过这道题，我们可以学习到：
1. 滑动窗口在处理连续子数组问题中的应用
2. 如何维护窗口的有效性
3. 动态规划状态设计的技巧

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 