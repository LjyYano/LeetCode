---
title: 青蛙过河
date: 2025-02-11
---

## 题目描述

**🔗 题目**：[青蛙过河](https://leetcode.cn/problems/frog-jump/description/)  
**🏷️ 标签**：`动态规划` `数组` `哈希表`  
**🟡 难度**：`困难`  

一只青蛙想要过河。假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。

给你一个长度为 n 的数组 stones ，其中 stones[i] 表示第 i 块石子的位置，每个位置只能有一块石子。请你判断青蛙能否成功过河（即能否到达最后一块石子）。开始时，青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃 1 个单位。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。

示例 1：
输入：stones = [0,1,3,5,6,8,12,17]
输出：true
解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 块石子（即最后一块石子）。

示例 2：
输入：stones = [0,1,2,3,4,8,9,11]
输出：false
解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。

提示：
- 2 <= stones.length <= 2000
- 0 <= stones[i] <= 2^31 - 1
- stones[0] == 0
- stones 按严格升序排列

---

## 解题思路

### 动态规划

#### 📝 核心思想
使用二维动态规划数组 dp[i][k] 表示能否通过跳 k 步到达位置 i。对于每个位置，我们需要考虑从之前的哪些位置可以跳到当前位置，以及跳跃的步数是否合法。

#### 🛠️ 实现步骤
1. 创建二维布尔数组 dp[n][n+1]，其中 n 是石子的数量
2. 初始化第一步，dp[0][1] = true，表示从位置 0 可以跳 1 步
3. 遍历每个位置 i，对于每个位置：
   - 遍历之前的所有位置 j
   - 计算从 j 到 i 需要跳跃的步数 k
   - 如果从位置 j 可以跳 k 步，则更新 dp[i][k-1]、dp[i][k] 和 dp[i][k+1]
4. 检查最后一个位置是否可达

#### 🧩 示例分析
以 stones = [0,1,3,5,6,8,12,17] 为例：

| 位置 | 石子位置 | 可能的跳跃步数 | 是否可达 | 解释 |
|-----|---------|--------------|---------|------|
| 0 | 0 | [1] | ✅ | 初始位置，可以跳 1 步 |
| 1 | 1 | [1,2] | ✅ | 从位置 0 跳 1 步可达 |
| 2 | 3 | [2,3] | ✅ | 从位置 1 跳 2 步可达 |
| 3 | 5 | [2,3,4] | ✅ | 从位置 2 跳 2 步可达 |
| 4 | 6 | [1,2,3] | ✅ | 从位置 3 跳 1 步可达 |
| 5 | 8 | [2,3,4] | ✅ | 从位置 4 跳 2 步可达 |
| 6 | 12 | [4,5,6] | ✅ | 从位置 5 跳 4 步可达 |
| 7 | 17 | [5,6,7] | ✅ | 从位置 6 跳 5 步可达 |

通过动态规划，我们可以看到青蛙能够成功到达最后一个石子。

---

## 代码实现

完整的可运行代码：[L0403_FrogJump.java](../src/main/java/L0403_FrogJump.java)

```java
public boolean canCross(int[] stones) {
    int n = stones.length;
    // dp[i][k] 表示能否通过跳 k 步到达位置 i
    boolean[][] dp = new boolean[n][n + 1];
    // 初始状态：第一步只能跳 1 个单位
    dp[0][1] = true;
    
    // 遍历每个位置
    for (int i = 1; i < n; i++) {
        // 遍历之前的所有位置
        for (int j = 0; j < i; j++) {
            // 计算从位置 j 跳到位置 i 需要的步数
            int k = stones[i] - stones[j];
            
            // 如果步数超过了 n，说明不可能跳到这个位置
            if (k > n) {
                continue;
            }
            
            // 如果从位置 j 可以跳 k-1、k 或 k+1 步，那么就可以跳到位置 i
            if (dp[j][k]) {
                dp[i][k] = true;
                if (k - 1 >= 0) {
                    dp[i][k - 1] = true;
                }
                if (k + 1 <= n) {
                    dp[i][k + 1] = true;
                }
            }
        }
    }
    
    // 检查是否能到达最后一个位置
    for (int k = 0; k <= n; k++) {
        if (dp[n - 1][k]) {
            return true;
        }
    }
    return false;
}
```

---

## 复杂度分析

- **时间复杂度：** O(n²)，其中 n 是石子的数量。我们需要遍历每个位置，对于每个位置还需要遍历之前的所有位置。  
- **空间复杂度：** O(n²)，需要一个 n × (n+1) 的二维数组来存储动态规划的状态。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 