---
title: 猜数字大小 II
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[猜数字大小 II](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/)  
**🏷️ 标签**：`数学` `动态规划` `博弈`  
**🟡 难度**：`中等`  

我们正在玩一个猜数游戏，游戏规则如下：
1. 我从 1 到 n 之间选择一个数字。
2. 你来猜我选了哪个数字。
3. 如果你猜到正确的数字，就会 赢得游戏 。
4. 如果你猜错了，那么我会告诉你，你猜测的数字比我选出的数字是大了还是小了。
5. 你可以通过支付 x 元获得数字 x 的提示。

给你一个数字 n ，返回你确保获胜的最小现金数，不管我选择那个数字。

示例 1：
```
输入：n = 10
输出：16
解释：制胜策略如下：
- 数字范围是 [1,10] 。你先猜测数字为 7 。
    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
    - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
        - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
        - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
        - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
    - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
        - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
        - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
            - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
            - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
            - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
        - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
            - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
            - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。
```

示例 2：
```
输入：n = 1
输出：0
解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。
```

示例 3：
```
输入：n = 2
输出：1
解释：有两个可能的数字 1 和 2 。
- 你可以先猜 1 。
    - 如果这是我选中的数字，你的总费用为 $0 。
    - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
最糟糕的情况下，你需要支付 $1 。
```

提示：
- 1 <= n <= 200

---

## 解题思路
### 动态规划

#### 📝 核心思想
这是一个极小化极大问题，我们需要：
1. 在每次猜测时，选择一个数字，使得在最坏情况下的开销最小
2. 使用动态规划来记录并计算不同区间内的最优解
3. 考虑所有可能的猜测点，选择其中最优的方案

关键点：
- 对于每个区间 [i,j]，我们需要考虑在该区间内猜测每个数字的情况
- 每次猜测都会产生一个开销，加上后续子问题的最优解
- 我们需要在所有可能的猜测中选择最坏情况下开销最小的方案

#### 🛠️ 实现步骤
1. 状态定义：
   - dp[i][j] 表示在范围 [i,j] 内确保获胜的最小现金数

2. 状态转移：
   - 对于每个区间 [i,j]
   - 尝试每个可能的猜测点 k
   - dp[i][j] = min(max(dp[i][k-1], dp[k+1][j]) + k)
   - 其中 k 从 i 到 j 遍历

3. 边界条件：
   - 当 i >= j 时，dp[i][j] = 0
   - 因为区间长度为 1 或 0 时不需要猜测

#### 🧩 示例分析
以 n = 3 为例，分析动态规划的过程：

1. 初始状态：
```
dp[i][i] = 0 (对角线)
```

2. 长度为 2 的区间：
```
dp[1][2] = 1 (猜 1，最坏情况需要再猜 2，花费 1)
dp[2][3] = 2 (猜 2，最坏情况需要再猜 3，花费 2)
```

3. 长度为 3 的区间：
```
dp[1][3] = 2 (最优策略是猜 2)
- 猜 1：花费 1 + dp[2][3] = 1 + 2 = 3
- 猜 2：花费 2 + max(dp[1][1], dp[3][3]) = 2
- 猜 3：花费 3 + dp[1][2] = 3 + 1 = 4
```

为什么选择猜 2？
- 猜 1：最坏情况是数字更大，需要在 [2,3] 中继续猜
- 猜 2：最坏情况是数字在 [1,1] 或 [3,3] 中
- 猜 3：最坏情况是数字更小，需要在 [1,2] 中继续猜
- 在所有选择中，猜 2 的最坏情况开销最小

---

## 代码实现

完整的可运行代码：[L0375_GuessNumberHigherOrLowerII.java](../src/main/java/L0375_GuessNumberHigherOrLowerII.java)

```java
public int getMoneyAmount(int n) {
    // dp[i][j] 表示在范围 [i,j] 内确保获胜的最小现金数
    int[][] dp = new int[n + 1][n + 1];
    
    // 初始化 dp 数组
    for (int i = 0; i <= n; i++) {
        Arrays.fill(dp[i], 0);
    }
    
    // 计算不同长度的区间
    for (int len = 2; len <= n; len++) {
        // 遍历所有可能的起点
        for (int start = 1; start <= n - len + 1; start++) {
            int end = start + len - 1;
            // 初始化为最大值
            dp[start][end] = Integer.MAX_VALUE;
            
            // 尝试每个可能的猜测点
            for (int guess = start; guess <= end; guess++) {
                // 当前猜测点的最坏情况开销
                int cost = guess + Math.max(
                    guess > start ? dp[start][guess - 1] : 0,
                    guess < end ? dp[guess + 1][end] : 0
                );
                // 更新最小开销
                dp[start][end] = Math.min(dp[start][end], cost);
            }
        }
    }
    
    return dp[1][n];
}
```

---

## 复杂度分析

- **时间复杂度**：O(n³)
  - 需要计算所有可能的区间，区间数量为 O(n²)
  - 对于每个区间，需要尝试每个可能的猜测点，复杂度为 O(n)
  - 总时间复杂度为 O(n³)

- **空间复杂度**：O(n²)
  - 需要一个 n×n 的二维数组来存储动态规划的状态
  - 空间复杂度为 O(n²)

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 