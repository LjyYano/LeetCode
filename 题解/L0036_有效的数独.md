---
title: 有效的数独
date: 2024-02-08
---

# 36. 有效的数独

## 题目链接

[有效的数独](https://leetcode.cn/problems/valid-sudoku/)

## 标签

- 数组
- 哈希表
- 矩阵

## 难度

中等

## 题目大意

给定一个 9x9 的数独方格 `board`，判断已经填入的数字是否满足数独规则：

1. 数字 1-9 在每一行只能出现一次
2. 数字 1-9 在每一列只能出现一次
3. 数字 1-9 在每一个 3x3 的子方格内只能出现一次

注意：
- 一个有效的数独（部分已被填充）不一定是可解的
- 只需要根据以上规则，验证已经填入的数字是否有效即可
- 空白格用 '.' 表示

## 解题思路

这道题的关键是要高效地判断数字在行、列和 3x3 子方格中是否重复出现。我们可以使用三个二维布尔数组来分别记录每个数字在行、列和子方格中的出现情况。

具体思路如下：

1. 创建三个 9x9 的布尔数组：
   - `rows[i][num]` 表示数字 num+1 是否在第 i 行出现过
   - `cols[j][num]` 表示数字 num+1 是否在第 j 列出现过
   - `boxes[boxIndex][num]` 表示数字 num+1 是否在第 boxIndex 个 3x3 子方格中出现过

2. 遍历整个数独方格：
   - 跳过空格（'.'）
   - 对于每个数字，计算它所在的行号、列号和子方格索引
   - 检查这个数字是否已经在对应的行、列或子方格中出现过
   - 如果出现过，返回 false
   - 如果没出现过，标记这个数字在对应位置已经出现

3. 如果遍历完整个数独方格都没有发现重复数字，返回 true

### 代码实现中的技巧

1. 将字符转换为数字：
   ```java
   int num = board[i][j] - '1';  // 将字符'1'-'9'转换为数字0-8
   ```

2. 计算 3x3 子方格的索引：
   ```java
   int boxIndex = (i / 3) * 3 + j / 3;
   ```
   这个公式可以将 9x9 的方格映射到 9 个 3x3 的子方格，每个子方格有唯一的索引。

## 复杂度分析

- 时间复杂度：O(1)，因为输入规模是固定的 9x9
- 空间复杂度：O(1)，使用了固定大小的数组

## 代码

```java
public boolean isValidSudoku(char[][] board) {
    boolean[][] rows = new boolean[9][9];
    boolean[][] cols = new boolean[9][9];
    boolean[][] boxes = new boolean[9][9];
    
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] == '.') {
                continue;
            }
            
            int num = board[i][j] - '1';
            int boxIndex = (i / 3) * 3 + j / 3;
            
            if (rows[i][num] || cols[j][num] || boxes[boxIndex][num]) {
                return false;
            }
            
            rows[i][num] = true;
            cols[j][num] = true;
            boxes[boxIndex][num] = true;
        }
    }
    
    return true;
}
```

## 相关题目

- [37. 解数独](https://leetcode.cn/problems/sudoku-solver/) - 困难
- [2133. 检查是否每一行每一列都包含全部整数](https://leetcode.cn/problems/check-if-every-row-and-column-contains-all-numbers/) - 简单 