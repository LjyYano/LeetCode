---
title: 有效的数独
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[有效的数独](https://leetcode.cn/problems/valid-sudoku/)  
**🏷️ 标签**：`数组` `哈希表` `矩阵`  
**🟡 难度**：`中等`  

请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

1. 数字 1-9 在每一行只能出现一次。
2. 数字 1-9 在每一列只能出现一次。 
3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

注意：
- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 '.' 表示。

示例 1：
```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".",".","6",".",".","."]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
```

示例 2：
```
输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".",".","6",".",".","."]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与示例 1 相同。但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

提示：
- board.length == 9
- board[i].length == 9
- board[i][j] 是一位数字（1-9）或者 '.'

---

## 解题思路

### 数组标记法

#### 📝 核心思想

使用三个二维布尔数组分别记录每个数字在行、列和 3x3 子方格中的出现情况，通过一次遍历即可判断数独是否有效。

#### 🛠️ 实现步骤

1. 创建三个 9x9 的布尔数组：
   - rows[i][num] 表示数字 num+1 是否在第 i 行出现过
   - cols[j][num] 表示数字 num+1 是否在第 j 列出现过
   - boxes[boxIndex][num] 表示数字 num+1 是否在第 boxIndex 个 3x3 子方格中出现过

2. 遍历整个数独方格：
   - 跳过空格（'.'）
   - 将当前数字转换为 0-8 的索引
   - 计算当前位置所在的 3x3 子方格索引
   - 检查数字是否重复出现
   - 标记数字的出现位置

3. 如果遍历完成没有发现重复数字，返回 true

#### 🧩 示例分析

以示例 2 中的错误情况为例：

| 步骤 | 位置 (i,j) | 数字 | 3x3 格子索引 | 检查结果 | 说明 |
|-----|------------|------|--------------|----------|------|
| 1 | (0,0) | 8 | 0 | 未出现 | 第一个 8 合法 |
| 2 | (0,1) | 3 | 0 | 未出现 | 3 合法 |
| ... | ... | ... | ... | ... | ... |
| 8 | (3,0) | 8 | 0 | 已出现 | 在同一个 3x3 格子中发现重复的 8 |

当扫描到第二个 8 时，发现它与第一个 8 在同一个 3x3 子方格中，此时返回 false。

---

## 代码实现

完整的可运行代码：[L0036_ValidSudoku.java](../src/main/java/L0036_ValidSudoku.java)

```java
public boolean isValidSudoku(char[][] board) {
    // 使用三个二维数组分别记录行、列、3x3宫格中数字出现的情况
    boolean[][] rows = new boolean[9][9];
    boolean[][] cols = new boolean[9][9];
    boolean[][] boxes = new boolean[9][9];
    
    // 遍历整个数独
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            // 跳过空格
            if (board[i][j] == '.') {
                continue;
            }
            
            // 将字符转换为数字(0-8)
            int num = board[i][j] - '1';
            
            // 计算当前格子所在的3x3宫格的索引
            int boxIndex = (i / 3) * 3 + j / 3;
            
            // 检查当前数字是否已经在对应的行、列或3x3宫格中出现过
            if (rows[i][num] || cols[j][num] || boxes[boxIndex][num]) {
                return false;
            }
            
            // 标记当前数字在对应的行、列和3x3宫格中已经出现
            rows[i][num] = true;
            cols[j][num] = true;
            boxes[boxIndex][num] = true;
        }
    }
    
    return true;
}
```

---

## 复杂度分析

- **时间复杂度**：O(1)
  - 由于数独大小固定为 9x9，所以遍历整个数独的时间是常数级的
  - 每个位置的检查和标记操作也是 O(1) 的

- **空间复杂度**：O(1)
  - 使用了三个 9x9 的布尔数组，大小固定
  - 不随输入规模变化

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 