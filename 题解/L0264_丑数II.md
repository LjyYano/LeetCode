---
title: 丑数 II
date: 2025-02-10
---

## 题目描述

**🔗 题目**：[丑数 II](https://leetcode.cn/problems/ugly-number-ii/)  
**🏷️ 标签**：`数组` `哈希表` `数学` `动态规划` `堆（优先队列）`  
**🟡 难度**：`中等`  

给你一个整数 n ，请你找出并返回第 n 个 丑数 。

丑数 就是只包含质因数 2、3 和 5 的正整数。

示例 1：
```
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
```

示例 2：
```
输入：n = 1
输出：1
解释：1 通常被视为丑数。
```

提示：
- 1 <= n <= 1690

---

## 解题思路
### 动态规划 + 三指针

#### 📝 核心思想
1. 丑数的生成规律：每个丑数都是由之前的某个丑数乘以 2、3 或 5 得到的
2. 使用动态规划数组 dp 存储已经生成的丑数，dp[i] 表示第 i+1 个丑数
3. 使用三个指针 p2、p3、p5，分别指向下一个要乘以 2、3、5 的丑数的位置

#### 🛠️ 实现步骤
1. 初始化：
   - 创建长度为 n 的动态规划数组 dp
   - 第一个丑数是 1，即 dp[0] = 1
   - 初始化三个指针 p2 = p3 = p5 = 0
2. 生成丑数：
   - 对于每个位置 i，计算三个候选丑数：
     * next2 = dp[p2] × 2
     * next3 = dp[p3] × 3
     * next5 = dp[p5] × 5
   - 选择三个候选中的最小值作为新的丑数
   - 更新对应的指针
3. 返回第 n 个丑数，即 dp[n-1]

#### 🧩 示例分析
以 n = 10 为例，演示丑数的生成过程：

| 步骤 | dp 数组 | p2 | p3 | p5 | next2 | next3 | next5 | 选择的数 | 说明 |
|-----|---------|-----|-----|-----|--------|--------|--------|-----------|------|
| 初始 | [1] | 0 | 0 | 0 | 2 | 3 | 5 | - | 初始状态 |
| 1 | [1,2] | 1 | 0 | 0 | 4 | 3 | 5 | 2 | 2 最小，p2++ |
| 2 | [1,2,3] | 1 | 1 | 0 | 4 | 6 | 5 | 3 | 3 最小，p3++ |
| 3 | [1,2,3,4] | 2 | 1 | 0 | 6 | 6 | 5 | 4 | 4 最小，p2++ |
| 4 | [1,2,3,4,5] | 2 | 1 | 1 | 6 | 6 | 10 | 5 | 5 最小，p5++ |
| 5 | [1,2,3,4,5,6] | 3 | 2 | 1 | 8 | 9 | 10 | 6 | 6 最小，p2++,p3++ |
| 6 | [1,2,3,4,5,6,8] | 4 | 2 | 1 | 10 | 9 | 10 | 8 | 8 最小，p2++ |
| 7 | [1,2,3,4,5,6,8,9] | 4 | 3 | 1 | 10 | 12 | 10 | 9 | 9 最小，p3++ |
| 8 | [1,2,3,4,5,6,8,9,10] | 5 | 3 | 2 | 12 | 12 | 15 | 10 | 10 最小，p2++ |
| 9 | [1,2,3,4,5,6,8,9,10,12] | 6 | 4 | 2 | 16 | 15 | 15 | 12 | 12 最小，p2++,p3++ |

可以看到，通过三个指针的移动，我们可以有序地生成所有的丑数。每次我们都从三个候选数中选择最小的一个，这样可以保证生成的丑数序列是有序的。

---

## 代码实现

完整的可运行代码：[L0264_UglyNumberII.java](../src/main/java/L0264_UglyNumberII.java)

```java
public int nthUglyNumber(int n) {
    // dp[i] 表示第 i+1 个丑数
    int[] dp = new int[n];
    // 第一个丑数是 1
    dp[0] = 1;
    
    // p2、p3、p5 分别表示下一个丑数是当前指针指向的丑数乘以对应的质因数
    int p2 = 0, p3 = 0, p5 = 0;
    
    // 从第二个丑数开始计算
    for (int i = 1; i < n; i++) {
        // 下一个丑数是三个候选中的最小值
        int next2 = dp[p2] * 2;
        int next3 = dp[p3] * 3;
        int next5 = dp[p5] * 5;
        dp[i] = Math.min(next2, Math.min(next3, next5));
        
        // 如果最小值是某个候选值，对应的指针向前移动
        if (dp[i] == next2) {
            p2++;
        }
        if (dp[i] == next3) {
            p3++;
        }
        if (dp[i] == next5) {
            p5++;
        }
    }
    
    // 返回第 n 个丑数
    return dp[n - 1];
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)。需要计算数组中的 n 个元素，每个元素的计算是 O(1) 的。
- **空间复杂度**：O(n)。需要一个长度为 n 的数组来存储所有的丑数。

---

## LeetCode 题解
     
本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。
     
<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 