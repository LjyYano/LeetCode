---
title: 在排序数组中查找元素的第一个和最后一个位置
date: 2025-02-08
---

## 题目描述

**🔗 题目**：[在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)  
**🏷️ 标签**：`数组` `二分查找`  
**🟡 难度**：`中等`  

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**
```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**
```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**
```
输入：nums = [], target = 0
输出：[-1,-1]
```

**提示：**
- 0 <= nums.length <= 10⁵
- -10⁹ <= nums[i] <= 10⁹
- nums 是一个非递减数组
- -10⁹ <= target <= 10⁹

---

## 解题思路

### 二分查找

#### 📝 核心思想

这道题的核心思想是使用二分查找的变体。由于数组是有序的，我们可以使用二分查找来实现 O(log n) 的时间复杂度。但是普通的二分查找只能找到一个目标值的位置，而我们需要找到目标值的第一个和最后一个位置。因此，我们需要进行两次二分查找：
1. 第一次查找目标值的左边界（第一个出现的位置）
2. 第二次查找目标值的右边界（最后一个出现的位置）

#### 🛠️ 实现步骤

1. 定义一个辅助函数 `findBound`，用于查找目标值的边界位置：
   - 参数 `isLeft` 为 true 时查找左边界
   - 参数 `isLeft` 为 false 时查找右边界

2. 在 `findBound` 函数中：
   - 使用二分查找的基本框架
   - 当找到目标值时，根据 `isLeft` 参数决定继续向左还是向右查找
   - 对于左边界，如果当前位置是数组首位或前一个数不等于目标值，则找到左边界
   - 对于右边界，如果当前位置是数组末位或后一个数不等于目标值，则找到右边界

3. 在主函数中：
   - 分别调用 `findBound` 函数查找左右边界
   - 返回包含两个边界位置的数组

#### 🧩 示例分析

以示例 1 为例，数组 `[5,7,7,8,8,10]`，目标值 `target = 8`：

1. 查找左边界的过程：
   ```
   初始状态：[5, 7, 7, 8, 8, 10]
            ↑        ↑        ↑
           left    mid     right
   
   第一次：mid = 8，等于 target
   检查左边：nums[mid-1] = 7 != target
   找到左边界：3
   ```

2. 查找右边界的过程：
   ```
   初始状态：[5, 7, 7, 8, 8, 10]
            ↑        ↑        ↑
           left    mid     right
   
   第一次：mid = 8，等于 target
   检查右边：nums[mid+1] = 8 == target
   继续向右查找
   
   第二次：[5, 7, 7, 8, 8, 10]
                     ↑  ↑  ↑
                   left mid right
   
   mid = 8，等于 target
   检查右边：nums[mid+1] = 10 != target
   找到右边界：4
   ```

---

## 代码实现

```java
public class L0034_FindFirstAndLastPositionOfElementInSortedArray {

    public static int[] searchRange(int[] nums, int target) {
        // 分别查找左边界和右边界
        int leftBound = findBound(nums, target, true);
        int rightBound = findBound(nums, target, false);
        return new int[]{leftBound, rightBound};
    }

    // 查找边界的辅助函数
    // isLeft 为 true 时查找左边界，为 false 时查找右边界
    private static int findBound(int[] nums, int target, boolean isLeft) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                if (isLeft) {
                    // 查找左边界时，即使找到了目标值也继续向左查找
                    if (mid == 0 || nums[mid - 1] != target) {
                        return mid;
                    }
                    right = mid - 1;
                } else {
                    // 查找右边界时，即使找到了目标值也继续向右查找
                    if (mid == nums.length - 1 || nums[mid + 1] != target) {
                        return mid;
                    }
                    left = mid + 1;
                }
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1;
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(log n)，其中 n 是数组的长度。二分查找的时间复杂度为 O(log n)，我们进行了两次二分查找。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 