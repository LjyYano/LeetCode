---
title: 子集
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[子集](https://leetcode.cn/problems/subsets/)  
**🏷️ 标签**：`数组` `回溯` `位运算`  
**🟡 难度**：`中等`  

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例 1：
```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

示例 2：
```
输入：nums = [0]
输出：[[],[0]]
```

提示：
- 1 <= nums.length <= 10
- -10 <= nums[i] <= 10
- nums 中的所有元素 互不相同

---

## 解题思路
### 回溯算法

#### 📝 核心思想
本题使用回溯算法来生成所有可能的子集。对于每个元素，我们都有两种选择：选择它或不选择它。通过递归地做出这些选择，我们可以生成所有可能的子集。

主要思路如下：
1. 从空集开始，逐步考虑每个元素
2. 对于每个元素，我们可以选择将其加入当前子集，或者跳过它
3. 每个状态都是一个有效的子集，需要保存到结果中
4. 使用 start 参数来控制当前可以选择的元素范围，避免重复

#### 🛠️ 实现步骤
1. 初始化：
   - 创建结果列表 result 存储所有子集
   - 创建当前子集列表 current
   - 从第一个元素开始尝试

2. 回溯过程：
   - 将当前子集加入结果集（每个状态都是有效的子集）
   - 从当前位置开始，尝试选择每个可能的元素
   - 选择一个元素后，继续递归处理后面的元素
   - 回溯时移除最后选择的元素

3. 优化说明：
   - 使用 start 参数控制可选范围，避免重复
   - 每次递归从 start 开始，保证元素选择的顺序性
   - 不需要额外的终止条件，因为 start >= nums.length 时自然结束

#### 🧩 示例分析
以 nums = [1,2,3] 为例，分析回溯过程：

```
递归树形结构：
                        []
            /           |           \
          [1]          [2]          [3]
        /     \         |
    [1,2]    [1,3]    [2,3]
      |
  [1,2,3]
```

详细的选择过程：

| 步骤 | 当前子集 | 可选范围 | 操作 | 结果集 |
|-----|---------|---------|------|--------|
| 1 | [] | [1,2,3] | 加入空集 | [[]] |
| 2 | [] | [1,2,3] | 选择 1 | [[]] |
| 3 | [1] | [2,3] | 加入当前集 | [[], [1]] |
| 4 | [1] | [2,3] | 选择 2 | [[], [1]] |
| 5 | [1,2] | [3] | 加入当前集 | [[], [1], [1,2]] |
| 6 | [1,2] | [3] | 选择 3 | [[], [1], [1,2]] |
| 7 | [1,2,3] | [] | 加入当前集 | [[], [1], [1,2], [1,2,3]] |
| 8 | [1,2] | [3] | 回溯，移除 3 | [[], [1], [1,2], [1,2,3]] |
| 9 | [1] | [2,3] | 回溯，移除 2 | [[], [1], [1,2], [1,2,3]] |
| 10 | [1] | [2,3] | 选择 3 | [[], [1], [1,2], [1,2,3]] |
| 11 | [1,3] | [] | 加入当前集 | [[], [1], [1,2], [1,2,3], [1,3]] |
| ... | ... | ... | ... | ... |

回溯过程说明：
1. 每次递归都会将当前子集加入结果集
2. 对于每个元素，我们可以选择它或不选择它
3. 选择后继续递归，处理剩余元素
4. 处理完当前分支后，回溯并尝试其他可能性

---

## 代码实现

完整的可运行代码：[L0078_Subsets.java](../src/main/java/L0078_Subsets.java)

```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    // 从空集开始回溯
    backtrack(result, new ArrayList<>(), nums, 0);
    return result;
}

private void backtrack(List<List<Integer>> result, List<Integer> current, int[] nums, int start) {
    // 每个状态都是一个有效的子集，将其加入结果集
    result.add(new ArrayList<>(current));
    
    // 从 start 开始尝试每个数字
    for (int i = start; i < nums.length; i++) {
        // 选择当前数字
        current.add(nums[i]);
        // 继续递归，注意下一轮从 i+1 开始，避免重复
        backtrack(result, current, nums, i + 1);
        // 回溯，移除最后选择的数字
        current.remove(current.size() - 1);
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(2ⁿ)
  - n 是数组的长度
  - 对于每个元素，我们都有选择或不选择两种可能
  - 总共需要生成 2ⁿ 个子集
  - 每个子集的复制需要 O(n) 的时间

- **空间复杂度**：O(n)
  - 递归调用栈的深度最大为 n
  - current 列表在任何时候最多存储 n 个元素
  - 不考虑存储最终结果所需的空间

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 