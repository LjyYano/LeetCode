---
title: 找到所有数组中消失的数字
date: 2025-02-11
---

## 题目描述

**🔗 题目**：[找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)  
**🏷️ 标签**：`数组` `哈希表`  
**🟢 难度**：`简单`  

给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。

示例 1：
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]

示例 2：
输入：nums = [1,1]
输出：[2]

提示：
- n == nums.length
- 1 <= n <= 10⁵
- 1 <= nums[i] <= n

进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。

---

## 解题思路
### 原地修改数组

#### 📝 核心思想
本题的关键是要在不使用额外空间的情况下找出缺失的数字。我们可以利用数组本身来标记数字的出现情况。由于数组中的数字范围在 1 到 n 之间，我们可以将每个数字对应位置（减 1 后的索引）的数加上 n，这样在最后遍历数组时，如果某个位置的数字小于等于 n，就说明没有数字映射到这个位置。

#### 🛠️ 实现步骤
1. 遍历数组，对于每个数字 nums[i]：
   - 计算其对应的索引 index = (nums[i] - 1) % n
   - 在 nums[index] 上加上 n
2. 再次遍历数组，对于每个位置 i：
   - 如果 nums[i] <= n，说明没有数字映射到这个位置
   - 将 i + 1 加入结果列表（因为数字范围是 1 到 n）

#### 🧩 示例分析
以示例 1：nums = [4,3,2,7,8,2,3,1] 为例，演示整个计算过程：

1. 初始状态：
```
索引：0  1  2  3  4  5  6  7
数字：4  3  2  7  8  2  3  1
```

2. 第一次遍历，标记数字出现的位置：
| 步骤 | 当前数字 | 对应索引 | 数组状态 | 说明 |
|-----|---------|---------|----------|-----|
| 1 | 4 | 3 | [4,3,2,15,8,2,3,1] | nums[3] += 8 |
| 2 | 3 | 2 | [4,3,10,15,8,2,3,1] | nums[2] += 8 |
| 3 | 2 | 1 | [4,11,10,15,8,2,3,1] | nums[1] += 8 |
| 4 | 7 | 6 | [4,11,10,15,8,2,11,1] | nums[6] += 8 |
| 5 | 8 | 7 | [4,11,10,15,8,2,11,9] | nums[7] += 8 |
| 6 | 2 | 1 | [4,19,10,15,8,2,11,9] | nums[1] += 8 |
| 7 | 3 | 2 | [4,19,18,15,8,2,11,9] | nums[2] += 8 |
| 8 | 1 | 0 | [12,19,18,15,8,2,11,9] | nums[0] += 8 |

3. 第二次遍历，找出未被标记的位置：
```
索引：0  1  2  3  4  5  6  7
数字：12 19 18 15 8  2  11 9
     ✓  ✓  ✓  ✓  ✗  ✗  ✓  ✓
```

可以看到，索引 4 和 5 对应的数字小于等于 8（数组长度），说明这两个位置没有被标记，因此缺失的数字是 5 和 6。

---

## 代码实现

完整的可运行代码：[L0448_FindAllNumbersDisappearedInAnArray.java](../src/main/java/L0448_FindAllNumbersDisappearedInAnArray.java)

```java
public java.util.List<Integer> findDisappearedNumbers(int[] nums) {
    int n = nums.length;
    
    // 将每个数对应位置的数加上 n
    for (int i = 0; i < n; i++) {
        // 获取当前数字对应的索引（减 1 是因为数字范围是 1 到 n）
        int index = (nums[i] - 1) % n;
        // 在对应位置的数字上加 n
        nums[index] += n;
    }
    
    // 收集结果
    java.util.List<Integer> result = new java.util.ArrayList<>();
    for (int i = 0; i < n; i++) {
        // 如果某个位置的数字小于等于 n，说明没有数字映射到这个位置
        if (nums[i] <= n) {
            // 将索引加 1 得到消失的数字
            result.add(i + 1);
        }
    }
    
    return result;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组的长度。我们只需要遍历数组两次。
- **空间复杂度**：O(1)，除了返回的结果数组外，我们只使用了常数级别的额外空间。

---

## LeetCode 题解
     
本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。
     
<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 