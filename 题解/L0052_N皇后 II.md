---
title: N 皇后 II
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[N 皇后 II](https://leetcode.cn/problems/n-queens-ii/)  
**🏷️ 标签**：`回溯` `数组`  
**🔴 难度**：`困难`  

n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。

示例 1：

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
输入：n = 4
输出：2
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

示例 2：
```
输入：n = 1
输出：1
```

提示：
- 1 <= n <= 9

---

## 解题思路
### 回溯算法

#### 📝 核心思想
1. 使用回溯算法，逐行放置皇后
2. 每行只能放置一个皇后，且皇后之间不能相互攻击
3. 使用一维数组记录每行皇后的列位置
4. 通过检查同列和对角线来判断是否可以放置皇后

#### 🛠️ 实现步骤
1. 使用一维数组 queens 记录每行皇后的列位置
2. 从第一行开始，尝试在每一列放置皇后
3. 对于每个位置，检查是否可以放置皇后：
   - 检查同列是否有其他皇后
   - 检查对角线是否有其他皇后
4. 如果可以放置，则：
   - 记录当前位置
   - 继续处理下一行
   - 回溯时不需要显式移除（会被覆盖）
5. 当成功放置 n 个皇后时，解的数量加 1

#### 🧩 示例分析
以 n = 4 为例，让我们详细分析回溯过程：

1. 棋盘表示：
```
0 1 2 3  列
□ □ □ □  第 0 行
□ □ □ □  第 1 行
□ □ □ □  第 2 行
□ □ □ □  第 3 行
```

2. 第一个解的查找过程：
```
步骤 1：在第 0 行尝试放置皇后
0 1 2 3
Q □ □ □  // 在 (0,0) 放置第一个皇后
□ □ □ □
□ □ □ □
□ □ □ □

步骤 2：在第 1 行尝试放置皇后
0 1 2 3
Q □ □ □  // 由于对角线和同列限制
□ □ Q □  // 只能在 (1,2) 放置第二个皇后
□ □ □ □
□ □ □ □

步骤 3：在第 2 行尝试放置皇后
0 1 2 3
Q □ □ □
□ □ Q □
□ Q □ □  // 在 (2,1) 放置第三个皇后
□ □ □ □

步骤 4：在第 3 行尝试放置皇后
0 1 2 3
Q □ □ □
□ □ Q □
□ Q □ □
□ □ □ Q  // 在 (3,3) 放置第四个皇后
```

3. 第二个解的查找过程：
```
回溯到第 0 行，尝试新的位置：
0 1 2 3
□ □ Q □  // 在 (0,2) 放置第一个皇后
□ □ □ □
□ □ □ □
□ □ □ □

继续放置：
0 1 2 3
□ □ Q □
Q □ □ □  // 在 (1,0) 放置第二个皇后
□ □ □ □
□ □ □ □

最终得到第二个解：
0 1 2 3
□ □ Q □
Q □ □ □
□ □ □ Q
□ Q □ □
```

4. 状态转移表：
| 行 | 可选列位置 | 选择的列 | 原因 |
|----|------------|----------|------|
| 0 | [0,1,2,3] | 0 | 第一个解的起始位置 |
| 1 | [2] | 2 | 避开对角线和同列 |
| 2 | [1] | 1 | 避开对角线和同列 |
| 3 | [3] | 3 | 唯一可选位置 |

5. 剪枝说明：
- 同列剪枝：queens[i] == col
- 对角线剪枝：|row - i| == |col - queens[i]|
- 每次放置皇后时，只需要检查之前放置的皇后

---

## 代码实现

完整的可运行代码：[L0052_NQueensII.java](../src/main/java/L0052_NQueensII.java)

```java
public int totalNQueens(int n) {
    // 使用一维数组表示每行皇后的列位置
    int[] queens = new int[n];
    // 从第一行开始放置皇后
    backtrack(queens, 0, n);
    return count;
}

private void backtrack(int[] queens, int row, int n) {
    // 如果已经放置了 n 个皇后，说明找到了一个解
    if (row == n) {
        count++;
        return;
    }
    
    // 尝试在当前行的每一列放置皇后
    for (int col = 0; col < n; col++) {
        // 检查当前位置是否可以放置皇后
        if (isValid(queens, row, col)) {
            // 在当前位置放置皇后
            queens[row] = col;
            // 继续放置下一行的皇后
            backtrack(queens, row + 1, n);
            // 回溯，移除当前位置的皇后（实际上不需要显式移除，因为会被覆盖）
        }
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(n!)
  - 需要尝试在 n × n 的棋盘上放置 n 个皇后
  - 第一行有 n 种选择
  - 第二行最多有 n-1 种选择
  - 依此类推
  - 实际复杂度会因为剪枝而小于 n!

- **空间复杂度**：O(n)
  - 需要一个长度为 n 的数组存储皇后位置
  - 递归调用栈的深度为 n

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 