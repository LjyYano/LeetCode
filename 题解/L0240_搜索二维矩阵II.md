---
title: 搜索二维矩阵 II
date: 2024-02-10
---

## 题目描述

**🔗 题目**：[搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)  
**🏷️ 标签**：`数组` `二分查找` `分治` `矩阵`  
**🟡 难度**：`中等`  

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：
- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

示例 1：
```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
```

示例 2：
```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

提示：
- m == matrix.length
- n == matrix[i].length
- 1 <= n, m <= 300
- -10⁹ <= matrix[i][j] <= 10⁹
- 每行的所有元素从左到右升序排列
- 每列的所有元素从上到下升序排列
- -10⁹ <= target <= 10⁹

---

## 解题思路
### 从右上角开始搜索

#### 📝 核心思想
本题的关键在于利用矩阵的两个特性：每行从左到右升序，每列从上到下升序。我们可以从右上角开始搜索，这样就可以根据当前元素与目标值的大小关系，排除一行或一列：

1. 如果当前元素等于目标值，直接返回 true
2. 如果当前元素大于目标值，说明这一列都大于目标值（因为下面的元素更大），可以排除这一列
3. 如果当前元素小于目标值，说明这一行的前面元素都小于目标值（因为前面的元素更小），可以排除这一行

这种方法每次比较都能排除一行或一列，直到找到目标值或搜索完整个矩阵。

#### 🛠️ 实现步骤
1. 处理边界情况：检查矩阵是否为空
2. 从右上角开始搜索：
   - 初始位置：row = 0, col = n - 1
3. 在矩阵范围内循环：
   - 如果当前元素等于目标值，返回 true
   - 如果当前元素大于目标值，向左移动（col--）
   - 如果当前元素小于目标值，向下移动（row++）
4. 如果没有找到目标值，返回 false

#### 🧩 示例分析
以示例 1 为例，matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5：

从右上角 15 开始搜索：
```
步骤 1：当前位置 (0,4)，值为 15
[1  4  7  11 [15]]  15 > 5
[2  5  8  12  19]   排除最后一列
[3  6  9  16  22]
[10 13 14 17 24]
[18 21 23 26 30]

步骤 2：当前位置 (0,3)，值为 11
[1  4  7  [11] *]   11 > 5
[2  5  8   12  *]   排除这一列
[3  6  9   16  *]
[10 13 14  17  *]
[18 21 23  26  *]

步骤 3：当前位置 (0,2)，值为 7
[1  4  [7]  *  *]   7 > 5
[2  5   8   *  *]   排除这一列
[3  6   9   *  *]
[10 13  14  *  *]
[18 21  23  *  *]

步骤 4：当前位置 (0,1)，值为 4
[1  [4]  *  *  *]   4 < 5
[2   5   *  *  *]   排除第一行
[3   6   *  *  *]
[10  13  *  *  *]
[18  21  *  *  *]

步骤 5：当前位置 (1,1)，值为 5
[1   *   *  *  *]   找到目标值 5
[2  [5]  *  *  *]   返回 true
[3   6   *  *  *]
[10  13  *  *  *]
[18  21  *  *  *]
```

搜索过程表格说明：

| 步骤 | 当前位置 | 当前值 | 目标值 | 比较结果 | 操作 |
|-----|---------|-------|--------|---------|------|
| 1 | (0,4) | 15 | 5 | 15 > 5 | 左移，排除最后一列 |
| 2 | (0,3) | 11 | 5 | 11 > 5 | 左移，排除当前列 |
| 3 | (0,2) | 7 | 5 | 7 > 5 | 左移，排除当前列 |
| 4 | (0,1) | 4 | 5 | 4 < 5 | 下移，排除第一行 |
| 5 | (1,1) | 5 | 5 | 5 = 5 | 找到目标值，返回 true |

---

## 代码实现

完整的可运行代码：[L0240_SearchA2DMatrixII.java](../src/main/java/L0240_SearchA2DMatrixII.java)

```java
public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }
    
    int m = matrix.length;
    int n = matrix[0].length;
    
    // 从右上角开始搜索
    int row = 0;
    int col = n - 1;
    
    while (row < m && col >= 0) {
        if (matrix[row][col] == target) {
            return true;
        } else if (matrix[row][col] > target) {
            // 当前元素大于目标值，排除这一列
            col--;
        } else {
            // 当前元素小于目标值，排除这一行
            row++;
        }
    }
    
    return false;
}
```

---

## 复杂度分析

- **时间复杂度**：O(m + n)
  - 从右上角开始，每次比较都会排除一行或一列
  - 最多需要 m + n 次比较就能遍历完整个矩阵
  - 其中 m 和 n 分别是矩阵的行数和列数

- **空间复杂度**：O(1)
  - 只使用了几个变量来存储位置信息
  - 不需要额外的数据结构

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 