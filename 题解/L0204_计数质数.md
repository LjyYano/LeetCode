# 计数质数

> 日期：2024-02-09

## 题目描述

给定整数 n ，返回所有小于非负整数 n 的质数的数量。

**示例 1：**
```
输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

**示例 2：**
```
输入：n = 0
输出：0
```

**示例 3：**
```
输入：n = 1
输出：0
```

**提示：**
- 0 <= n <= 5 * 10^6

## 解题思路

这道题目要求计算小于给定数字 n 的所有质数的数量。最直观的方法是对每个数字判断是否为质数，但这种方法的时间复杂度较高。这里我们使用一个更高效的算法 —— 埃拉托斯特尼筛法（Sieve of Eratosthenes）。

### 核心思路

埃拉托斯特尼筛法的基本思想是：
1. 初始化一个布尔数组，标记每个数是否为质数，初始都假设为质数
2. 从 2 开始遍历，如果当前数字是质数：
   - 将它的所有倍数都标记为非质数
   - 计数器加一
3. 最终计数器的值就是质数的数量

### 优化点
1. 只需要遍历到 n，而不是 sqrt(n)，因为我们需要统计所有小于 n 的质数
2. 标记倍数时可以从 i * i 开始，因为小于 i * i 的倍数已经被之前的数处理过了
3. 使用 boolean 数组来标记非质数，节省空间
4. 使用 long 类型避免 i * i 可能的整数溢出

### 步骤分解

1. 特殊情况处理：
   - 如果 n <= 2，直接返回 0，因为没有小于 2 的质数

2. 初始化：
   - 创建一个长度为 n 的 boolean 数组 notPrime
   - 创建计数器 count

3. 筛选过程：
   - 从 2 遍历到 n-1
   - 如果当前数字未被标记为非质数：
     - count++
     - 将它的所有倍数标记为非质数

4. 返回结果：
   - 返回 count 值

## 代码实现

```java
public int countPrimes(int n) {
    // 使用埃氏筛法
    if (n <= 2) {
        return 0;
    }
    
    // 初始化标记数组，默认都是质数
    boolean[] notPrime = new boolean[n];
    int count = 0;
    
    // 从 2 开始遍历到 sqrt(n)
    for (int i = 2; i < n; i++) {
        if (!notPrime[i]) {
            count++;
            // 将当前质数的倍数都标记为非质数
            if ((long) i * i < n) {
                for (int j = i * i; j < n; j += i) {
                    notPrime[j] = true;
                }
            }
        }
    }
    
    return count;
}
```

## 复杂度分析

- 时间复杂度：O(n log log n)
  - 外层循环需要 O(n) 的时间
  - 内层循环需要 O(log log n) 的时间（这是因为每个数被其质因数筛选的次数与调和级数相关）

- 空间复杂度：O(n)
  - 需要一个长度为 n 的布尔数组来标记数字是否为质数

## 总结

埃拉托斯特尼筛法是一个非常经典的算法，它不仅可以用来统计质数的数量，还可以用来生成质数表。这个算法的优势在于它避免了对每个数进行判断是否为质数的繁琐过程，而是通过标记非质数的方式来反向得到质数。

这个解法是处理质数相关问题的基础，在很多其他问题中也会用到类似的思想。比如求解因数分解、欧拉函数等问题时，都可能会用到筛法的思想。

---

本题解由 [力扣刷题插件](https://leetcode.cn/leetbook/detail/leetcode-helper/) 自动生成，欢迎分享交流。 