---
title: 等差数列划分
date: 2024-02-11
---

## 题目描述

**🔗 题目**：[等差数列划分](https://leetcode.cn/problems/arithmetic-slices/description/)  
**🏷️ 标签**：`数组` `动态规划`  
**🟡 难度**：`中等`  

如果一个数字序列至少有三个元素，并且任意两个相邻元素之差相同，则称该序列为等差序列。
例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差序列。
给你一个整数数组 nums ，返回数组 nums 中所有为等差序列的子数组个数。
子数组是数组中的一个连续序列。

示例 1：
输入：nums = [1,2,3,4]
输出：3
解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4]

示例 2：
输入：nums = [1]
输出：0

---

## 解题思路

### 动态规划法

#### 📝 核心思想
使用动态规划来解决这个问题。关键是理解：如果一个新的数字可以和前面的数字构成等差数列，那么它不仅可以构成一个新的长度为 3 的等差数列，还可以和之前的等差数列组合形成更长的等差数列。

例如，对于序列 [1,2,3,4]：
1. 当考虑到 3 时，可以形成 [1,2,3]
2. 当考虑到 4 时，不仅可以形成 [2,3,4]，还可以形成 [1,2,3,4]

#### 🛠️ 实现步骤
1. 创建动态规划数组 dp，其中 dp[i] 表示以 nums[i] 结尾的等差数列的个数
2. 从第三个元素开始遍历数组：
   - 如果当前三个数构成等差数列（nums[i] - nums[i-1] == nums[i-1] - nums[i-2]）
   - 则 dp[i] = dp[i-1] + 1
3. 最终结果是所有 dp[i] 的和

#### 🧩 示例分析
以 nums = [1,2,3,4,5] 为例，分析动态规划的过程：

| 索引 i | 数字序列 | 是否构成等差 | dp[i] | 新增等差序列 | 累计和 | 说明 |
|-------|---------|------------|-------|-------------|--------|------|
| 0,1 | [1,2] | - | 0 | - | 0 | 少于 3 个数 |
| 2 | [1,2,3] | 是 | 1 | [1,2,3] | 1 | 第一个等差序列 |
| 3 | [2,3,4] | 是 | 2 | [2,3,4], [1,2,3,4] | 3 | 新增两个序列 |
| 4 | [3,4,5] | 是 | 3 | [3,4,5], [2,3,4,5], [1,2,3,4,5] | 6 | 新增三个序列 |

详细分析：
1. 当 i = 2 时：
   - 检查 [1,2,3]，构成等差数列
   - dp[2] = 1，表示有一个等差序列
   
2. 当 i = 3 时：
   - 检查 [2,3,4]，构成等差数列
   - dp[3] = dp[2] + 1 = 2，表示新增两个等差序列
   
3. 当 i = 4 时：
   - 检查 [3,4,5]，构成等差数列
   - dp[4] = dp[3] + 1 = 3，表示新增三个等差序列

最终结果为 6，包含所有可能的等差子数列：
- 长度为 3：[1,2,3], [2,3,4], [3,4,5]
- 长度为 4：[1,2,3,4], [2,3,4,5]
- 长度为 5：[1,2,3,4,5]

---

## 代码实现

完整的可运行代码：[L0413_ArithmeticSlices.java](../src/main/java/L0413_ArithmeticSlices.java)

```java
public int numberOfArithmeticSlices(int[] nums) {
    if (nums == null || nums.length < 3) {
        return 0;
    }
    
    int n = nums.length;
    // dp[i] 表示以 nums[i] 结尾的等差数列的个数
    int[] dp = new int[n];
    int sum = 0;
    
    // 从第三个元素开始遍历
    for (int i = 2; i < n; i++) {
        // 如果当前三个数构成等差数列
        if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) {
            // 新的等差数列个数等于前一个位置的个数加 1
            dp[i] = dp[i-1] + 1;
            // 累加到结果中
            sum += dp[i];
        }
    }
    
    return sum;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组的长度。我们只需要遍历一次数组。
- **空间复杂度**：O(n)，需要一个长度为 n 的数组来存储动态规划的状态。实际上可以优化到 O(1)，因为我们只需要前一个状态。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 