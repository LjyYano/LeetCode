---
title: 有效的字母异位词
date: 2024-02-10
---

## 题目描述

**🔗 题目**：[有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)  
**🏷️ 标签**：`哈希表` `字符串` `排序`  
**🟢 难度**：`简单`  

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

示例 1:
```
输入: s = "anagram", t = "nagaram"
输出: true
```

示例 2:
```
输入: s = "rat", t = "car"
输出: false
```

提示:
- 1 <= s.length, t.length <= 5 * 10⁴
- s 和 t 仅包含小写字母

---

## 解题思路
### 字符计数法

#### 📝 核心思想
字母异位词的特点是：两个字符串包含相同的字符，且每个字符出现的次数相同。因此，我们可以：
1. 统计第一个字符串中每个字符出现的次数
2. 遍历第二个字符串，减去对应字符的计数
3. 如果最终所有字符的计数都为 0，说明是字母异位词

由于题目说明只包含小写字母，我们可以使用一个长度为 26 的数组来记录字符出现的次数，这比使用哈希表更高效。

#### 🛠️ 实现步骤
1. 首先判断两个字符串的长度是否相等，不相等则直接返回 false
2. 创建一个长度为 26 的整型数组，用于记录字符出现次数
3. 遍历第一个字符串，将每个字符出现的次数加 1
4. 遍历第二个字符串，将每个字符出现的次数减 1
   - 如果某个字符的计数小于 0，说明该字符在 t 中出现的次数多于 s，返回 false
5. 遍历结束后返回 true

#### 🧩 示例分析
以示例 1 为例，s = "anagram", t = "nagaram"：

1. 统计 s 中字符出现次数：
```
字符 'a'：3 次
字符 'n'：1 次
字符 'g'：1 次
字符 'r'：1 次
字符 'm'：1 次
```

2. 处理 t 中的字符：
```
'n'：计数 1 -> 0
'a'：计数 3 -> 2
'g'：计数 1 -> 0
'a'：计数 2 -> 1
'r'：计数 1 -> 0
'a'：计数 1 -> 0
'm'：计数 1 -> 0
```

3. 最终所有计数都为 0，返回 true

以示例 2 为例，s = "rat", t = "car"：

| 步骤 | 操作 | a 计数 | c 计数 | r 计数 | t 计数 |
|-----|------|--------|--------|--------|--------|
| 1 | 处理 "rat" | 1 | 0 | 1 | 1 |
| 2 | 处理 'c' | 1 | -1 | 1 | 1 |
| 3 | 处理 'a' | 0 | -1 | 1 | 1 |
| 4 | 处理 'r' | 0 | -1 | 0 | 1 |

发现 'c' 的计数为负数，说明不是字母异位词，返回 false。

### 其他解法

1. **排序法**：
   - 将两个字符串转换为字符数组并排序
   - 比较排序后的数组是否相同
   - 时间复杂度 O(n log n)，空间复杂度 O(n)

2. **哈希表法**：
   - 使用哈希表记录字符出现次数
   - 适用于字符集较大的情况
   - 时间复杂度 O(n)，空间复杂度 O(k)，k 为字符集大小

---

## 代码实现

完整的可运行代码：[L0242_ValidAnagram.java](../src/main/java/L0242_ValidAnagram.java)

```java
public boolean isAnagram(String s, String t) {
    // 如果长度不相等，一定不是字母异位词
    if (s.length() != t.length()) {
        return false;
    }
    
    // 创建一个长度为 26 的数组，记录每个字符出现的次数
    int[] charCount = new int[26];
    
    // 遍历第一个字符串，记录每个字符出现的次数
    for (char c : s.toCharArray()) {
        charCount[c - 'a']++;
    }
    
    // 遍历第二个字符串，减去每个字符出现的次数
    for (char c : t.toCharArray()) {
        charCount[c - 'a']--;
        // 如果某个字符出现的次数小于 0，说明不是字母异位词
        if (charCount[c - 'a'] < 0) {
            return false;
        }
    }
    
    return true;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)
  - 需要遍历两个字符串各一次
  - n 是字符串的长度
  - 数组操作的时间复杂度是 O(1)

- **空间复杂度**：O(1)
  - 使用了一个固定大小的数组（长度为 26）
  - 空间消耗不随输入规模变化
  - 因此空间复杂度是常数级的

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 