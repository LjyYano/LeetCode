---
title: 滑动窗口中位数
date: 2024-02-12
---

## 题目描述

**🔗 题目**：[480. 滑动窗口中位数](https://leetcode.cn/problems/sliding-window-median/)  
**🏷️ 标签**：`数组` `哈希表` `滑动窗口` `堆（优先队列）`  
**🔴 难度**：`困难`  

中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：
- `[2,3,4]`，中位数是 `3`
- `[2,3]`，中位数是 `(2 + 3) / 2 = 2.5`

给你一个数组 `nums`，有一个长度为 `k` 的窗口从最左端滑动到最右端。窗口中有 `k` 个数，每次窗口向右移动 `1` 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

**示例 1：**
```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]
解释：
窗口位置                      中位数
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7      -1
 1  3 [-1  -3  5] 3  6  7      -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
```

**示例 2：**
```
输入：nums = [1,2,3,4,2,3,1,4,2], k = 3
输出：[2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]
```

**提示：**
- `1 <= k <= nums.length <= 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`

---

## 解题思路

### 双堆法

#### 📝 核心思想
使用两个堆来维护滑动窗口中的元素：
- 小根堆（大顶堆）：存储较小的一半元素
- 大根堆（小顶堆）：存储较大的一半元素

保持两个堆的大小平衡，中位数就可以从堆顶快速获取。

但是滑动窗口需要删除元素，而堆不支持高效的删除操作。我们可以使用"延迟删除"的技巧：
- 用哈希表记录需要删除的元素
- 在访问堆顶时，如果堆顶元素在删除集合中，就将其弹出

#### 🛠️ 实现步骤
1. 初始化两个优先队列和一个哈希表
2. 先处理前 k 个元素，建立初始窗口
3. 滑动窗口：
   - 添加新元素到合适的堆中
   - 标记要删除的元素
   - 调整两个堆的大小，保持平衡
   - 计算中位数

#### 🧩 示例分析
以示例 1 的前几个窗口为例：

窗口 [1, 3, -1]：
- 排序后：[-1, 1, 3]
- 中位数：1

窗口 [3, -1, -3]：
- 排序后：[-3, -1, 3]
- 中位数：-1

### 平衡技巧
- 保持小根堆的大小 >= 大根堆的大小
- 如果 k 是奇数，小根堆比大根堆多一个元素
- 如果 k 是偶数，两个堆大小相等

---

## 代码实现

```java
import java.util.*;

public class L0480_SlidingWindowMedian {
    // 小根堆：存储较大的一半
    private PriorityQueue<Integer> small = new PriorityQueue<>();
    // 大根堆：存储较小的一半
    private PriorityQueue<Integer> large = new PriorityQueue<>(Collections.reverseOrder());
    // 延迟删除的元素
    private Map<Integer, Integer> delayed = new HashMap<>();
    private int smallSize = 0;
    private int largeSize = 0;
    
    public double[] medianSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        double[] result = new double[n - k + 1];
        
        // 初始化前 k 个元素
        for (int i = 0; i < k; i++) {
            addNum(nums[i]);
        }
        result[0] = getMedian(k);
        
        // 滑动窗口
        for (int i = k; i < n; i++) {
            // 添加新元素
            addNum(nums[i]);
            // 删除旧元素
            removeNum(nums[i - k]);
            // 计算中位数
            result[i - k + 1] = getMedian(k);
        }
        
        return result;
    }
    
    private void addNum(int num) {
        if (large.isEmpty() || num <= large.peek()) {
            large.offer(num);
            largeSize++;
        } else {
            small.offer(num);
            smallSize++;
        }
        rebalance();
    }
    
    private void removeNum(int num) {
        delayed.put(num, delayed.getOrDefault(num, 0) + 1);
        if (num <= large.peek()) {
            largeSize--;
        } else {
            smallSize--;
        }
        rebalance();
    }
    
    private void rebalance() {
        // 调整堆的平衡
        if (largeSize > smallSize + 1) {
            small.offer(large.poll());
            smallSize++;
            largeSize--;
            prune(large);
        } else if (smallSize > largeSize) {
            large.offer(small.poll());
            largeSize++;
            smallSize--;
            prune(small);
        }
        prune(large);
        prune(small);
    }
    
    private void prune(PriorityQueue<Integer> heap) {
        while (!heap.isEmpty() && delayed.getOrDefault(heap.peek(), 0) > 0) {
            int num = heap.poll();
            delayed.put(num, delayed.get(num) - 1);
            if (delayed.get(num) == 0) {
                delayed.remove(num);
            }
        }
    }
    
    private double getMedian(int k) {
        if (k % 2 == 1) {
            return large.peek();
        } else {
            return ((long) large.peek() + (long) small.peek()) / 2.0;
        }
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(nlogk)，其中 n 是数组长度。每次插入和删除操作需要 O(logk) 时间。
- **空间复杂度**：O(k)，需要存储窗口中的元素。

---

## 相关题目

- [🔗 295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)
- [🔗 239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

---

## 总结

这道题结合了滑动窗口和求中位数两个经典问题。解题的关键在于：
1. 使用双堆来维护中位数
2. 使用延迟删除技巧来处理滑动窗口的删除操作
3. 保持两个堆的平衡

通过这道题，我们可以学习到：
1. 双堆求中位数的经典技巧
2. 延迟删除在优先队列中的应用
3. 滑动窗口与数据结构的结合

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 