---
title: 比较版本号
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[比较版本号](https://leetcode.cn/problems/compare-version-numbers/)  
**🏷️ 标签**：`字符串` `双指针`  
**🟡 难度**：`中等`  

给你两个版本号 version1 和 version2 ，请你比较它们。

版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。

比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。

返回规则如下：
- 如果 version1 > version2 返回 1，
- 如果 version1 < version2 返回 -1，
- 除此之外返回 0。

示例 1：
```
输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，"01" 和 "001" 都表示相同的整数 "1"
```

示例 2：
```
输入：version1 = "1.0", version2 = "1.0.0"
输出：0
解释：version1 没有指定下标为 2 的修订号，即视为 "0"
```

示例 3：
```
输入：version1 = "0.1", version2 = "1.1"
输出：-1
解释：version1 中下标为 0 的修订号是 "0"，version2 中下标为 0 的修订号是 "1" 。0 < 1，所以 version1 < version2
```

提示：
- 1 <= version1.length, version2.length <= 500
- version1 和 version2 仅包含数字和 '.'
- version1 和 version2 都是 有效版本号
- version1 和 version2 的所有修订号都可以存储在 32 位整数 中

---

## 解题思路
### 分割字符串比较法

#### 📝 核心思想
本题的核心在于正确处理版本号的比较规则：
1. 版本号按照 '.' 分割成多个修订号
2. 每个修订号需要去除前导零后再比较
3. 缺失的修订号视为 0
4. 从左到右依次比较每个修订号的大小

#### 🛠️ 实现步骤
1. 使用 split 方法将两个版本号按照 '.' 分割成字符串数组
2. 获取两个数组的最大长度，确保能够处理所有修订号
3. 遍历比较每个位置的修订号：
   - 将字符串转换为整数（自动去除前导零）
   - 如果超出数组长度，则该位置的修订号视为 0
   - 比较两个修订号的大小
4. 如果发现不相等的修订号，立即返回比较结果
5. 如果所有修订号都相等，返回 0

#### 🧩 示例分析
让我们以示例 "1.01" 和 "1.001" 为例，详细分析比较过程：

| 步骤 | 操作 | version1 | version2 | 说明 |
|-----|------|----------|----------|-----|
| 1 | 分割字符串 | ["1", "01"] | ["1", "001"] | 按 '.' 分割成数组 |
| 2 | 比较第一位 | 1 | 1 | 第一位相等，继续比较 |
| 3 | 比较第二位 | 1 | 1 | "01" 和 "001" 转为整数后都是 1 |
| 4 | 结果 | - | - | 所有位都相等，返回 0 |

再看一个更复杂的例子 "1.0" 和 "1.0.0"：

| 步骤 | 操作 | version1 | version2 | 说明 |
|-----|------|----------|----------|-----|
| 1 | 分割字符串 | ["1", "0"] | ["1", "0", "0"] | 按 '.' 分割成数组 |
| 2 | 比较第一位 | 1 | 1 | 第一位相等，继续比较 |
| 3 | 比较第二位 | 0 | 0 | 第二位相等，继续比较 |
| 4 | 比较第三位 | 0 (缺失位) | 0 | version1 缺失的位视为 0 |
| 5 | 结果 | - | - | 所有位都相等，返回 0 |

---

## 代码实现

完整的可运行代码：[L0165_CompareVersionNumbers.java](../src/main/java/L0165_CompareVersionNumbers.java)

```java
public int compareVersion(String version1, String version2) {
    // 将版本号按点号分割成数组
    String[] v1 = version1.split("\\.");
    String[] v2 = version2.split("\\.");
    
    // 获取两个版本号的最大长度
    int maxLength = Math.max(v1.length, v2.length);
    
    // 逐个比较每个修订号
    for (int i = 0; i < maxLength; i++) {
        // 获取当前位置的修订号，如果超出长度则视为 0
        int num1 = i < v1.length ? Integer.parseInt(v1[i]) : 0;
        int num2 = i < v2.length ? Integer.parseInt(v2[i]) : 0;
        
        // 比较当前修订号
        if (num1 < num2) {
            return -1;
        } else if (num1 > num2) {
            return 1;
        }
    }
    
    // 所有修订号都相等
    return 0;
}
```

---

## 复杂度分析

- **时间复杂度**：O(max(n, m))，其中 n 和 m 分别是两个版本号的长度
  - split 操作需要遍历整个字符串，时间复杂度为 O(n) 和 O(m)
  - 比较操作需要遍历所有的修订号，时间复杂度为 O(max(n, m))

- **空间复杂度**：O(n + m)
  - 需要存储两个版本号分割后的字符串数组
  - 数组的大小分别与输入字符串的长度成正比

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 