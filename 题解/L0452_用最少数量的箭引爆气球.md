---
title: 用最少数量的箭引爆气球
date: 2025-02-11
---

## 题目描述

**🔗 题目**：[用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)  
**🏷️ 标签**：`贪心` `数组` `排序`  
**🟡 难度**：`中等`  

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中 points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend 之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 points ，返回引爆所有气球所需的 最小 弓箭数。
```
示例 1：
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]
-在x = 11处射出箭，击破气球[10,16]和[7,12]

示例 2：
输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
解释：每个气球需要射出一支箭，总共需要4支箭

示例 3：
输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
解释：气球可以用2支箭来爆破:
- 在x = 2处发射箭，击破气球[1,2]和[2,3]
- 在x = 4处发射箭，击破气球[3,4]和[4,5]
```
提示:
- 1 <= points.length <= 10⁵
- points[i].length == 2
- -2³¹ <= xstart < xend <= 2³¹ - 1

---

## 解题思路
### 贪心算法

#### 📝 核心思想
这道题可以使用贪心算法来解决。关键思路是：
1. 按照气球的结束位置进行排序
2. 尽可能在一个气球的结束位置射箭，这样可以尽可能多地引爆其他气球
3. 当一支箭无法引爆下一个气球时，才需要增加新的箭

为什么按照结束位置排序是正确的？
- 如果我们在一个气球的结束位置射箭，这支箭一定可以引爆这个气球
- 同时，这支箭也可能引爆其他与这个气球有重叠的气球
- 通过选择结束位置最早的气球，我们可以保证不会错过任何可能的重叠机会

#### 🛠️ 实现步骤
1. 首先对气球数组按照结束位置进行排序
2. 初始化第一支箭的位置（第一个气球的结束位置）
3. 遍历排序后的气球：
   - 如果当前气球的开始位置大于当前箭的位置，需要一支新箭
   - 更新当前箭的位置为新气球的结束位置

#### 🧩 示例分析
以示例 1：points = [[10,16],[2,8],[1,6],[7,12]] 为例：

1. 首先按结束位置排序：
```
原始数组：[10,16], [2,8], [1,6], [7,12]
排序后：  [1,6], [2,8], [7,12], [10,16]
```

2. 处理过程：
| 步骤 | 当前气球 | 当前箭位置 | 是否需要新箭 | 箭数 | 说明 |
|-----|---------|-----------|------------|------|-----|
| 1 | [1,6] | 6 | 是 | 1 | 第一支箭 |
| 2 | [2,8] | 6 | 否 | 1 | 可以用第一支箭 |
| 3 | [7,12] | 12 | 是 | 2 | 需要新箭 |
| 4 | [10,16] | 12 | 否 | 2 | 可以用第二支箭 |

图示：
```
1: [1,6]     ←第一支箭(x=6)
2: [2,8]     ←第一支箭(x=6)
3:     [7,12]     ←第二支箭(x=12)
4:      [10,16]   ←第二支箭(x=12)
```

对于示例 2：[[1,2],[3,4],[5,6],[7,8]]
- 所有气球都没有重叠
- 每个气球都需要一支独立的箭
- 总共需要 4 支箭

对于示例 3：[[1,2],[2,3],[3,4],[4,5]]
- 相邻气球有重叠
- 可以用 2 支箭：一支在 x=2 处，一支在 x=4 处
- 每支箭可以引爆两个气球

---

## 代码实现

完整的可运行代码：[L0452_MinimumNumberOfArrowsToBurstBalloons.java](../src/main/java/L0452_MinimumNumberOfArrowsToBurstBalloons.java)

```java
public int findMinArrowShots(int[][] points) {
    if (points == null || points.length == 0) {
        return 0;
    }
    
    // 按照气球的结束位置排序
    java.util.Arrays.sort(points, (a, b) -> {
        // 注意这里不能直接用减法，因为可能会溢出
        return a[1] < b[1] ? -1 : (a[1] > b[1] ? 1 : 0);
    });
    
    // 至少需要一支箭
    int arrows = 1;
    // 当前箭能够到达的最远位置（第一个气球的结束位置）
    int currentEnd = points[0][1];
    
    // 遍历所有气球
    for (int i = 1; i < points.length; i++) {
        // 如果当前气球的开始位置大于当前箭能到达的位置
        // 说明需要一支新的箭
        if (points[i][0] > currentEnd) {
            arrows++;
            currentEnd = points[i][1];
        }
    }
    
    return arrows;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n log n)，其中 n 是气球的数量。
  - 排序需要 O(n log n) 时间
  - 遍历数组需要 O(n) 时间
  - 总体时间复杂度由排序决定，为 O(n log n)

- **空间复杂度**：O(log n)
  - 主要是排序所需的栈空间
  - 除此之外只使用了常数额外空间

---

## LeetCode 题解
     
本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。
     
<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 