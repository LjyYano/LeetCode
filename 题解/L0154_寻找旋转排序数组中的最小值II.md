---
title: 寻找旋转排序数组中的最小值 II
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)  
**🏷️ 标签**：`数组` `二分查找`  
**🟡 难度**：`困难`  

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
- 若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
- 若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须尽可能减少整个过程的操作步骤。

**示例 1：**
```
输入：nums = [1,3,5]
输出：1
```

**示例 2：**
```
输入：nums = [2,2,2,0,1]
输出：0
```

**示例 3：**
```
输入：nums = [3,3,1,3]
输出：1
```

**提示：**
- n == nums.length
- 1 <= n <= 5000
- -5000 <= nums[i] <= 5000
- nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转

---

## 解题思路

### 二分查找

#### 📝 核心思想
这道题是 [寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/) 的进阶版本，区别在于数组中可能包含重复元素。这个变化会导致我们无法直接判断最小值在哪个区间，需要额外的处理。

主要思路仍然是使用二分查找，但是需要处理中间值等于右边界值的情况：

1. 如果中间值大于右边界的值，说明最小值在右半部分
2. 如果中间值小于右边界的值，说明最小值在左半部分（包括中间值）
3. 如果中间值等于右边界的值，无法判断最小值在哪个区间，此时将右边界左移一位

#### 🛠️ 实现步骤
1. 特殊情况处理：
   - 如果数组为空，返回 -1
   - 如果数组首元素小于末元素，说明数组是有序的，返回首元素

2. 二分查找：
   - 初始化左右指针 left 和 right
   - 当 left < right 时：
     * 计算中间位置 mid
     * 如果 nums[mid] > nums[right]，说明最小值在右半部分
     * 如果 nums[mid] < nums[right]，说明最小值在左半部分（包括 mid）
     * 如果 nums[mid] == nums[right]，将右边界左移一位

3. 返回 nums[left]，此时 left 指向最小值

#### 🧩 示例分析
以示例 2 为例：nums = [2,2,2,0,1]

| 步骤 | left | right | mid | nums[mid] | nums[right] | 操作 | 说明 |
|-----|------|-------|-----|-----------|-------------|------|------|
| 1 | 0 | 4 | 2 | 2 | 1 | left = mid + 1 | 2 > 1，最小值在右半部分 |
| 2 | 3 | 4 | 3 | 0 | 1 | right = mid | 0 < 1, 最小值在左半部分 |
| 3 | 3 | 3 | - | - | - | 结束循环 | nums[3] = 0 是最小值 |

图解过程：
```
初始数组：[2, 2, 2, 0, 1]
第一步：  [2, 2, 2, 0, 1]
              ↑
             mid=2 > 1，搜索右半部分
第二步：  [2, 2, 2, 0, 1]
                 ↑
                mid=0 < 1，搜索左半部分
第三步：  [2, 2, 2, 0, 1]
                 ↑
                mid=0 是最小值
```

再看一个包含重复元素的例子：nums = [3,3,1,3]

| 步骤 | left | right | mid | nums[mid] | nums[right] | 操作 | 说明 |
|-----|------|-------|-----|-----------|-------------|------|------|
| 1 | 0 | 3 | 1 | 3 | 3 | right-- | 3 = 3，无法判断，右边界左移 |
| 2 | 0 | 2 | 1 | 3 | 1 | left = mid + 1 | 3 > 1，最小值在右半部分 |
| 3 | 2 | 2 | - | - | - | 结束循环 | nums[2] = 1 是最小值 |

---

## 代码实现

完整的可运行代码：[L0154_FindMinimumInRotatedSortedArrayII.java](../src/main/java/L0154_FindMinimumInRotatedSortedArrayII.java)

```java
public int findMin(int[] nums) {
    if (nums == null || nums.length == 0) {
        return -1;
    }
    
    int left = 0;
    int right = nums.length - 1;
    
    // 如果数组没有旋转或旋转了 n 次（相当于没旋转）
    if (nums[left] < nums[right]) {
        return nums[left];
    }
    
    // 使用二分查找
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        // 如果中间值大于右边值，说明最小值在右半部分
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        }
        // 如果中间值小于右边值，说明最小值在左半部分（包括 mid）
        else if (nums[mid] < nums[right]) {
            right = mid;
        }
        // 如果中间值等于右边值，无法判断最小值在哪个区间
        // 此时可以将右边界左移一位，因为即使 nums[right] 是最小值
        // nums[mid] 也同样是最小值
        else {
            right--;
        }
    }
    
    return nums[left];
}
```

---

## 复杂度分析

- **时间复杂度**：O(log n)，其中 n 是数组的长度
  - 在最好情况下（没有重复元素），每次都能将搜索范围缩小一半
  - 在最坏情况下（所有元素都相同），可能需要遍历整个数组，时间复杂度为 O(n)
  - 平均情况下，时间复杂度仍然是 O(log n)

- **空间复杂度**：O(1)
  - 只使用了几个变量来存储指针和临时值
  - 不需要额外的数组空间

---

## 优化思路

1. **预处理重复元素**
   - 可以在开始时先处理一些特殊情况
   - 例如，如果数组中所有元素都相同，直接返回第一个元素
   - 这样可以避免一些不必要的二分查找过程

2. **优化边界条件**
   - 可以在开始时判断更多的特殊情况
   - 例如数组长度为 1 或 2 的情况
   - 可以减少一些不必要的计算

3. **使用左边界比较**
   - 当前算法使用右边界进行比较
   - 也可以使用左边界进行比较
   - 两种方法都是可行的，可以根据具体情况选择

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 