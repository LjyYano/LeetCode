---
title: 整数反转
date: 2024-02-06
---

## 题目描述

**🔗 题目**：[整数反转](https://leetcode.cn/problems/reverse-integer/)  
**🏷️ 标签**：`数学`  
**🟡 难度**：`中等`  

给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 `[−2^31, 2^31 − 1]` ，就返回 `0`。

**假设环境不允许存储 64 位整数（有符号或无符号）。**

**示例 1：**
```
输入：x = 123
输出：321
```

**示例 2：**
```
输入：x = -123
输出：-321
```

**示例 3：**
```
输入：x = 120
输出：21
```

**示例 4：**
```
输入：x = 0
输出：0
```

**提示：**
- `-2^31 <= x <= 2^31 - 1`

---

## 解题思路

### 数学方法

#### 📝 核心思想
通过不断取出数字的最后一位并构建反转后的数字，同时需要处理溢出的情况。由于不能使用 64 位整数，我们需要在计算过程中判断是否会溢出。

#### 🛠️ 实现步骤
1. 初始化结果变量 result = 0
2. 当输入数字 x 不为 0 时：
   - 通过 x % 10 获取最后一位数字 digit
   - 判断 result * 10 + digit 是否会导致溢出
   - 如果不会溢出，则更新 result = result * 10 + digit
   - 更新 x = x / 10 去掉最后一位
3. 返回最终结果

#### 🧩 示例分析
以 `x = 123` 为例：

| 步骤 | 当前数字 | 当前位 | 反转结果 | 溢出检查 | 说明 |
|------|----------|--------|-----------|-----------|------|
| 初始状态 | 123 | - | 0 | - | 开始反转过程 |
| Step 1 | [123] | 3 | 3 | 0 * 10 + 3 < MAX_VALUE | 取出个位 3 |
| Step 2 | [12] | 2 | 32 | 3 * 10 + 2 < MAX_VALUE | 取出十位 2 |
| Step 3 | [1] | 1 | 321 | 32 * 10 + 1 < MAX_VALUE | 取出百位 1 |

**反转过程示意图**：
```
原始数字：1  2  3
Step 1：  [3]
Step 2：  [3  2]
Step 3：  [3  2  1]
```

**溢出检查**：
对于 32 位整数：
```
MAX_VALUE = 2147483647
MIN_VALUE = -2147483648

检查正数溢出：
result > MAX_VALUE/10 或 (result == MAX_VALUE/10 且 digit > 7)

检查负数溢出：
result < MIN_VALUE/10 或 (result == MIN_VALUE/10 且 digit < -8)
```

**特殊情况示例**：
1. 负数：
以 `x = -123` 为例：

| 步骤 | 当前数字 | 当前位 | 反转结果 | 溢出检查 | 说明 |
|------|----------|--------|-----------|-----------|------|
| 初始状态 | -123 | - | 0 | - | 开始反转过程 |
| Step 1 | [-123] | -3 | -3 | 0 * 10 - 3 > MIN_VALUE | 取出个位 -3 |
| Step 2 | [-12] | -2 | -32 | -3 * 10 - 2 > MIN_VALUE | 取出十位 -2 |
| Step 3 | [-1] | -1 | -321 | -32 * 10 - 1 > MIN_VALUE | 取出百位 -1 |

2. 溢出情况：
以 `x = 1463847412` 为例：

| 步骤 | 当前数字 | 当前位 | 反转结果 | 溢出检查 | 说明 |
|------|----------|--------|-----------|-----------|------|
| Step 1 | [1463847412] | 2 | 2 | 通过 | 取出个位 2 |
| Step 2 | [146384741] | 1 | 21 | 通过 | 取出十位 1 |
| Step 3 | [14638474] | 4 | 214 | 通过 | 取出百位 4 |
| Step 4 | [1463847] | 7 | 2147 | 通过 | 继续反转 |
| Step 5 | [146384] | 4 | 21474 | 通过 | 继续反转 |
| Step 6 | [14638] | 8 | 214748 | 通过 | 继续反转 |
| Step 7 | [1463] | 3 | 2147483 | 通过 | 继续反转 |
| Step 8 | [146] | 6 | 21474836 | 通过 | 继续反转 |
| Step 9 | [14] | 4 | 214748364 | 通过 | 继续反转 |
| Step 10 | [1] | 1 | 溢出 | 2147483641 > MAX_VALUE | 发生溢出，返回 0 |

---

## 代码实现

完整的可运行代码：[L0007_ReverseInteger.java](../src/main/java/L0007_ReverseInteger.java)

```java
public int reverse(int x) {
    // 结果
    int result = 0;
    
    // 当 x 不为 0 时继续处理
    while (x != 0) {
        // 取出最后一位数字
        int digit = x % 10;
        
        // 判断是否会溢出
        // 对于正数，result > Integer.MAX_VALUE/10 或者 result == Integer.MAX_VALUE/10 且 digit > 7 时会溢出
        // 对于负数，result < Integer.MIN_VALUE/10 或者 result == Integer.MIN_VALUE/10 且 digit < -8 时会溢出
        if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 && digit > 7)) {
            return 0;
        }
        if (result < Integer.MIN_VALUE / 10 || (result == Integer.MIN_VALUE / 10 && digit < -8)) {
            return 0;
        }
        
        // 将当前数字加入结果
        result = result * 10 + digit;
        
        // 去掉已处理的最后一位
        x /= 10;
    }
    
    return result;
}
```

---

## 复杂度分析

- **时间复杂度**：`O(log|x|)`，其中 |x| 是输入整数的绝对值。我们需要遍历 x 的每一位数字，而 x 的位数就是 log|x|。
- **空间复杂度**：`O(1)`，我们只需要常数级别的额外空间来存储变量。

---

## LeetCode 题解

[LeetCode 最全题解](https://github.com/LjyYano/LeetCode) 