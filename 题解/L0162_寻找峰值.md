---
title: 寻找峰值
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[寻找峰值](https://leetcode.cn/problems/find-peak-element/)  
**🏷️ 标签**：`数组` `二分查找`  
**🟡 难度**：`中等`  

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

示例 1：
```
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

示例 2：
```
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；或者返回索引 5，其峰值元素为 6。
```

提示：
- 1 <= nums.length <= 1000
- -2³¹ <= nums[i] <= 2³¹ - 1
- 对于所有有效的 i 都有 nums[i] != nums[i + 1]

---

## 解题思路

### 二分查找

#### 📝 核心思想
这道题的关键在于理解：如果我们在一个位置，它的值比右边的值小，那么右边一定存在一个峰值。这是因为：
1. 如果右边一直递增，那么最右边的元素就是峰值（因为 nums[n] = -∞）
2. 如果右边不是一直递增，那么第一个下降的位置就是峰值

同理，如果一个位置的值比左边的值小，那么左边一定存在一个峰值。

基于这个性质，我们可以使用二分查找来寻找峰值，每次都去有峰值的那一半继续查找。

#### 🛠️ 实现步骤
1. 处理特殊情况：
   - 如果数组为空，返回 -1
   - 如果数组只有一个元素，返回 0
   - 如果第一个元素大于第二个元素，返回 0
   - 如果最后一个元素大于倒数第二个元素，返回最后一个元素的索引

2. 使用二分查找：
   - 初始化左右指针，left = 1, right = nums.length - 2
   - 当 left <= right 时：
     * 计算中间位置 mid
     * 如果 nums[mid] 大于其左右相邻元素，返回 mid
     * 如果 nums[mid-1] > nums[mid]，说明左边一定有峰值，搜索左半部分
     * 否则右边一定有峰值，搜索右半部分

#### 🧩 示例分析
以示例 2 为例：nums = [1,2,1,3,5,6,4]

| 步骤 | 区间 | mid | nums[mid-1] | nums[mid] | nums[mid+1] | 操作 | 说明 |
|-----|------|-----|-------------|-----------|-------------|------|------|
| 1 | [1,5] | 3 | 1 | 3 | 5 | 右半部分 | 3 < 5，右边一定有峰值 |
| 2 | [4,5] | 4 | 3 | 5 | 6 | 右半部分 | 5 < 6，右边一定有峰值 |
| 3 | [5,5] | 5 | 5 | 6 | 4 | 返回 5 | 6 大于左右相邻值，是峰值 |

图解过程：
```
初始数组：[1, 2, 1, 3, 5, 6, 4]
第一步：  [1, 2, 1, 3, 5, 6, 4]
                  ↑
                 mid=3 < 5，搜索右半部分
第二步：  [1, 2, 1, 3, 5, 6, 4]
                     ↑
                    mid=5 < 6，搜索右半部分
第三步：  [1, 2, 1, 3, 5, 6, 4]
                        ↑
                       mid=6 是峰值
```

---

## 代码实现

完整的可运行代码：[L0162_FindPeakElement.java](../src/main/java/L0162_FindPeakElement.java)

```java
public int findPeakElement(int[] nums) {
    if (nums == null || nums.length == 0) {
        return -1;
    }
    
    // 如果数组只有一个元素，它就是峰值
    if (nums.length == 1) {
        return 0;
    }
    
    // 如果第一个元素大于第二个元素，它就是峰值
    if (nums[0] > nums[1]) {
        return 0;
    }
    
    // 如果最后一个元素大于倒数第二个元素，它就是峰值
    if (nums[nums.length - 1] > nums[nums.length - 2]) {
        return nums.length - 1;
    }
    
    // 使用二分查找
    int left = 1;
    int right = nums.length - 2;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        // 如果中间元素大于其左右相邻元素，它就是峰值
        if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1]) {
            return mid;
        }
        // 如果左边元素大于中间元素，说明左边一定有峰值
        else if (nums[mid - 1] > nums[mid]) {
            right = mid - 1;
        }
        // 否则右边一定有峰值
        else {
            left = mid + 1;
        }
    }
    
    return -1;  // 理论上不会到达这里
}
```

---

## 复杂度分析

- **时间复杂度**：O(log n)，其中 n 是数组的长度
  - 使用二分查找，每次将搜索范围缩小一半
  - 最多需要 log n 次比较就能找到峰值

- **空间复杂度**：O(1)
  - 只使用了几个变量来存储指针和临时值
  - 不需要额外的数组空间

---

## 优化思路

1. **边界条件优化**
   - 可以在开始时判断更多的特殊情况
   - 例如数组长度为 2 的情况
   - 可以减少一些不必要的计算

2. **二分查找的变体**
   - 可以只比较中间元素和其右边元素
   - 如果 nums[mid] < nums[mid + 1]，说明右边一定有峰值
   - 否则左边一定有峰值
   - 这样可以减少一次比较操作

3. **初始化优化**
   - 可以直接从整个数组开始二分
   - 不需要特别处理边界情况
   - 但是需要注意处理数组边界的访问

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 