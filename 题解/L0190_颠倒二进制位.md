---
title: 颠倒二进制位
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[颠倒二进制位](https://leetcode.cn/problems/reverse-bits/)  
**🏷️ 标签**：`位运算` `分治`  
**🟢 难度**：`简单`  

颠倒给定的 32 位无符号整数的二进制位。

**提示：**
- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

**示例 1：**
```
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```

**示例 2：**
```
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471，其二进制表示形式为 10111111111111111111111111111111。
```

**提示：**
- 输入是一个长度为 32 的二进制字符串

---

## 解题思路

### 逐位反转法

#### 📝 核心思想
这道题的核心思想是：从右到左遍历原数的每一位，将每一位放到结果中对应的位置。具体来说：
1. 原数从右到左的第 i 位，应该放到结果从左到右的第 i 位
2. 使用位运算来提取和放置每一位
3. 使用循环处理所有 32 位

#### 🛠️ 实现步骤
1. 初始化结果变量 result = 0
2. 循环 32 次，每次处理一位：
   - 将结果左移一位，为新的位腾出空间
   - 取出原数的最后一位（使用 & 1 操作）
   - 将取出的位放到结果的最后（使用 | 操作）
   - 将原数右移一位，准备处理下一位
3. 返回最终结果

#### 🧩 示例分析
以 `n = 43261596`（二进制：`00000010100101000001111010011100`）为例：

| 步骤 | 原数剩余位 | 当前处理位 | 结果 | 说明 |
|-----|------------|-----------|------|------|
| 初始 | 00000010100101000001111010011100 | - | 00000000000000000000000000000000 | 初始状态 |
| 1 | 0000001010010100000111101001110 | 0 | 00000000000000000000000000000000 | 处理最后一位 0 |
| 2 | 000000101001010000011110100111 | 0 | 00000000000000000000000000000000 | 处理倒数第二位 0 |
| 3 | 00000010100101000001111010011 | 1 | 00000000000000000000000000000001 | 处理倒数第三位 1 |
| 4 | 0000001010010100000111101001 | 1 | 00000000000000000000000000000011 | 处理倒数第四位 1 |
| ... | ... | ... | ... | ... |
| 31 | 0 | 0 | 00111001011110000010100101000000 | 处理第二位 0 |
| 32 | - | 0 | 00111001011110000010100101000000 | 处理第一位 0 |

位运算过程示意：
```
步骤 1：
原数：00000010100101000001111010011100
取位：00000010100101000001111010011100 & 1 = 0
结果：00000000000000000000000000000000

步骤 2：
原数：0000001010010100000111101001110
取位：0000001010010100000111101001110 & 1 = 0
结果：00000000000000000000000000000000

步骤 3：
原数：000000101001010000011110100111
取位：000000101001010000011110100111 & 1 = 1
结果：00000000000000000000000000000001

... 以此类推
```

---

## 代码实现

完整的可运行代码：[L0190_ReverseBits.java](../src/main/java/L0190_ReverseBits.java)

```java
public int reverseBits(int n) {
    int result = 0;
    
    // 遍历 32 位
    for (int i = 0; i < 32; i++) {
        // 将结果左移一位，为新的位腾出空间
        result <<= 1;
        // 取出原数最后一位，加到结果中
        result |= (n & 1);
        // 将原数右移一位
        n >>>= 1;
    }
    
    return result;
}
```

---

## 复杂度分析

- **时间复杂度**：O(1)
  - 需要遍历 32 位，但这是一个常数
  - 每一位的操作都是 O(1) 的位运算
  - 因此总的时间复杂度是 O(1)

- **空间复杂度**：O(1)
  - 只需要常数个变量来存储中间结果
  - 不需要额外的空间

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 