---
title: 跳跃游戏 II
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)  
**🏷️ 标签**：`贪心` `数组` `动态规划`  
**🟡 难度**：`中等`  

给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:
- 0 <= j <= nums[i]
- i + j < n

返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。

**示例 1:**
```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**
```
输入: nums = [2,3,0,1,4]
输出: 2
```

**提示：**
- 1 <= nums.length <= 10⁴
- 0 <= nums[i] <= 1000
- 题目保证可以到达 nums[n-1]

---

## 解题思路

### 贪心算法

#### 📝 核心思想
使用贪心策略，在每一步跳跃时都尽可能到达最远的位置。我们不需要考虑具体跳到哪个位置，而是维护当前能够到达的最远位置，并在到达边界时更新跳跃次数。

#### 🛠️ 实现步骤
1. 初始化变量：
   - maxPosition：记录当前能够到达的最远位置
   - end：记录当前步数能够到达的边界
   - steps：记录跳跃次数
2. 遍历数组（不包括最后一个元素）：
   - 更新当前能够到达的最远位置
   - 如果到达当前步数的边界，更新边界并增加跳跃次数
3. 返回跳跃次数

#### 🧩 示例分析
以 nums = [2,3,1,1,4] 为例：

```text
初始状态：
[2, 3, 1, 1, 4]
 ↑
 i=0, maxPosition=0, end=0, steps=0

第一步：
[2, 3, 1, 1, 4]
 ↑
 i=0：maxPosition = max(0, 0+2) = 2
 到达边界 end=0：更新 end=2, steps=1

第二步：
[2, 3, 1, 1, 4]
    ↑
 i=1：maxPosition = max(2, 1+3) = 4
 未到达边界 end=2

第三步：
[2, 3, 1, 1, 4]
       ↑
 i=2：maxPosition = max(4, 2+1) = 4
 到达边界 end=2：更新 end=4, steps=2

第四步：
[2, 3, 1, 1, 4]
          ↑
 i=3：maxPosition = max(4, 3+1) = 4
 未到达边界 end=4

最终结果：steps = 2
```

详细的步骤分析：

| 步骤 | 当前位置 i | maxPosition | end | steps | 说明 |
|-----|------------|-------------|-----|-------|------|
| 初始 | 0 | 0 | 0 | 0 | 初始状态 |
| 1 | 0 | 2 | 2 | 1 | 第一次跳跃，可以到达位置 2 |
| 2 | 1 | 4 | 2 | 1 | 更新最远可达位置为 4 |
| 3 | 2 | 4 | 4 | 2 | 第二次跳跃，可以到达位置 4（终点） |
| 4 | 3 | 4 | 4 | 2 | 已经可以到达终点，继续遍历 |

为什么这种贪心策略是正确的？
1. 在每一步中，我们都计算从当前位置到最远可达位置之间的所有点能够到达的最远位置
2. 当我们到达当前边界时，必须进行一次跳跃，而最远可达位置就是下一次跳跃能够到达的边界
3. 由于题目保证可以到达终点，所以这种贪心策略一定能找到最少的跳跃次数

---

## 代码实现

完整的可运行代码：[L0045_JumpGameII.java](../src/main/java/L0045_JumpGameII.java)

```java
public int jump(int[] nums) {
    // 如果数组长度小于等于 1，不需要跳跃
    if (nums == null || nums.length <= 1) {
        return 0;
    }
    
    // 记录当前能够到达的最远位置
    int maxPosition = 0;
    // 记录当前步数能够到达的边界
    int end = 0;
    // 记录跳跃次数
    int steps = 0;
    
    // 遍历数组（不需要访问最后一个元素）
    for (int i = 0; i < nums.length - 1; i++) {
        // 更新当前能够到达的最远位置
        maxPosition = Math.max(maxPosition, i + nums[i]);
        
        // 如果到达当前步数能够到达的边界
        if (i == end) {
            // 更新边界为当前能够到达的最远位置
            end = maxPosition;
            // 增加跳跃次数
            steps++;
        }
    }
    
    return steps;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)
  - 只需要遍历一次数组
  - 每个位置的计算都是常数时间
  - n 是数组的长度

- **空间复杂度**：O(1)
  - 只使用了几个变量来记录状态
  - 不需要额外的空间

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 