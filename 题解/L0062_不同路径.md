---
title: 不同路径
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[不同路径](https://leetcode.cn/problems/unique-paths/)  
**🏷️ 标签**：`数组` `动态规划` `组合数学`  
**🟡 难度**：`中等`  

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 "Start" ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 "Finish" ）。

问总共有多少条不同的路径？

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

示例 1：
```
输入：m = 3, n = 7
输出：28
```

示例 2：
```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角：
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

示例 3：
```
输入：m = 7, n = 3
输出：28
```

示例 4：
```
输入：m = 3, n = 3
输出：6
```

提示：
- 1 <= m, n <= 100
- 题目数据保证答案小于等于 2 * 10⁹

---

## 解题思路
### 动态规划

#### 📝 核心思想
本题可以使用动态规划来解决。由于机器人每次只能向右或向下移动，所以到达某个位置的路径数等于到达其上方位置的路径数加上到达其左方位置的路径数。这是因为机器人只能从上方或左方到达当前位置。

#### 🛠️ 实现步骤
1. 创建动态规划数组 `dp[m][n]`，其中 `dp[i][j]` 表示到达位置 (i,j) 的不同路径数
2. 初始化第一行和第一列：
   - 由于只能向右或向下移动，所以第一行和第一列的所有位置的路径数都是 1
3. 对于其他位置，使用动态规划方程：
   - `dp[i][j] = dp[i-1][j] + dp[i][j-1]`
4. 最终返回 `dp[m-1][n-1]`，即到达右下角的路径数

#### 🧩 示例分析
以 m = 3, n = 3 的网格为例，分析整个过程：

1. 初始化 dp 数组：
```
1  1  1
1  ?  ?
1  ?  ?
```

2. 计算 dp[1][1]：
```
1  1  1
1  2  ?
1  ?  ?
```
dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2

3. 计算 dp[1][2]：
```
1  1  1
1  2  3
1  ?  ?
```
dp[1][2] = dp[0][2] + dp[1][1] = 1 + 2 = 3

4. 计算 dp[2][1]：
```
1  1  1
1  2  3
1  3  ?
```
dp[2][1] = dp[1][1] + dp[2][0] = 2 + 1 = 3

5. 计算 dp[2][2]（最终结果）：
```
1  1  1
1  2  3
1  3  6
```
dp[2][2] = dp[1][2] + dp[2][1] = 3 + 3 = 6

因此，从左上角到右下角共有 6 条不同的路径。

---

## 代码实现

完整的可运行代码：[L0062_UniquePaths.java](../src/main/java/L0062_UniquePaths.java)

```java
public int uniquePaths(int m, int n) {
    // 创建动态规划数组，dp[i][j] 表示到达位置 (i,j) 的不同路径数
    int[][] dp = new int[m][n];

    // 初始化第一行和第一列
    // 因为只能向右或向下移动，所以第一行和第一列的路径数都是 1
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (int j = 0; j < n; j++) {
        dp[0][j] = 1;
    }

    // 动态规划计算每个位置的路径数
    // 到达位置 (i,j) 的路径数等于到达其上方位置的路径数加上到达其左方位置的路径数
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }

    // 返回到达右下角位置的路径数
    return dp[m - 1][n - 1];
}
```

---

## 复杂度分析

- **时间复杂度**：O(m × n)。需要填充整个动态规划数组，数组大小为 m × n。
- **空间复杂度**：O(m × n)。需要一个 m × n 的二维数组来存储中间结果。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 