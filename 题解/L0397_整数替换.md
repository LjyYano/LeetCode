---
title: 整数替换
date: 2025-02-11
---

## 题目描述

**🔗 题目**：[397. 整数替换](https://leetcode.cn/problems/integer-replacement/)  
**🏷️ 标签**：`贪心` `位运算` `记忆化搜索` `动态规划`  
**🟡 难度**：`中等`  

给定一个正整数 n ，你可以做如下操作：

1. 如果 n 是偶数，则用 n / 2替换 n 。
2. 如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。

n 变为 1 所需的最小替换次数是多少？

示例 1：
```
输入：n = 8
输出：3
解释：8 -> 4 -> 2 -> 1
```

示例 2：
```
输入：n = 7
输出：4
解释：7 -> 8 -> 4 -> 2 -> 1
或 7 -> 6 -> 3 -> 2 -> 1
```

示例 3：
```
输入：n = 4
输出：2
```

提示：
- 1 <= n <= 2³¹ - 1

---

## 解题思路
### 递归解法

#### 📝 核心思想
这道题可以使用递归的思想来解决。对于每个数字 n，我们需要考虑以下情况：
1. 如果 n 是偶数，那么只有一种选择，就是除以 2
2. 如果 n 是奇数，我们有两种选择：加 1 或减 1，需要选择能得到最小步数的那个选择

通过递归，我们可以不断地将问题规模缩小，直到达到基准情况（n = 1）。

#### 🛠️ 实现步骤
1. 基准情况：当 n = 1 时，不需要任何操作，返回 0
2. 如果 n 是偶数：直接返回 1 + 递归处理 n/2 的结果
3. 如果 n 是奇数：返回 1 + min(递归处理 n+1 的结果, 递归处理 n-1 的结果)
4. 注意处理整数溢出的情况，使用 long 类型

#### 🧩 示例分析
以 n = 7 为例，让我们看看递归的过程：

| 步骤 | 当前值 | 操作 | 下一步值 | 剩余步数 | 总步数 |
|-----|-------|------|---------|---------|--------|
| 1 | 7 | +1 | 8 | 3 | 4 |
| 2 | 8 | /2 | 4 | 2 | 3 |
| 3 | 4 | /2 | 2 | 1 | 2 |
| 4 | 2 | /2 | 1 | 0 | 1 |
| 5 | 1 | 结束 | - | - | 0 |

另一种路径：

| 步骤 | 当前值 | 操作 | 下一步值 | 剩余步数 | 总步数 |
|-----|-------|------|---------|---------|--------|
| 1 | 7 | -1 | 6 | 3 | 4 |
| 2 | 6 | /2 | 3 | 2 | 3 |
| 3 | 3 | -1 | 2 | 1 | 2 |
| 4 | 2 | /2 | 1 | 0 | 1 |
| 5 | 1 | 结束 | - | - | 0 |

两种路径都需要 4 步才能到达 1。

---

## 代码实现

完整的可运行代码：[L0397_IntegerReplacement.java](../src/main/java/L0397_IntegerReplacement.java)

```java
public class L0397_IntegerReplacement {

    // 使用递归解法
    public int integerReplacement(int n) {
        // 使用 long 类型避免整数溢出
        return (int) helper((long) n);
    }

    // 递归辅助方法
    private long helper(long n) {
        // 基准情况：当 n 为 1 时，不需要替换
        if (n == 1) {
            return 0;
        }
        
        // 如果是偶数，直接除以 2
        if (n % 2 == 0) {
            return 1 + helper(n / 2);
        }
        
        // 如果是奇数，取 n+1 和 n-1 中的最小值
        return 1 + Math.min(helper(n + 1), helper(n - 1));
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(log n)。每次操作都会将数字减半或加/减 1，因此最多需要 log n 次操作。
- **空间复杂度**：O(log n)。递归调用栈的深度为 log n。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 