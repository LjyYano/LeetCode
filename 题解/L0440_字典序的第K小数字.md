---
title: 字典序的第K小数字
date: 2024-03-27
---

## 题目描述

**🔗 题目**：[字典序的第K小数字](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/)  
**🏷️ 标签**：`字典树` `数学`  
**🔴 难度**：`困难`  

给定整数 n 和 k，返回 [1, n] 中字典序第 k 小的数字。

示例 1：
```
输入: n = 13, k = 2
输出: 10
解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```

示例 2：
```
输入: n = 1, k = 1
输出: 1
```

---

## 解题思路
### 字典树模拟

#### 📝 核心思想
1. 字典序实际上就是按照字符串比较的方式来排序
2. 可以将数字看作是一个 10 叉树，每个节点的子节点是原数字乘以 10 加上 0-9
3. 按照字典序遍历这棵树，就是按照先序遍历的顺序
4. 不需要真正构建这棵树，而是通过计算来模拟遍历过程

#### 🛠️ 实现步骤
1. 从 1 开始（因为字典序最小的数字是 1）
2. 计算以当前数字为前缀的所有数字的个数
3. 如果个数小于等于 k，说明第 k 小的数不在当前前缀下，需要移动到下一个前缀
4. 如果个数大于 k，说明第 k 小的数在当前前缀下，需要向下一层移动

#### 🧩 示例分析
以 n = 13, k = 2 为例，我们来看看如何找到字典序第 2 小的数字：

1. 首先，我们构建一个虚拟的 10 叉树：
```
                1                    2    3    4    ...    9
              /   \
            10    11,12,13
```

2. 计算以 1 为前缀的数字个数：
   - 第一层：1
   - 第二层：10
   - 第三层：11,12,13
   - 总共有 5 个数字（1,10,11,12,13）

3. 查找过程：
   | 步骤 | 当前数字 | 剩余 k | 计算的个数 | 操作 |
   |-----|---------|--------|-----------|------|
   | 1 | 1 | 1 | 5 | k < 5，向下移动 |
   | 2 | 10 | 0 | - | 找到答案 |

4. 因此，字典序第 2 小的数字是 10

详细的遍历过程：
```
1. 从 1 开始
   - 计算以 1 为前缀的数字个数：5 个（1,10,11,12,13）
   - k = 1 < 5，说明答案在这个子树中
   - curr *= 10，变成 10
   - k--，变成 0

2. k = 0，说明找到了答案
   - 返回 curr = 10
```

---

## 代码实现

完整的可运行代码：[L0440_KthSmallestInLexicographicalOrder.java](../src/main/java/L0440_KthSmallestInLexicographicalOrder.java)

```java
public int findKthNumber(int n, int k) {
    // 从 1 开始，因为字典序最小的数字是 1
    int curr = 1;
    // k 需要减 1，因为我们从 1 开始
    k = k - 1;
    
    while (k > 0) {
        // 计算以 curr 为前缀的数字个数
        int steps = calSteps(n, curr, curr + 1);
        
        // 如果 steps <= k，说明第 k 小的数不在以 curr 为前缀的数中
        if (steps <= k) {
            curr++; // 移动到下一个前缀
            k -= steps;
        } else {
            // 如果 steps > k，说明第 k 小的数在以 curr 为前缀的数中
            curr *= 10; // 向下一层移动
            k--;
        }
    }
    
    return curr;
}

/**
 * 计算在 n 的范围内，以 n1 为前缀的数字个数
 * 例如：n = 100, n1 = 1, n2 = 2
 * 返回的是以 1 为前缀且不超过 100 的数字个数
 */
private int calSteps(int n, long n1, long n2) {
    int steps = 0;
    
    // 同一层的数字比较
    while (n1 <= n) {
        // 如果 n2 <= n，则当前层的数字都可以取到
        steps += Math.min(n + 1, n2) - n1;
        // 进入下一层
        n1 *= 10;
        n2 *= 10;
    }
    
    return steps;
}
```

---

## 复杂度分析

- **时间复杂度**：O(log n)
  - 每次计算以某个前缀开头的数字个数需要 O(log n) 的时间
  - 总共需要计算 O(log n) 次
  - 因此总时间复杂度为 O(log n)

- **空间复杂度**：O(1)
  - 只使用了常数个变量
  - 没有使用额外的数据结构
  - 因此空间复杂度为常数级

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 