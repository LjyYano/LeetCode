---
title: 根据身高重建队列
date: 2024-02-11
---

## 题目描述

**🔗 题目**：[根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/description/)  
**🏷️ 标签**：`贪心` `数组` `排序`  
**🟡 难度**：`中等`  

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面正好有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

示例 1：
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。

示例 2：
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]

---

## 解题思路

### 贪心算法

#### 📝 核心思想
贪心策略：先按身高从高到低排序，身高相同的按 k 值从小到大排序。然后按照 k 值将每个人插入到对应位置。这样做的原因是：
1. 身高高的人不会受身高低的人的影响
2. 身高相同时，k 值小的应该在前面
3. 按照这个顺序插入，每个人的位置都是最终位置

#### 🛠️ 实现步骤
1. 对数组按身高降序排序，身高相同时按 k 值升序排序
2. 创建一个空的 List 用于存储结果
3. 遍历排序后的数组，将每个人插入到其 k 值对应的位置
4. 将 List 转换为数组返回

#### 🧩 示例分析
以示例 1 为例：`[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]`

排序过程：
1. 按身高降序，k 值升序排序：
   ```
   [7,0] [7,1] [6,1] [5,0] [5,2] [4,4]
   ```

插入过程：
| 步骤 | 当前处理的人 [h,k] | 插入位置 | 当前队列 | 说明 |
|-----|------------------|---------|---------|------|
| 1 | [7,0] | 0 | [[7,0]] | 插入到位置 0 |
| 2 | [7,1] | 1 | [[7,0], [7,1]] | 插入到位置 1 |
| 3 | [6,1] | 1 | [[7,0], [6,1], [7,1]] | 插入到位置 1 |
| 4 | [5,0] | 0 | [[5,0], [7,0], [6,1], [7,1]] | 插入到位置 0 |
| 5 | [5,2] | 2 | [[5,0], [7,0], [5,2], [6,1], [7,1]] | 插入到位置 2 |
| 6 | [4,4] | 4 | [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] | 插入到位置 4 |

最终结果：`[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]`

---

## 代码实现

完整的可运行代码：[L0406_QueueReconstructionByHeight.java](../src/main/java/L0406_QueueReconstructionByHeight.java)

```java
public int[][] reconstructQueue(int[][] people) {
    // 按身高降序排序，身高相同时按 k 值升序排序
    Arrays.sort(people, (a, b) -> {
        if (a[0] != b[0]) {
            return b[0] - a[0];
        }
        return a[1] - b[1];
    });
    
    // 使用 List 存储结果，方便插入操作
    List<int[]> result = new ArrayList<>();
    // 按照 k 值将每个人插入到对应位置
    for (int[] person : people) {
        result.add(person[1], person);
    }
    
    // 将 List 转换为数组返回
    return result.toArray(new int[result.size()][]);
}
```

---

## 复杂度分析

- **时间复杂度**：O(n²)，其中 n 是数组的长度。排序需要 O(nlogn)，插入操作需要 O(n²)。
- **空间复杂度**：O(n)，需要额外的空间存储结果。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 