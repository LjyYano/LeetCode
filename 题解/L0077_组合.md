---
title: 组合
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[组合](https://leetcode.cn/problems/combinations/)  
**🏷️ 标签**：`回溯` `组合`  
**🟡 难度**：`中等`  

给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

你可以按 任何顺序 返回答案。

示例 1：
```
输入：n = 4, k = 2
输出：[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
```

示例 2：
```
输入：n = 1, k = 1
输出：[[1]]
```

提示：
- 1 <= n <= 20
- 1 <= k <= n

---

## 解题思路
### 回溯算法

#### 📝 核心思想
本题使用回溯算法来解决。回溯算法是一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化来尝试新的候选解。

主要思路如下：
1. 从 1 到 n 的数字中选择 k 个数字
2. 使用回溯法，每次选择一个数字，然后继续选择剩余的数字
3. 当选择的数字个数等于 k 时，就找到了一个组合
4. 通过剪枝优化，减少不必要的搜索

#### 🛠️ 实现步骤
1. 初始化：
   - 创建结果列表 result 存储所有组合
   - 创建当前组合列表 current 存储正在构建的组合
   - 从数字 1 开始尝试

2. 回溯过程：
   - 如果已经选择了 k 个数字，将当前组合加入结果集
   - 如果剩余可选的数字不够凑成 k 个，直接返回（剪枝优化）
   - 从当前数字开始，尝试选择每个可能的数字
   - 选择一个数字后，继续递归选择下一个数字
   - 回溯时移除最后选择的数字

3. 剪枝优化：
   - 在选择数字时，判断剩余可选的数字是否足够
   - 如果剩余数字不够凑成 k 个，就不用继续尝试

#### 🧩 示例分析
以 n = 4, k = 2 为例，分析回溯过程：

```
递归树形结构：
                    []
        /           |           \          \
      [1]          [2]          [3]        [4]
    /  |  \        |  \          \
[1,2][1,3][1,4]  [2,3][2,4]     [3,4]
```

详细的选择过程：

| 步骤 | 当前组合 | 可选范围 | 剩余需选 | 操作 | 是否有效 |
|-----|---------|---------|---------|------|---------|
| 1 | [] | [1,2,3,4] | 2 | 选择 1 | - |
| 2 | [1] | [2,3,4] | 1 | 选择 2 | ✓ |
| 3 | [1] | [2,3,4] | 1 | 选择 3 | ✓ |
| 4 | [1] | [2,3,4] | 1 | 选择 4 | ✓ |
| 5 | [] | [1,2,3,4] | 2 | 选择 2 | - |
| 6 | [2] | [3,4] | 1 | 选择 3 | ✓ |
| 7 | [2] | [3,4] | 1 | 选择 4 | ✓ |
| 8 | [] | [1,2,3,4] | 2 | 选择 3 | - |
| 9 | [3] | [4] | 1 | 选择 4 | ✓ |

剪枝优化说明：
1. 当选择第一个数字时，不能从太后面的数字开始
   - 例如，如果还需要选择 2 个数字，最多只能从 n-1 开始选择
2. 通过判断 n - start + 1 < k 来实现剪枝
   - n - start + 1 表示剩余可选的数字个数
   - k 表示还需要选择的数字个数
   - 如果剩余数字不够，就不用继续尝试

---

## 代码实现

完整的可运行代码：[L0077_Combinations.java](../src/main/java/L0077_Combinations.java)

```java
public List<List<Integer>> combine(int n, int k) {
    List<List<Integer>> result = new ArrayList<>();
    // 从 1 开始回溯
    backtrack(result, new ArrayList<>(), 1, n, k);
    return result;
}

private void backtrack(List<List<Integer>> result, List<Integer> current, int start, int n, int k) {
    // 如果已经选够了 k 个数字，将当前组合加入结果集
    if (k == 0) {
        result.add(new ArrayList<>(current));
        return;
    }

    // 剪枝优化：如果剩余的数字不够凑成 k 个，就不用继续了
    // 还需要 k 个数字，但是从 start 到 n 只剩下 n-start+1 个数字
    if (n - start + 1 < k) {
        return;
    }

    // 尝试选择每个可能的数字
    for (int i = start; i <= n; i++) {
        // 选择当前数字
        current.add(i);
        // 继续递归选择下一个数字
        backtrack(result, current, i + 1, n, k - 1);
        // 回溯，移除最后选择的数字
        current.remove(current.size() - 1);
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(C(n,k))，其中 C(n,k) 是组合数。
  - 需要生成所有可能的组合
  - 剪枝优化可以减少实际的计算量
  - 每个组合需要 O(k) 的时间来构建

- **空间复杂度**：O(k)
  - 递归调用栈的深度最大为 k
  - 不考虑存储最终结果所需的空间
  - current 列表在任何时候最多存储 k 个数字

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 