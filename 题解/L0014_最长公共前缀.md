---
title: 最长公共前缀
date: 2024-02-06
---

## 题目描述

**🔗 题目**：[最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)  
**🏷️ 标签**：`字符串`  
**🟢 难度**：`简单`  

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1：**
```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**示例 2：**
```
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

**提示：**
- `1 <= strs.length <= 200`
- `0 <= strs[i].length <= 200`
- `strs[i]` 仅由小写英文字母组成

---

## 解题思路

### 纵向扫描

#### 📝 核心思想
从前往后遍历字符串的每一个字符位置，比较所有字符串在相同位置上的字符是否相同。一旦发现不同，或者某个字符串已经到达末尾，就返回当前已经匹配的部分作为最长公共前缀。

#### 🛠️ 实现步骤
1. 处理边界情况：如果数组为空，返回空字符串
2. 使用第一个字符串作为基准，遍历它的每个字符：
   - 获取当前位置的字符
   - 与其他所有字符串的相同位置的字符进行比较
   - 如果发现不匹配，或者某个字符串已经到达末尾，返回当前位置之前的子串
3. 如果循环正常结束，说明第一个字符串就是最长公共前缀

#### 🧩 示例分析
以 `strs = ["flower", "flow", "flight"]` 为例：

横向字符位置对比表：

| 字符串   | 位置0 | 位置1 | 位置2 | 位置3 | 位置4 | 位置5 | 最长匹配位 |
|----------|-------|-------|-------|-------|-------|-------|------------|
| flower   | f     | l     | o     | w     | e     | r     | →          |
| flow     | f     | l     | o     | w     | -     | -     | →          |
| flight   | f     | l     | i     | g     | h     | t     | →          |
| 比较结果 | ✅    | ✅    | ❌    | -     | -     | -     | ▲ 终止位置  |

关键分析点：
1. 前两列（位置0-1）全部匹配 ✅
2. 位置2出现差异：o vs i ❌
3. 最终有效匹配长度 = 2 → 公共前缀 "fl"

符号说明：
- ✅：所有字符串在该位置字符相同
- ❌：存在不同字符
- - ：无需比较（因已发现不匹配）
- ▲ ：终止比较位置

#### 为什么这种方法是正确的？
1. 公共前缀必须出现在所有字符串的开头
2. 一旦发现某个位置的字符不匹配，该位置及之后的字符都不可能是公共前缀的一部分
3. 如果某个字符串已经到达末尾，那么更长的前缀也不可能是公共前缀

---

## 代码实现

完整的可运行代码：[L0014_LongestCommonPrefix.java](../src/main/java/L0014_LongestCommonPrefix.java)

```java
public String longestCommonPrefix(String[] strs) {
    // 处理边界情况
    if (strs == null || strs.length == 0) {
        return "";
    }
    
    // 使用第一个字符串作为基准
    String firstStr = strs[0];
    
    // 遍历第一个字符串的每个字符
    for (int i = 0; i < firstStr.length(); i++) {
        char c = firstStr.charAt(i);
        
        // 与其他字符串比较当前位置的字符
        for (int j = 1; j < strs.length; j++) {
            // 如果当前字符串已经到达末尾，或者字符不匹配
            if (i >= strs[j].length() || strs[j].charAt(i) != c) {
                // 返回当前位置之前的子串
                return firstStr.substring(0, i);
            }
        }
    }
    
    // 如果循环正常结束，说明第一个字符串就是最长公共前缀
    return firstStr;
}
```

---

## 复杂度分析

- **时间复杂度**：`O(S)`，其中 S 是所有字符串中字符数量的总和。最坏情况下，所有字符串都相同，我们需要比较每个字符串的每个字符。
- **空间复杂度**：`O(1)`，我们只需要常数级别的额外空间来存储变量。

---

## LeetCode 题解

[LeetCode 最全题解](https://github.com/LjyYano/LeetCode) 