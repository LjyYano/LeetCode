---
title: 拼接最大数
date: 2024-02-10
---

## 题目描述

**🔗 题目**：[拼接最大数](https://leetcode.cn/problems/create-maximum-number/)  
**🏷️ 标签**：`栈` `贪心` `动态规划`  
**🔴 难度**：`困难`  

给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。

说明: 请尽可能地优化你算法的时间和空间复杂度。

示例 1:
```
输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]
```

示例 2:
```
输入:
nums1 = [6, 7]
nums2 = [6, 0, 4]
k = 5
输出:
[6, 7, 6, 0, 4]
```

示例 3:
```
输入:
nums1 = [3, 9]
nums2 = [8, 9]
k = 3
输出:
[9, 8, 9]
```

---

## 解题思路

### 单调栈 + 贪心

#### 📝 核心思想

这道题可以分为三个子问题：
1. 从一个数组中选择指定数量的数字，保持相对顺序，使得结果最大
2. 将两个数组合并，使得结果最大
3. 枚举从两个数组中分别选择的数字个数，找到最优解

对于第一个子问题，我们可以使用单调栈来解决。对于第二个子问题，我们需要设计一个合并策略，使得结果最大。对于第三个子问题，我们需要枚举所有可能的分配方案。

#### 🛠️ 实现步骤

1. 从单个数组选择数字：
   - 使用单调栈维护当前选择的数字
   - 遍历数组，当当前数字大于栈顶元素且还可以丢弃数字时，弹出栈顶元素
   - 如果栈未满，将当前数字入栈

2. 合并两个数组：
   - 比较两个数组从当前位置开始的子数组的大小
   - 选择较大的数组的当前元素放入结果中

3. 枚举分配方案：
   - 遍历从第一个数组中选择的数字个数 i
   - i 的范围是 [max(0, k-n2), min(k, n1)]
   - 从第二个数组中选择 k-i 个数字
   - 合并两个结果，更新最大值

#### 🧩 示例分析

以示例 1 为例：
```
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
```

1. 枚举从 nums1 中选择的数字个数 i：

   | i | 从 nums1 选择 | 从 nums2 选择 | 合并结果 |
   |---|-------------|-------------|----------|
   | 0 | [] | [9,8,5,3,2] | [9,8,5,3,2] |
   | 1 | [6] | [9,8,5,3] | [9,8,6,5,3] |
   | 2 | [6,5] | [9,8,3] | [9,8,6,5,3] |
   | 3 | [6,5,4] | [9,8] | [9,8,6,5,4] |
   | 4 | [6,5,4,3] | [9] | [9,6,5,4,3] |

2. 以 i = 2 为例，详细分析从 nums1 中选择 2 个数字的过程：
   ```
   nums1 = [3, 4, 6, 5]
   需要选择 2 个数字
   
   遍历到 3：stack = [3]
   遍历到 4：stack = [4]（可以丢弃 3）
   遍历到 6：stack = [6]（可以丢弃 4）
   遍历到 5：stack = [6,5]
   
   最终结果：[6,5]
   ```

3. 合并过程示例（[6,5] 和 [9,8,3]）：
   ```
   比较 6 和 9：选择 9
   比较 6 和 8：选择 8
   比较 6 和 3：选择 6
   选择剩余的 5
   选择剩余的 3
   
   最终结果：[9,8,6,5,3]
   ```

---

## 代码实现

完整的可运行代码：[L0321_CreateMaximumNumber.java](../src/main/java/L0321_CreateMaximumNumber.java)

```java
public int[] maxNumber(int[] nums1, int[] nums2, int k) {
    int n1 = nums1.length;
    int n2 = nums2.length;
    // 结果数组
    int[] result = new int[k];
    // 从 nums1 中选取的数字个数范围：[max(0, k-n2), min(k, n1)]
    for (int i = Math.max(0, k - n2); i <= Math.min(k, n1); i++) {
        // 从 nums1 中选 i 个数字，从 nums2 中选 k-i 个数字
        int[] candidate = merge(
            maxArray(nums1, i),
            maxArray(nums2, k - i)
        );
        // 更新结果数组
        if (greater(candidate, 0, result, 0)) {
            result = candidate;
        }
    }
    return result;
}
```

---

## 复杂度分析

- **时间复杂度**：O((m+n)³)，其中 m 和 n 分别是两个数组的长度
  - 从单个数组选择数字的时间复杂度是 O(n)
  - 合并两个数组的时间复杂度是 O((m+n)²)
  - 需要枚举 O(k) 种分配方案
  - 总时间复杂度为 O((m+n)³)

- **空间复杂度**：O(k)
  - 需要额外的空间来存储选择的数字和合并的结果
  - 单调栈的空间复杂度是 O(k)
  - 总空间复杂度为 O(k)

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 