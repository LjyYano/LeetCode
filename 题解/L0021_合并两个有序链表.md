# 合并两个有序链表
date: 2025-02-08

## 题目描述

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**🔗 题目**: [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

**🏷️ 标签**: 递归、链表

**🟢 难度**: 简单

### 示例 1：
![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

### 示例 2：
```
输入：l1 = [], l2 = []
输出：[]
```

### 示例 3：
```
输入：l1 = [], l2 = [0]
输出：[0]
```

### 提示：
- 两个链表的节点数目范围是 [0, 50]
- -100 <= Node.val <= 100
- l1 和 l2 均按 非递减顺序 排列

## 解题思路

### 核心思路
1. 使用迭代的方法，同时遍历两个链表
2. 创建一个哑节点（dummy node）作为新链表的头部，方便处理边界情况
3. 每次比较两个链表当前节点的值，将较小的节点连接到新链表上
4. 移动较小节点所在链表的指针到下一个节点
5. 重复步骤 3-4，直到其中一个链表遍历完
6. 将剩余链表直接连接到新链表的末尾

### 步骤分析
1. 创建哑节点 dummy，用于简化头节点的处理
2. 创建 current 指针指向 dummy，用于构建新链表
3. 当两个链表都不为空时：
   - 比较两个链表当前节点的值
   - 将较小值的节点连接到 current 的后面
   - 移动对应链表的指针到下一个节点
   - 移动 current 指针到下一个节点
4. 处理剩余节点：
   - 如果 list1 还有剩余节点，直接连接到 current 后面
   - 如果 list2 还有剩余节点，直接连接到 current 后面
5. 返回 dummy.next 作为合并后的链表头节点

### 示例分析
以示例 1 为例，演示合并过程：
```
输入：l1 = [1,2,4], l2 = [1,3,4]

初始状态：
l1: 1 -> 2 -> 4
l2: 1 -> 3 -> 4
结果：dummy -> null

第一步：比较 1 和 1
l1: 2 -> 4
l2: 1 -> 3 -> 4
结果：dummy -> 1 -> null

第二步：比较 2 和 1
l1: 2 -> 4
l2: 3 -> 4
结果：dummy -> 1 -> 1 -> null

第三步：比较 2 和 3
l1: 4
l2: 3 -> 4
结果：dummy -> 1 -> 1 -> 2 -> null

第四步：比较 4 和 3
l1: 4
l2: 4
结果：dummy -> 1 -> 1 -> 2 -> 3 -> null

第五步：比较 4 和 4
l1: null
l2: 4
结果：dummy -> 1 -> 1 -> 2 -> 3 -> 4 -> null

最后：连接剩余节点
结果：dummy -> 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> null
```

## 代码实现

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    // 创建一个哑节点作为新链表的头部
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    
    // 当两个链表都不为空时，比较节点值并连接
    while (list1 != null && list2 != null) {
        if (list1.val <= list2.val) {
            current.next = list1;
            list1 = list1.next;
        } else {
            current.next = list2;
            list2 = list2.next;
        }
        current = current.next;
    }
    
    // 如果 list1 还有剩余节点，直接连接到末尾
    if (list1 != null) {
        current.next = list1;
    }
    
    // 如果 list2 还有剩余节点，直接连接到末尾
    if (list2 != null) {
        current.next = list2;
    }
    
    return dummy.next;
}
```

## 复杂度分析

- **时间复杂度**: O(n + m)，其中 n 和 m 分别是两个链表的长度。需要遍历两个链表各一次。
- **空间复杂度**: O(1)，只使用了常数个指针变量。 