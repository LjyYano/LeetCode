---
title: 旋转数组
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[旋转数组](https://leetcode.cn/problems/rotate-array/)  
**🏷️ 标签**：`数组` `数学` `双指针`  
**🟡 难度**：`中等`  

给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

示例 1：
```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

示例 2：
```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

提示：
- 1 <= nums.length <= 10⁵
- -2³¹ <= nums[i] <= 2³¹ - 1
- 0 <= k <= 10⁵

---

## 解题思路

### 数组反转法

#### 📝 核心思想

这道题可以通过数组反转来实现。具体步骤是：
1. 首先反转整个数组
2. 然后反转前 k 个元素
3. 最后反转剩余的元素

这个方法的巧妙之处在于，通过三次反转，我们可以将数组向右轮转 k 个位置。

#### 🛠️ 实现步骤

1. 处理 k 值：
   - 当 k > nums.length 时，我们只需要移动 k % nums.length 个位置
   - 这是因为移动 nums.length 个位置相当于没有移动

2. 反转整个数组：
   - 使用双指针，从两端向中间移动
   - 交换两个指针指向的元素

3. 反转前 k 个元素：
   - 使用相同的反转方法
   - 范围是 [0, k-1]

4. 反转剩余元素：
   - 使用相同的反转方法
   - 范围是 [k, nums.length-1]

#### 🧩 示例分析

以示例 1 为例：nums = [1,2,3,4,5,6,7], k = 3

1. 处理 k 值：
   - k = 3 < nums.length = 7，无需处理

2. 第一次反转（整个数组）：
   | 步骤 | 数组状态 | 说明 |
   |-----|---------|------|
   | 初始 | [1,2,3,4,5,6,7] | 原始数组 |
   | 反转 | [7,6,5,4,3,2,1] | 整个数组反转 |

3. 第二次反转（前 k 个元素）：
   | 步骤 | 数组状态 | 说明 |
   |-----|---------|------|
   | 初始 | [7,6,5,4,3,2,1] | 上一步的结果 |
   | 反转 | [5,6,7,4,3,2,1] | 前 3 个元素反转 |

4. 第三次反转（剩余元素）：
   | 步骤 | 数组状态 | 说明 |
   |-----|---------|------|
   | 初始 | [5,6,7,4,3,2,1] | 上一步的结果 |
   | 反转 | [5,6,7,1,2,3,4] | 后 4 个元素反转 |

最终结果：[5,6,7,1,2,3,4]

---

## 代码实现

完整的可运行代码：[L0189_RotateArray.java](../src/main/java/L0189_RotateArray.java)

```java
public void rotate(int[] nums, int k) {
    k = k % nums.length; // 处理 k 大于数组长度的情况
    
    // 反转整个数组
    reverse(nums, 0, nums.length - 1);
    // 反转前 k 个元素
    reverse(nums, 0, k - 1);
    // 反转剩余元素
    reverse(nums, k, nums.length - 1);
}

/**
 * 反转数组中指定范围的元素
 */
private void reverse(int[] nums, int start, int end) {
    while (start < end) {
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start++;
        end--;
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组的长度。需要反转三次数组，每次反转的时间复杂度都是 O(n)。
- **空间复杂度**：O(1)，只需要常数级别的额外空间。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 