---
title: 只出现一次的数字 II
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/)  
**🏷️ 标签**：`位运算` `数组`  
**🟡 难度**：`中等`  

给你一个整数数组 nums ，除了某个元素只出现一次以外，其余每个元素都出现三次。请你找出那个只出现一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

**示例 1：**
```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**
```
输入：nums = [0,1,0,1,0,1,99]
输出：99
```

**提示：**
- 1 <= nums.length <= 3 * 10⁴
- -2³¹ <= nums[i] <= 2³¹ - 1
- nums 中，除某个元素仅出现一次外，其余每个元素都恰出现三次

---

## 解题思路

### 位运算法

#### 📝 核心思想
这道题是"只出现一次的数字"的进阶版本。在原题中，其他数字都出现两次，我们可以使用异或运算来解决。但在这道题中，其他数字都出现三次，我们需要一个新的思路。

关键思路是：
1. 如果一个数字出现三次，那么它的二进制表示中每一位上的 1 出现的次数一定是 3 的倍数
2. 因此，对于数组中所有数字的二进制表示，统计每一位上 1 出现的次数
3. 对这些次数对 3 取余，结果就是只出现一次的数字在该位上的值

#### 🛠️ 实现步骤
1. 初始化结果变量 result = 0
2. 遍历整数的每一位（0-31，因为是 32 位整数）：
   - 统计所有数字在当前位上 1 的个数
   - 将计数对 3 取余
   - 如果余数为 1，说明只出现一次的数字在这一位上是 1
3. 将每一位的结果组合成最终答案

#### 🧩 示例分析
以 `nums = [2,2,3,2]` 为例：

首先，将所有数字转换为二进制：
```
2 的二进制：0010
2 的二进制：0010
3 的二进制：0011
2 的二进制：0010
```

统计每一位上 1 的个数：
| 位数 | 数字的该位值 | 1的个数 | 对3取余 |
|-----|------------|---------|---------|
| 位3 | [0,0,0,0] | 0 | 0 |
| 位2 | [0,0,0,0] | 0 | 0 |
| 位1 | [1,1,1,1] | 4 | 1 |
| 位0 | [0,0,1,0] | 1 | 1 |

最终结果：
- 位3：0
- 位2：0
- 位1：1
- 位0：1
组合起来就是二进制 0011，即十进制 3。

以 `nums = [0,1,0,1,0,1,99]` 为例：

将所有数字转换为二进制：
```
0  的二进制：00000000
1  的二进制：00000001
0  的二进制：00000000
1  的二进制：00000001
0  的二进制：00000000
1  的二进制：00000001
99 的二进制：01100011
```

对于每一位：
1. 最低位（位0）：
   - 1 出现了 3 次（来自三个 1）
   - 1 出现了 1 次（来自 99）
   - 对 3 取余得 1
2. 位1：
   - 1 出现了 1 次（来自 99）
   - 对 3 取余得 1
3. 位5 和位6：
   - 1 各出现了 1 次（来自 99）
   - 对 3 取余得 1
4. 其他位：
   - 要么全是 0
   - 要么 1 出现了 3 次，对 3 取余得 0

最终得到二进制 01100011，即十进制 99。

---

## 代码实现

完整的可运行代码：[L0137_SingleNumberII.java](../src/main/java/L0137_SingleNumberII.java)

```java
public int singleNumber(int[] nums) {
    int result = 0;
    
    // 遍历每一位（0-31，因为是 32 位整数）
    for (int i = 0; i < 32; i++) {
        // 统计当前位上 1 的个数
        int bitSum = 0;
        for (int num : nums) {
            // 统计第 i 位上是否为 1
            bitSum += (num >> i) & 1;
        }
        // 对 3 取余，结果就是只出现一次的数字在该位上的值
        result |= (bitSum % 3) << i;
    }
    
    return result;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)
  - 需要遍历 32 次数组（因为整数是 32 位的）
  - 每次遍历的时间复杂度是 O(n)
  - 总的时间复杂度是 O(32n)，即 O(n)

- **空间复杂度**：O(1)
  - 只使用了几个变量来存储中间结果
  - 不需要额外的空间

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 