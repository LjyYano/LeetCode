---
title: 最少移动次数使数组元素相等 II
date: 2024-03-19
---

## 题目描述

**🔗 题目**：[最少移动次数使数组元素相等 II](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/)  
**🏷️ 标签**：`数组` `数学` `排序`  
**🟡 难度**：`中等`  

给你一个长度为 n 的整数数组 nums ，返回使所有数组元素相等需要的最少移动数。

在一步操作中，你可以使数组中的一个元素加 1 或者减 1 。

示例 1：
```
输入：nums = [1,2,3]
输出：2
解释：
只需要两步操作（每步操作指南使一个元素加 1 或减 1）：
[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
```

示例 2：
```
输入：nums = [1,10,2,9]
输出：16
```

提示：
- n == nums.length
- 1 <= nums.length <= 10⁵
- -10⁹ <= nums[i] <= 10⁹

---

## 解题思路

### 中位数法

#### 📝 核心思想
这道题的关键是要找到一个目标值，使得所有数字移动到这个目标值所需的步数最少。可以证明，这个最优的目标值就是数组的中位数。

为什么是中位数？我们可以通过以下方式来理解：
1. 假设我们选择了一个数 x 作为目标值
2. 对于数组中的每个数 nums[i]，需要的移动次数是 |nums[i] - x|
3. 我们要最小化所有这些移动次数的总和
4. 这个问题等价于在数轴上找一个点，使得到所有点的距离之和最小
5. 这个最优点就是中位数（可以通过数学证明）

#### 🛠️ 实现步骤
1. 对数组进行排序
2. 找到中位数（如果数组长度为奇数，就是中间的数；如果是偶数，取中间两个数中的任意一个）
3. 计算每个数到中位数的距离之和

#### 🧩 示例分析
以示例 1：nums = [1,2,3] 为例：

1. 排序后数组不变：[1,2,3]
2. 数组长度为 3，中位数是 nums[1] = 2
3. 计算移动次数：
   - 1 到 2 的距离：|1-2| = 1
   - 2 到 2 的距离：|2-2| = 0
   - 3 到 2 的距离：|3-2| = 1
4. 总移动次数：1 + 0 + 1 = 2

以示例 2：nums = [1,10,2,9] 为例：

1. 排序后：[1,2,9,10]
2. 数组长度为 4，取 nums[2] = 9 作为中位数
   （注：取 nums[1] = 2 也可以，结果是一样的）
3. 计算移动次数：
   - 1 到 9 的距离：|1-9| = 8
   - 2 到 9 的距离：|2-9| = 7
   - 9 到 9 的距离：|9-9| = 0
   - 10 到 9 的距离：|10-9| = 1
4. 总移动次数：8 + 7 + 0 + 1 = 16

---

## 数学证明

为什么中位数是最优解？我们可以通过反证法来证明：

假设最优解不是中位数，而是另一个数 x：
1. 如果 x 小于中位数，那么数组中有超过一半的数大于 x
2. 如果 x 大于中位数，那么数组中有超过一半的数小于 x
3. 在这两种情况下，我们都可以通过将 x 向中位数方向移动一步来减少总移动次数
4. 这与 x 是最优解矛盾

更严格的证明：
设数组长度为 n，排序后的数组为 a₁ ≤ a₂ ≤ ... ≤ aₙ，目标值为 x
总移动次数为：|a₁-x| + |a₂-x| + ... + |aₙ-x|
这个函数在 x = a⌊(n+1)/2⌋ 处取得最小值（即中位数处）

---

## 代码实现

完整的可运行代码：[L0462_MinimumMovesToEqualArrayElementsII.java](../src/main/java/L0462_MinimumMovesToEqualArrayElementsII.java)

```java
public int minMoves2(int[] nums) {
    // 对数组进行排序
    Arrays.sort(nums);
    
    // 找到中位数
    int median = nums[nums.length / 2];
    
    // 计算所有数字到中位数的距离之和
    int moves = 0;
    for (int num : nums) {
        moves += Math.abs(num - median);
    }
    
    return moves;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n log n)
  - 排序需要 O(n log n) 的时间
  - 遍历数组计算距离需要 O(n) 的时间
  - 总的时间复杂度由排序决定，为 O(n log n)

- **空间复杂度**：O(1)
  - 只使用了几个变量来存储中间结果
  - 如果使用原地排序算法，不需要额外的空间

---

## 优化思路

1. **快速选择优化**
   - 实际上我们只需要找到中位数，不需要对整个数组排序
   - 可以使用快速选择算法（Quick Select）在 O(n) 时间内找到中位数
   - 这样可以将时间复杂度优化到 O(n)

2. **处理溢出**
   - 在计算距离时要注意处理整数溢出的情况
   - 可以使用 long 类型来存储中间结果

3. **数学优化**
   - 如果数组长度为偶数，取中间两个数中的任意一个作为中位数都可以
   - 这是因为在这两个数之间的任何值都会得到相同的结果

---

## LeetCode 题解
     
本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。
     
<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 