---
title: 分数排名
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[分数排名](https://leetcode.cn/problems/rank-scores/)  
**🏷️ 标签**：`数据库`  
**🟡 难度**：`中等`  

表: Scores

```
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| score       | decimal |
+-------------+---------+
```

id 是该表的主键。
该表的每一行都包含了一场比赛的分数。Score 是一个有两位小数点的浮点值。

编写 SQL 查询对分数进行排序。排名按以下规则计算:
- 分数应按从高到低排序
- 如果两个分数相同，那么两个分数的排名应该相同
- 在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字

按 score 降序返回结果表。

查询结果格式如下所示。

示例 1：

输入：
Scores 表：
```
+----+-------+
| id | score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
```

输出：
```
+-------+------+
| score | rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
```

---

## 解题思路

### 窗口函数 DENSE_RANK()

#### 📝 核心思想
这道题考察的是 SQL 中的窗口函数（Window Function）的使用，特别是排名函数。我们需要使用 `DENSE_RANK()` 函数，因为它具有以下特点：
1. 按分数降序排序
2. 相同分数获得相同排名
3. 排名是连续的，没有空缺

SQL 中有三个常用的排名函数：
1. `ROW_NUMBER()`：生成连续的唯一排名，即使遇到相同的值也会生成不同的排名
2. `RANK()`：生成排名，相同的值获得相同的排名，但会产生空缺
3. `DENSE_RANK()`：生成排名，相同的值获得相同的排名，并且排名是连续的

#### 🛠️ 实现步骤
1. 使用 `SELECT` 选择需要的列：score 和排名
2. 使用 `DENSE_RANK()` 函数生成排名
3. 使用 `OVER` 子句指定排序方式
4. 使用 `ORDER BY score DESC` 实现降序排序

#### 🧩 示例分析
以示例数据为例，让我们看看不同排名函数的结果：

原始数据（按分数降序）：
```
score
-----
4.00
4.00
3.85
3.65
3.65
3.50
```

不同排名函数的结果对比：

| score | ROW_NUMBER() | RANK() | DENSE_RANK() |
|-------|-------------|--------|--------------|
| 4.00  | 1           | 1      | 1            |
| 4.00  | 2           | 1      | 1            |
| 3.85  | 3           | 3      | 2            |
| 3.65  | 4           | 4      | 3            |
| 3.65  | 5           | 4      | 3            |
| 3.50  | 6           | 6      | 4            |

从对比可以看出：
1. `ROW_NUMBER()` 生成连续的唯一排名，即使分数相同也会有不同的排名
2. `RANK()` 会在相同分数后产生空缺（1,1,3,4,4,6）
3. `DENSE_RANK()` 生成连续的排名，没有空缺（1,1,2,3,3,4）

根据题目要求，我们应该使用 `DENSE_RANK()`。

---

## 代码实现

完整的可运行代码：[L0178_RankScores.java](../src/main/java/L0178_RankScores.java)

```java
public String getSQL() {
    return "SELECT\n" +
           "  score,\n" +
           "  DENSE_RANK() OVER (ORDER BY score DESC) AS 'rank'\n" +
           "FROM Scores";
}
```

---

## 复杂度分析

- **时间复杂度**：O(n log n)，其中 n 是表中的记录数。这是由于需要对分数进行排序。
- **空间复杂度**：O(n)，需要存储排序后的结果。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 