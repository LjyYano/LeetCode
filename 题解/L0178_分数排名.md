---
title: 分数排名
date: 2024-02-10
---

## 题目描述

**🔗 题目**：[分数排名](https://leetcode.cn/problems/rank-scores/)  
**🏷️ 标签**：`数据库`  
**🟡 难度**：`中等`  

Scores 表：
```
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| score       | decimal |
+-------------+---------+
```
id 是该表的主键。  
该表的每一行都包含了一个分数。  

编写一个 SQL 查询，将分数按照降序排序，并返回排名。排名按以下规则计算：  
- 分数应按从高到低排序  
- 如果两个分数相同，那么两个分数的排名应该相同  
- 在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字  

返回按 score 降序排列的查询结果。  

查询结果格式如下所示。  

示例 1：  
输入：  
Scores 表：
```
+----+-------+
| id | score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
```
输出：
```
+-------+------+
| score | rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
```

---

## 解题思路

### DENSE_RANK 窗口函数

#### 📝 核心思想
要对分数进行排名，我们需要：
1. 按分数降序排序
2. 相同分数获得相同排名
3. 排名连续，不跳过数字

这正是 DENSE_RANK() 窗口函数的特点：
- 按照指定列排序
- 相同值获得相同排名
- 排名连续，不会跳过数字

#### 🛠️ 实现步骤
1. 使用 `DENSE_RANK() OVER (ORDER BY score DESC)` 对分数进行排名
2. 使用 `ORDER BY score DESC` 确保结果按分数降序排序

#### 🧩 示例分析
以示例数据为例，让我们看看查询是如何工作的：

1. 原始数据：
   ```
   +----+-------+
   | id | score |
   +----+-------+
   | 1  | 3.50  |
   | 2  | 3.65  |
   | 3  | 4.00  |
   | 4  | 3.85  |
   | 5  | 4.00  |
   | 6  | 3.65  |
   +----+-------+
   ```

2. 按分数降序排序：
   ```
   +----+-------+
   | id | score |
   +----+-------+
   | 3  | 4.00  |
   | 5  | 4.00  |
   | 4  | 3.85  |
   | 2  | 3.65  |
   | 6  | 3.65  |
   | 1  | 3.50  |
   +----+-------+
   ```

3. 使用 DENSE_RANK() 添加排名：
   ```
   +-------+------+
   | score | rank |
   +-------+------+
   | 4.00  | 1    | ← 相同分数，相同排名
   | 4.00  | 1    |
   | 3.85  | 2    | ← 排名连续，没有跳过
   | 3.65  | 3    | ← 相同分数，相同排名
   | 3.65  | 3    |
   | 3.50  | 4    | ← 排名连续，没有跳过
   +-------+------+
   ```

---

## 代码实现

完整的可运行代码：[L0178_RankScores.sql](../src/main/sql/L0178_RankScores.sql)

```sql
SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS rank
FROM Scores
```

---

## 复杂度分析

- **时间复杂度**：O(n log n)，其中 n 是 Scores 表的记录数
  - DENSE_RANK() 需要对数据进行排序，时间复杂度为 O(n log n)
  - 使用索引可以优化查找性能

- **空间复杂度**：O(n)
  - 需要存储带有排名的临时表
  - n 是 Scores 表的记录数

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 