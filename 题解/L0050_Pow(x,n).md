---
title: Pow(x, n)
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[Pow(x, n)](https://leetcode.cn/problems/powx-n/)  
**🏷️ 标签**：`递归` `数学`  
**🟡 难度**：`中等`  

实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，x^n ）。

示例 1：
```
输入：x = 2.00000, n = 10
输出：1024.00000
```

示例 2：
```
输入：x = 2.10000, n = 3
输出：9.26100
```

示例 3：
```
输入：x = 2.00000, n = -2
输出：0.25000
解释：2^-2 = 1/2^2 = 1/4 = 0.25
```

提示：
- -100.0 < x < 100.0
- -2³¹ <= n <= 2³¹-1
- n 是一个整数
- -10⁴ <= x^n <= 10⁴

---

## 解题思路
### 快速幂算法

#### 📝 核心思想
快速幂算法的核心思想是将指数 n 转换为二进制表示，利用二进制的性质来减少乘法运算的次数。例如，要计算 x¹⁰，我们可以将 10 转换为二进制 1010，那么：

x¹⁰ = x^(2³×1 + 2²×0 + 2¹×1 + 2⁰×0) = x⁸ × x²

这样，我们只需要进行 4 次乘法运算，而不是 9 次。

#### 🛠️ 实现步骤
1. 处理特殊情况：
   - 当 n = 0 时，返回 1
   - 当 x = 1 或 x = -1 时，需要特殊处理
   - 当 n = Integer.MIN_VALUE 时，需要特殊处理

2. 处理负数指数：
   - 如果 n < 0，将 x 变为 1/x，n 变为 -n
   - 注意处理 n = Integer.MIN_VALUE 的情况，因为 -n 会溢出

3. 使用快速幂计算：
   - 初始化结果 result = 1
   - 当 n > 0 时：
     - 如果 n 的二进制最低位为 1，将当前的 x 累乘到结果中
     - 将 x 自乘，准备下一位的计算
     - 将 n 右移一位

#### 🧩 示例分析
以计算 2¹⁰ 为例，演示快速幂算法的执行过程：

| 步骤 | n 的二进制 | n & 1 | result | x | 说明 |
|-----|-----------|--------|--------|---|-----|
| 初始 | 1010 | 0 | 1 | 2 | 初始状态 |
| 1 | 1010 | 0 | 1 | 4 | n 最低位为 0，只更新 x |
| 2 | 101 | 1 | 4 | 16 | n 最低位为 1，result *= x |
| 3 | 10 | 0 | 4 | 256 | n 最低位为 0，只更新 x |
| 4 | 1 | 1 | 1024 | 65536 | n 最低位为 1，result *= x |
| 5 | 0 | - | 1024 | - | 计算完成 |

---

## 代码实现

完整的可运行代码：[L0050_PowxN.java](../src/main/java/L0050_PowxN.java)

```java
public double myPow(double x, int n) {
    // 处理特殊情况
    if (n == 0) {
        return 1.0;
    }
    if (x == 1.0) {
        return 1.0;
    }
    if (x == -1.0) {
        return n % 2 == 0 ? 1.0 : -1.0;
    }

    // 处理 n 为最小值的情况
    if (n == Integer.MIN_VALUE) {
        return Math.abs(x) < 1.0 ? Double.POSITIVE_INFINITY : 0.0;
    }

    // 处理负数指数的情况
    if (n < 0) {
        x = 1 / x;
        n = -n;
    }

    // 快速幂算法
    double result = 1.0;
    while (n > 0) {
        // 如果当前二进制位为 1，将当前 x 累乘到结果中
        if ((n & 1) == 1) {
            result *= x;
        }
        // x 自乘，准备下一位的计算
        x *= x;
        // n 右移一位
        n >>= 1;
    }
    return result;
}
```

---

## 复杂度分析

- **时间复杂度**：O(log n)。我们需要对 n 的二进制位进行遍历，而 n 的二进制位数为 log n。
- **空间复杂度**：O(1)。我们只需要常数个变量来存储中间结果。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 