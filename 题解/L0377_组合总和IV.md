---
title: 组合总和 IV
date: 2024-02-11
---

## 题目描述

**🔗 题目**：[组合总和 IV](https://leetcode.cn/problems/combination-sum-iv/)  
**🏷️ 标签**：`数组` `动态规划`  
**🟡 难度**：`中等`  

给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**示例 1：**
```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

**示例 2：**
```
输入：nums = [9], target = 3
输出：0
```

**提示：**
- 1 <= nums.length <= 200
- 1 <= nums[i] <= 1000
- nums 中的所有元素 互不相同
- 1 <= target <= 1000

**进阶：**如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？

---

## 解题思路

### 动态规划

#### 📝 核心思想
这道题的关键在于理解它与普通的组合总和问题的区别：这里要求考虑元素的顺序。例如 `[1,2]` 和 `[2,1]` 被视为不同的组合。这个特点使得我们可以使用动态规划来解决问题。

我们定义 `dp[i]` 表示目标数为 i 的组合个数。对于每个目标数 i，我们可以通过在已有的组合后面添加一个数字来得到新的组合。

#### 🛠️ 实现步骤
1. 创建动态规划数组 `dp`，长度为 `target + 1`
2. 初始化 `dp[0] = 1`，表示空集的组合数为 1
3. 对于每个目标数 i（从 1 到 target）：
   - 遍历数组 nums 中的每个数字 num
   - 如果 i >= num，说明可以使用这个数字
   - 更新 dp[i] += dp[i - num]

#### 🧩 示例分析
以 nums = [1,2,3], target = 4 为例：

| 目标数 i | dp[i] | 计算过程 |
|---------|-------|---------|
| 0 | 1 | 初始化 |
| 1 | 1 | dp[1] = dp[0] (使用 1) |
| 2 | 2 | dp[2] = dp[1] (使用 1) + dp[0] (使用 2) |
| 3 | 4 | dp[3] = dp[2] (使用 1) + dp[1] (使用 2) + dp[0] (使用 3) |
| 4 | 7 | dp[4] = dp[3] (使用 1) + dp[2] (使用 2) + dp[1] (使用 3) |

对于 i = 4 的情况：
- 使用 1：可以在所有和为 3 的组合后面加上 1，有 dp[3] = 4 种
- 使用 2：可以在所有和为 2 的组合后面加上 2，有 dp[2] = 2 种
- 使用 3：可以在所有和为 1 的组合后面加上 3，有 dp[1] = 1 种
- 总共：4 + 2 + 1 = 7 种组合

---

## 代码实现

完整的可运行代码：[L0377_CombinationSumIV.java](../src/main/java/L0377_CombinationSumIV.java)

```java
public int combinationSum4(int[] nums, int target) {
    // dp[i] 表示目标数为 i 的组合个数
    int[] dp = new int[target + 1];
    // 初始化：空集的组合数为 1
    dp[0] = 1;
    
    // 遍历所有目标数
    for (int i = 1; i <= target; i++) {
        // 遍历所有可用的数字
        for (int num : nums) {
            // 如果当前数字小于等于目标数，则可以使用
            if (i >= num) {
                dp[i] += dp[i - num];
            }
        }
    }
    
    return dp[target];
}
```

---

## 复杂度分析

- **时间复杂度**：O(target × n)，其中 n 是数组 nums 的长度。我们需要计算每个从 1 到 target 的目标数的组合个数，对于每个目标数，我们都需要遍历一遍 nums 数组。
- **空间复杂度**：O(target)，用于存储动态规划数组。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 