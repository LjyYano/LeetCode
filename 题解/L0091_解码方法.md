---
title: 解码方法
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[解码方法](https://leetcode.cn/problems/decode-ways/)  
**🏷️ 标签**：`字符串` `动态规划`  
**🟡 难度**：`中等`  

一条包含字母 A-Z 的消息通过以下映射进行了编码：
```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
- "AAJF" ，将消息分组为 (1 1 10 6)
- "KJF" ，将消息分组为 (11 10 6)

注意，消息不能分组为 (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。题目数据保证答案肯定是一个 32 位 的整数。

示例 1：
```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

示例 2：
```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ"（2 26）, "VF"（22 6）, 或者 "BBF"（2 2 6）。
```

示例 3：
```
输入：s = "06"
输出：0
解释："06" 无法映射到 "F" ，因为存在前导零（"6" 和 "06" 并不等价）。
```

提示：
- 1 <= s.length <= 100
- s 只包含数字，并且可能包含前导零。

---

## 解题思路
### 动态规划

#### 📝 核心思想
本题可以使用动态规划来解决。对于每个位置，我们需要考虑两种可能的解码方式：
1. 单独解码当前数字（如果当前数字不是 0）
2. 将当前数字和前一个数字一起解码（如果这两个数字组成的数在 10-26 之间）

关键点是：
1. 处理前导零和无效的两位数
2. 正确累加不同解码方式的数量

#### 🛠️ 实现步骤
1. 处理边界情况：
   - 空字符串或首字符为 0 时，返回 0
   - 初始化 dp 数组，dp[i] 表示前 i 个字符的解码方法总数

2. 初始化基础状态：
   - dp[0] = 1（空字符串）
   - dp[1] 根据第一个字符是否为 0 设置为 0 或 1

3. 动态规划过程：
   - 遍历字符串的每个位置
   - 考虑单个字符解码的情况
   - 考虑两个字符一起解码的情况
   - 累加有效的解码方式数量

#### 🧩 示例分析
以示例 2 为例，分析整个过程：
```
输入：s = "226"
```

动态规划过程表格说明：

| 位置 i | 字符 | 单字符解码 | 双字符解码 | dp[i] | 说明 |
|-------|-----|-----------|-----------|-------|------|
| 0 | - | - | - | 1 | 空字符串 |
| 1 | '2' | 1 | - | 1 | 可以解码为 'B' |
| 2 | '2' | 1 | 1 | 2 | 可以解码为 'BB' 或 'V' |
| 3 | '6' | 2 | 1 | 3 | 可以解码为 'BBF', 'VF', 或 'BZ' |

详细分析：
1. 初始状态：
   ```
   dp[0] = 1 (空字符串)
   dp[1] = 1 ('2' 可以解码为 'B')
   ```

2. 处理第二个字符 '2'：
   ```
   单字符：'2' 可以解码为 'B'，继承 dp[1] 的解码方式数
   双字符：'22' 可以解码为 'V'，继承 dp[0] 的解码方式数
   dp[2] = dp[1] + dp[0] = 1 + 1 = 2
   ```

3. 处理第三个字符 '6'：
   ```
   单字符：'6' 可以解码为 'F'，继承 dp[2] 的解码方式数
   双字符：'26' 可以解码为 'Z'，继承 dp[1] 的解码方式数
   dp[3] = dp[2] + dp[1] = 2 + 1 = 3
   ```

---

## 代码实现

完整的可运行代码：[L0091_DecodeWays.java](../src/main/java/L0091_DecodeWays.java)

```java
public int numDecodings(String s) {
    if (s == null || s.length() == 0 || s.charAt(0) == '0') {
        return 0;
    }
    
    int n = s.length();
    // dp[i] 表示前 i 个字符的解码方法总数
    int[] dp = new int[n + 1];
    // 空字符串可以有 1 种解码方法
    dp[0] = 1;
    // 第一个字符如果不是 0，则有 1 种解码方法
    dp[1] = s.charAt(0) == '0' ? 0 : 1;
    
    // 从第二个字符开始动态规划
    for (int i = 2; i <= n; i++) {
        // 当前字符对应的数字
        int oneDigit = s.charAt(i - 1) - '0';
        // 当前字符和前一个字符组成的两位数
        int twoDigits = (s.charAt(i - 2) - '0') * 10 + oneDigit;
        
        // 如果当前字符可以单独解码（1-9）
        if (oneDigit >= 1) {
            dp[i] += dp[i - 1];
        }
        
        // 如果当前字符和前一个字符可以一起解码（10-26）
        if (twoDigits >= 10 && twoDigits <= 26) {
            dp[i] += dp[i - 2];
        }
    }
    
    return dp[n];
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)
  - 需要遍历字符串一次
  - 每个位置的计算是常数时间
  - n 是字符串的长度

- **空间复杂度**：O(n)
  - 需要一个长度为 n+1 的 dp 数组
  - 可以优化为 O(1)，因为每次只需要前两个状态

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 