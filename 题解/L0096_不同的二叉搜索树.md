---
title: 不同的二叉搜索树
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)  
**🏷️ 标签**：`树` `二叉搜索树` `数学` `动态规划` `二叉树`  
**🟡 难度**：`中等`  

给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

示例 1：
![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)
```
输入：n = 3
输出：5
```

示例 2：
```
输入：n = 1
输出：1
```

提示：
- 1 <= n <= 19

---

## 解题思路
### 动态规划

#### 📝 核心思想
本题可以使用动态规划来解决。关键是找到状态转移方程。对于一个长度为 n 的序列 [1,n]，我们可以遍历每个数字 i，将其作为根节点，此时：

1. 左子树由序列 [1,i-1] 构成，长度为 i-1
2. 右子树由序列 [i+1,n] 构成，长度为 n-i
3. 根据乘法原理，以 i 为根的二叉搜索树数量 = 左子树数量 × 右子树数量

关键点是：
1. 二叉搜索树的数量只与节点个数有关，与具体的节点值无关
2. 可以使用动态规划数组 dp[i] 表示 i 个节点能构成的二叉搜索树数量
3. 状态转移方程：dp[i] = sum(dp[j-1] * dp[i-j]) for j in [1,i]

#### 🛠️ 实现步骤
1. 初始化动态规划数组：
   - dp[0] = 1（空树是一种特殊情况）
   - dp[1] = 1（一个节点只有一种情况）

2. 从小到大计算每个规模的解：
   - 对于每个 i（2 到 n）
   - 遍历每个可能的根节点 j（1 到 i）
   - 计算 dp[i] += dp[j-1] * dp[i-j]

3. 最终返回 dp[n]

#### 🧩 示例分析
以 n = 3 为例，分析计算过程：

| i | j | 左子树节点数 | 右子树节点数 | 计算过程 | dp[i] |
|---|---|------------|-------------|----------|--------|
| 0 | - | - | - | 初始化 | 1 |
| 1 | - | - | - | 初始化 | 1 |
| 2 | 1 | 0 | 1 | dp[2] += dp[0] * dp[1] = 1 | 1 |
| 2 | 2 | 1 | 0 | dp[2] += dp[1] * dp[0] = 1 | 2 |
| 3 | 1 | 0 | 2 | dp[3] += dp[0] * dp[2] = 2 | 2 |
| 3 | 2 | 1 | 1 | dp[3] += dp[1] * dp[1] = 1 | 3 |
| 3 | 3 | 2 | 0 | dp[3] += dp[2] * dp[0] = 2 | 5 |

详细分析 n = 3 的情况：
```
1. 初始状态：
   dp[0] = 1（空树）
   dp[1] = 1（单节点树）

2. 计算 dp[2]：
   - j = 1：根节点为 1，左子树 0 个节点，右子树 1 个节点
     dp[2] += dp[0] * dp[1] = 1 * 1 = 1
   - j = 2：根节点为 2，左子树 1 个节点，右子树 0 个节点
     dp[2] += dp[1] * dp[0] = 1 * 1 = 1
   所以 dp[2] = 2

3. 计算 dp[3]：
   - j = 1：根节点为 1，左子树 0 个节点，右子树 2 个节点
     dp[3] += dp[0] * dp[2] = 1 * 2 = 2
   - j = 2：根节点为 2，左子树 1 个节点，右子树 1 个节点
     dp[3] += dp[1] * dp[1] = 1 * 1 = 1
   - j = 3：根节点为 3，左子树 2 个节点，右子树 0 个节点
     dp[3] += dp[2] * dp[0] = 2 * 1 = 2
   所以 dp[3] = 5
```

---

## 代码实现

完整的可运行代码：[L0096_UniqueBinarySearchTrees.java](../src/main/java/L0096_UniqueBinarySearchTrees.java)

```java
public int numTrees(int n) {
    // dp[i] 表示由 i 个节点组成的不同二叉搜索树的数量
    int[] dp = new int[n + 1];
    
    // 初始化边界条件
    dp[0] = 1; // 空树也是一种情况
    dp[1] = 1; // 只有一个节点的情况
    
    // 从 2 到 n 依次计算每个规模的解
    for (int i = 2; i <= n; i++) {
        // 对于每个规模 i，考虑每个节点作为根节点的情况
        for (int j = 1; j <= i; j++) {
            // 左子树节点数为 j-1，右子树节点数为 i-j
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }
    
    return dp[n];
}
```

---

## 复杂度分析

- **时间复杂度**：O(n²)
  - 需要计算从 2 到 n 的每个数的二叉搜索树数量
  - 对于每个数 i，需要遍历从 1 到 i 的所有可能根节点
  - 总的时间复杂度为 O(n²)

- **空间复杂度**：O(n)
  - 需要一个长度为 n+1 的数组来存储动态规划的中间结果
  - 除此之外不需要额外的空间

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 