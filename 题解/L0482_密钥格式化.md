---
title: 密钥格式化
date: 2024-02-12
---

## 题目描述

**🔗 题目**：[482. 密钥格式化](https://leetcode.cn/problems/license-key-formatting/)  
**🏷️ 标签**：`字符串`  
**🟢 难度**：`简单`  

给定一个许可密钥字符串 `s`，仅由字母、数字字符和破折号组成。字符串由 `n` 个破折号分隔成 `n + 1` 组。你也会得到一个整数 `k`。

我们想要重新格式化字符串 `s`，使每一组包含 `k` 个字符，除了第一组，它可以比 `k` 短，但仍然必须包含至少一个字符。此外，两组之间必须插入破折号，并且应该将所有小写字母转换为大写字母。

返回 重新格式化的许可密钥 。

**示例 1：**
```
输入：s = "5F3Z-2e-9-w", k = 4
输出："5F3Z-2E9W"
解释：字符串 s 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。
```

**示例 2：**
```
输入：s = "2-5g-3-J", k = 2
输出："2-5G-3J"
解释：字符串 s 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
```

**提示：**
- `1 <= s.length <= 10^5`
- `s` 只包含字母、数字和破折号 `'-'`
- `1 <= k <= 10^4`

---

## 解题思路

### 逆向构造法

#### 📝 核心思想
从字符串末尾开始构造结果，这样可以保证每组（除第一组外）都恰好有 k 个字符。第一组会自然地包含剩余的字符。

#### 🛠️ 实现步骤
1. 先移除所有破折号，并将所有字母转为大写
2. 从后往前遍历处理后的字符串
3. 每 k 个字符插入一个破折号
4. 最后反转结果字符串

#### 🧩 示例分析
以示例 1 为例：`s = "5F3Z-2e-9-w", k = 4`

```
1. 移除破折号并转大写：5F3Z2E9W (长度8)
2. 从后往前每4个字符分组：
   - 5F3Z | 2E9W
3. 插入破折号：5F3Z-2E9W
```

以示例 2 为例：`s = "2-5g-3-J", k = 2`

```
1. 移除破折号并转大写：25G3J (长度5)
2. 从后往前每2个字符分组：
   - 2 | 5G | 3J
   第一组只有1个字符
3. 插入破折号：2-5G-3J
```

---

## 代码实现

```java
public class L0482_LicenseKeyFormatting {
    public String licenseKeyFormatting(String s, int k) {
        // 移除破折号并转为大写
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (c != '-') {
                sb.append(Character.toUpperCase(c));
            }
        }
        
        // 如果没有有效字符，返回空字符串
        if (sb.length() == 0) {
            return "";
        }
        
        // 从后往前构造结果
        StringBuilder result = new StringBuilder();
        int count = 0;
        
        for (int i = sb.length() - 1; i >= 0; i--) {
            if (count == k) {
                result.append('-');
                count = 0;
            }
            result.append(sb.charAt(i));
            count++;
        }
        
        // 反转结果
        return result.reverse().toString();
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是字符串 s 的长度。需要遍历字符串两次。
- **空间复杂度**：O(n)，需要额外的空间存储处理后的字符串和结果。

---

## 相关题目

- [🔗 443. 压缩字符串](https://leetcode.cn/problems/string-compression/)
- [🔗 68. 文本左右对齐](https://leetcode.cn/problems/text-justification/)

---

## 总结

这道题是字符串处理的简单题目。解题的关键在于：
1. 从后往前构造可以确保每组（除第一组外）都有 k 个字符
2. 注意处理边界情况（如字符串为空或只有破折号）
3. 记得转换大小写

通过这道题，我们可以学习到：
1. 逆向思维在字符串处理中的应用
2. StringBuilder 的高效使用
3. 字符串格式化的技巧

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 