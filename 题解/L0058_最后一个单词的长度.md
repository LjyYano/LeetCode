---
title: 最后一个单词的长度
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[最后一个单词的长度](https://leetcode.cn/problems/length-of-last-word/)  
**🏷️ 标签**：`字符串`  
**🟢 难度**：`简单`  

给你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。

单词是指仅由字母组成、不包含任何空格字符的最大子字符串。

**示例 1：**
```
输入：s = "Hello World"
输出：5
解释：最后一个单词是"World"，长度为5。
```

**示例 2：**
```
输入：s = "   fly me   to   the moon  "
输出：4
解释：最后一个单词是"moon"，长度为4。
```

**示例 3：**
```
输入：s = "luffy is still joyboy"
输出：6
解释：最后一个单词是长度为6的"joyboy"。
```

**提示：**
- `1 <= s.length <= 10⁴`
- `s` 仅有英文字母和空格 `' '` 组成
- `s` 中至少存在一个单词

---

## 解题思路

### 从后向前遍历

#### 📝 核心思想
从字符串末尾开始向前遍历，先跳过末尾的空格，然后计算最后一个单词的长度。这种方法不需要处理整个字符串，只需要关注最后一个单词。

#### 🛠️ 实现步骤
1. 特殊情况处理：
   - 如果字符串为空或长度为0，返回0
2. 从字符串末尾开始遍历：
   - 跳过末尾的空格
   - 统计最后一个单词的长度
3. 返回统计的长度

#### 🧩 示例分析
以输入 `s = "   fly me   to   the moon  "` 为例：

| 步骤 | 当前位置 | 当前字符 | 操作 | 长度 | 说明 |
|-----|---------|---------|------|------|------|
| 初始状态 | 25 | ' ' | - | 0 | 从末尾开始 |
| 跳过空格 | 24 | ' ' | 跳过 | 0 | 继续跳过空格 |
| 跳过空格 | 23 | ' ' | 跳过 | 0 | 继续跳过空格 |
| 遇到字母 | 22 | 'n' | 计数 | 1 | 开始计算长度 |
| 继续 | 21 | 'o' | 计数 | 2 | 继续计算 |
| 继续 | 20 | 'o' | 计数 | 3 | 继续计算 |
| 继续 | 19 | 'm' | 计数 | 4 | 继续计算 |
| 遇到空格 | 18 | ' ' | 结束 | 4 | 遇到空格，结束计算 |

**详细分析**：
1. 从字符串末尾（位置25）开始向前遍历
2. 先跳过末尾的空格字符（位置25-23）
3. 遇到字母 'n'，开始计数
4. 继续向前遍历，依次遇到 'o'、'o'、'm'，计数增加
5. 遇到空格字符，结束计数
6. 返回最后一个单词 "moon" 的长度 4

### 其他可能的解法

1. **从前向后遍历**：
   - 遍历整个字符串，记录每个单词的长度
   - 最后返回最后一个单词的长度
   - 这种方法需要处理整个字符串，效率较低

2. **使用 split 方法**：
   ```java
   return s.trim().split(" ")[s.trim().split(" ").length-1].length();
   ```
   - 简单但效率不高，需要处理整个字符串
   - 额外使用了空间来存储分割后的数组

3. **使用正则表达式**：
   ```java
   return s.trim().replaceAll(".*\\s+", "").length();
   ```
   - 代码简洁但性能较差
   - 正则表达式的匹配和替换操作开销较大

---

## 代码实现

完整的可运行代码：[L0058_LengthOfLastWord.java](../src/main/java/L0058_LengthOfLastWord.java)

```java
public int lengthOfLastWord(String s) {
    // 特殊情况处理
    if (s == null || s.length() == 0) {
        return 0;
    }
    
    // 从字符串末尾开始遍历
    int length = 0;
    int i = s.length() - 1;
    
    // 跳过末尾的空格
    while (i >= 0 && s.charAt(i) == ' ') {
        i--;
    }
    
    // 计算最后一个单词的长度
    while (i >= 0 && s.charAt(i) != ' ') {
        length++;
        i--;
    }
    
    return length;
}
```

---

## 复杂度分析

- **时间复杂度**：`O(n)`，其中 n 是字符串的长度。最坏情况下需要遍历整个字符串（当字符串全是空格时）。
- **空间复杂度**：`O(1)`，只使用了常数个变量来存储长度和索引。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 