---
title: 买卖股票的最佳时机 III
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)  
**🏷️ 标签**：`数组` `动态规划`  
**🔴 难度**：`困难`  

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:
```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

示例 2：
```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

示例 3：
```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

示例 4：
```
输入：prices = [1]
输出：0
```

提示：
- 1 <= prices.length <= 10⁵
- 0 <= prices[i] <= 10⁵

---

## 解题思路
### 动态规划

#### 📝 核心思想
这道题是"买卖股票的最佳时机"系列中的一道难题，限制最多只能进行两次交易。我们可以使用动态规划来解决这个问题。关键是设计好状态定义和状态转移方程。

状态定义：
- dp[i][k][0] 表示第 i 天，最多进行 k 次交易，手上没有股票的最大利润
- dp[i][k][1] 表示第 i 天，最多进行 k 次交易，手上持有股票的最大利润

状态转移方程：
- dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
  - 前一天也没有股票：dp[i-1][k][0]
  - 前一天有股票，今天卖出：dp[i-1][k][1] + prices[i]
- dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
  - 前一天也有股票：dp[i-1][k][1]
  - 前一天没有股票，今天买入：dp[i-1][k-1][0] - prices[i]

#### 🛠️ 实现步骤
1. 处理特殊情况：
   - 如果数组为空或长度小于等于 1，返回 0

2. 初始化状态数组：
   - 创建三维数组 dp[n][3][2]
   - 初始化第一天的状态：
     * dp[0][1][0] = 0（第一天，最多进行 1 次交易，不持有股票）
     * dp[0][1][1] = -prices[0]（第一天，最多进行 1 次交易，持有股票）
     * dp[0][2][0] = 0（第一天，最多进行 2 次交易，不持有股票）
     * dp[0][2][1] = -prices[0]（第一天，最多进行 2 次交易，持有股票）

3. 动态规划过程：
   - 遍历每一天
   - 对于每一天，分别计算第一次和第二次交易的状态
   - 使用状态转移方程更新状态

4. 返回最终结果：
   - 返回 dp[n-1][2][0]，表示最后一天，最多进行两次交易，不持有股票的最大利润

#### 🧩 示例分析
以示例 1 为例，分析整个过程：
```
输入：prices = [3,3,5,0,0,3,1,4]
```

我们来看一下状态变化的过程：

| 天数 | 价格 | 第一次交易不持有 | 第一次交易持有 | 第二次交易不持有 | 第二次交易持有 | 说明 |
|-----|------|----------------|--------------|----------------|--------------|------|
| 0 | 3 | 0 | -3 | 0 | -3 | 初始状态 |
| 1 | 3 | 0 | -3 | 0 | -3 | 价格相同，状态不变 |
| 2 | 5 | 2 | -3 | 2 | -3 | 可以卖出获利 |
| 3 | 0 | 2 | 0 | 2 | 0 | 低价买入 |
| 4 | 0 | 2 | 0 | 2 | 0 | 价格相同，状态不变 |
| 5 | 3 | 3 | 0 | 5 | 0 | 第一次和第二次交易都可能获利 |
| 6 | 1 | 3 | 0 | 5 | 2 | 为第二次交易买入 |
| 7 | 4 | 3 | 0 | 6 | 2 | 完成第二次交易，获得最大利润 |

最终的最大利润是 6，对应的交易方式是：
1. 第一次交易：在价格为 0 时买入，在价格为 3 时卖出，获利 3
2. 第二次交易：在价格为 1 时买入，在价格为 4 时卖出，获利 3
总利润 = 3 + 3 = 6

---

## 代码实现

完整的可运行代码：[L0123_BestTimeToBuyAndSellStockIII.java](../src/main/java/L0123_BestTimeToBuyAndSellStockIII.java)

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length <= 1) {
        return 0;
    }

    int n = prices.length;
    // 由于最多进行 2 次交易，所以 k = 2
    int[][][] dp = new int[n][3][2];

    // 初始化第一天的状态
    dp[0][1][0] = 0;
    dp[0][1][1] = -prices[0];
    dp[0][2][0] = 0;
    dp[0][2][1] = -prices[0];

    // 动态规划过程
    for (int i = 1; i < n; i++) {
        // 第一次交易
        dp[i][1][0] = Math.max(dp[i - 1][1][0], dp[i - 1][1][1] + prices[i]);
        dp[i][1][1] = Math.max(dp[i - 1][1][1], -prices[i]);
        // 第二次交易
        dp[i][2][0] = Math.max(dp[i - 1][2][0], dp[i - 1][2][1] + prices[i]);
        dp[i][2][1] = Math.max(dp[i - 1][2][1], dp[i - 1][1][0] - prices[i]);
    }

    // 最终结果是最多进行两次交易，且手上没有股票的情况
    return dp[n - 1][2][0];
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)
  - 需要遍历一次数组，其中 n 是数组的长度
  - 每个位置的状态转移是常数时间的操作

- **空间复杂度**：O(n)
  - 需要一个三维数组来存储状态
  - 数组大小是 n×3×2，其中 n 是数组的长度
  - 可以优化为 O(1) 空间复杂度，因为每个状态只依赖于前一天的状态

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 