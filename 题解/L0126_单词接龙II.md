# 126. 单词接龙 II

## 题目

给你两个单词 beginWord 和 endWord ，以及一个字典 wordList 。请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表。每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回。

每对相邻的单词之间仅有单个字母不同。
转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词。
sk == endWord

## 解题思路

这是一道比较复杂的图搜索问题，需要找到所有最短路径。我们可以分两步解决：

1. 使用 BFS 找到从 beginWord 到 endWord 的最短路径长度，同时记录每个节点的前驱节点。
2. 使用 DFS 根据前驱节点信息构建所有最短路径。

### 具体步骤

1. BFS 部分：
   - 使用队列进行广度优先搜索
   - 记录每个单词的层次（steps）
   - 记录每个单词可以从哪些单词转换而来（from）
   - 对于当前单词，尝试修改每个位置的字母，看是否能得到字典中的新单词
   - 如果找到 endWord，标记 found 为 true，并在当前层结束后停止 BFS

2. DFS 部分：
   - 从 beginWord 开始，根据 from 记录的信息进行深度优先搜索
   - 使用 path 记录当前路径
   - 当到达 endWord 时，将当前路径加入结果集
   - 回溯时需要移除最后添加的单词

### 复杂度分析

- 时间复杂度：O(N * 26 * L)，其中 N 是单词表中单词的个数，L 是单词的长度。
- 空间复杂度：O(N)，主要是存储 from 和 steps 的空间。

## 代码实现

```java
class Solution {
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        // 结果集
        List<List<String>> res = new ArrayList<>();
        // 字典集合
        Set<String> dict = new HashSet<>(wordList);
        // 如果字典中不包含目标单词，则无法转换
        if (!dict.contains(endWord)) {
            return res;
        }
        dict.remove(beginWord);
        
        // 第一步：使用 BFS 得到每个单词的层次
        Map<String, Integer> steps = new HashMap<>();
        steps.put(beginWord, 0);
        Map<String, Set<String>> from = new HashMap<>();
        boolean found = bfs(beginWord, endWord, dict, steps, from);
        
        if (found) {
            // 第二步：基于 BFS 结果，使用 DFS 构造路径
            Deque<String> path = new ArrayDeque<>();
            path.add(beginWord);
            dfs(beginWord, endWord, from, path, res);
        }
        
        return res;
    }
    
    private boolean bfs(String beginWord, String endWord, Set<String> dict, 
                       Map<String, Integer> steps, Map<String, Set<String>> from) {
        int wordLen = beginWord.length();
        int step = 0;
        boolean found = false;
        
        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);
        while (!queue.isEmpty()) {
            step++;
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                String currWord = queue.poll();
                char[] charArray = currWord.toCharArray();
                
                for (int j = 0; j < wordLen; j++) {
                    char origin = charArray[j];
                    for (char c = 'a'; c <= 'z'; c++) {
                        charArray[j] = c;
                        String nextWord = String.valueOf(charArray);
                        if (steps.containsKey(nextWord) && step == steps.get(nextWord)) {
                            from.get(nextWord).add(currWord);
                        }
                        
                        if (!dict.contains(nextWord)) {
                            continue;
                        }
                        
                        dict.remove(nextWord);
                        queue.offer(nextWord);
                        from.putIfAbsent(nextWord, new HashSet<>());
                        from.get(nextWord).add(currWord);
                        steps.put(nextWord, step);
                        
                        if (nextWord.equals(endWord)) {
                            found = true;
                        }
                    }
                    charArray[j] = origin;
                }
            }
            if (found) {
                break;
            }
        }
        return found;
    }
    
    private void dfs(String currWord, String endWord, Map<String, Set<String>> from,
                    Deque<String> path, List<List<String>> res) {
        if (currWord.equals(endWord)) {
            res.add(new ArrayList<>(path));
            return;
        }
        
        if (!from.containsKey(currWord)) {
            return;
        }
        
        for (String nextWord : from.get(currWord)) {
            path.addLast(nextWord);
            dfs(nextWord, endWord, from, path, res);
            path.removeLast();
        }
    }
}
```

## 示例分析

以示例 1 为例：
```
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
```

1. BFS 过程：
   - 第 1 层：hit -> hot
   - 第 2 层：hot -> (dot, lot)
   - 第 3 层：dot -> dog, lot -> log
   - 第 4 层：dog -> cog, log -> cog

2. DFS 过程：
   - 从 hit 开始，通过 from 记录的信息，可以找到两条路径：
     - hit -> hot -> dot -> dog -> cog
     - hit -> hot -> lot -> log -> cog

这样就找到了所有的最短转换序列。 