
- [题目描述](#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0)
- [解题思路](#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF)
    - [哈希表法](#%E5%93%88%E5%B8%8C%E8%A1%A8%E6%B3%95)
- [代码实现](#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
- [复杂度分析](#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)

# 题目描述

- **题目**：<kbd>两数之和</kbd>
- **题目链接**：https://leetcode.cn/problems/two-sum/description/
- **相关标签**：<kbd>数组</kbd>、<kbd>哈希表</kbd>
- **难度**：<kbd>简单</kbd>

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** `target` 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

# 解题思路

## 哈希表法
1. **核心思想**：通过哈希表存储遍历过的数字及其索引，实现快速查找补数
2. **具体步骤**：
   - 创建哈希表 `numMap` 存储数字到索引的映射
   - 遍历数组，对每个元素 `nums[i]`：
     - 计算补数 `complement = target - nums[i]`
     - 如果补数存在于哈希表中，直接返回 `[numMap.get(complement), i]`
     - 否则将当前数字和索引存入哈希表
3. **示例分析**：
   以 `nums = [2,7,11,15]`, `target = 9` 为例：
   - i=0时，补数=7，不在哈希表，存入2→0
   - i=1时，补数=2，已存在哈希表，返回[0,1]

# 代码实现

可运行调试的代码，参考 [L0000_Template.java](../src/main/java/L0000_Template.java)

```java
class Solution {
    public static int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> numMap = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (numMap.containsKey(complement)) {
                return new int[] { numMap.get(complement), i };
            }
            numMap.put(nums[i], i);
        }
        throw new IllegalArgumentException("No solution");
    }
}
```

# 复杂度分析
- **时间复杂度**：O(n)，只需遍历数组一次
- **空间复杂度**：O(n)，最坏情况下需要存储所有元素的哈希映射