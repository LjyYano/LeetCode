---
title: 生命游戏
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[生命游戏](https://leetcode.cn/problems/game-of-life/)  
**🏷️ 标签**：`数组` `矩阵` `模拟`  
**🟡 难度**：`中等`  

根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；

下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/26/grid1.jpg)

```
输入：board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
输出：[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/26/grid2.jpg)

```
输入：board = [[1,1],[1,0]]
输出：[[1,1],[1,1]]
```

**提示：**
- m == board.length
- n == board[i].length
- 1 <= m, n <= 25
- board[i][j] 为 0 或 1

---

## 解题思路
### 原地修改的状态机解法

#### 📝 核心思想
这道题的关键在于如何在不使用额外空间的情况下，同时更新所有细胞的状态。由于每个细胞的下一个状态依赖于其邻居的当前状态，如果我们直接修改细胞的状态，会影响到其他细胞的状态判断。

解决方案是使用状态机的思想，用不同的数字表示细胞状态的变化：
- 0：死细胞保持死亡
- 1：活细胞保持存活
- 2：活细胞变为死细胞
- 3：死细胞变为活细胞

这样，我们可以通过检查一个细胞的状态是 1 还是 2 来判断它在当前轮次是否是活细胞。

#### 🛠️ 实现步骤
1. 定义八个方向的偏移量数组，用于访问细胞的邻居
2. 遍历矩阵中的每个细胞：
   - 统计周围活细胞的数量
   - 根据规则更新状态：
     * 活细胞死亡：状态从 1 变为 2
     * 死细胞复活：状态从 0 变为 3
3. 再次遍历矩阵，将所有状态对 2 取模，得到最终状态：
   - 2 (活→死) % 2 = 0（死）
   - 3 (死→活) % 2 = 1（活）

#### 🧩 示例分析
以示例 1 为例，分析整个过程：

初始状态：
```
0 1 0
0 0 1
1 1 1
0 0 0
```

1. 第一轮遍历，标记状态变化：
   ```
   第一行：[0, 2, 0]   // 中间的 1 变为 2（死亡）
   第二行：[3, 0, 2]   // 左边的 0 变为 3（复活），右边的 1 变为 2（死亡）
   第三行：[0, 2, 2]   // 中间和右边的 1 变为 2（死亡）
   第四行：[0, 3, 0]   // 中间的 0 变为 3（复活）
   ```

2. 第二轮遍历，对 2 取模：
   ```
   [0, 0, 0]   // 2 % 2 = 0
   [1, 0, 0]   // 3 % 2 = 1
   [0, 0, 0]   // 2 % 2 = 0
   [0, 1, 0]   // 3 % 2 = 1
   ```

最终状态：
```
0 0 0
1 0 1
0 1 1
0 1 0
```

---

## 代码实现

完整的可运行代码：[L0289_GameOfLife.java](../src/main/java/L0289_GameOfLife.java)

```java
public void gameOfLife(int[][] board) {
    if (board == null || board.length == 0 || board[0].length == 0) {
        return;
    }
    
    int m = board.length;
    int n = board[0].length;
    
    // 使用状态机的思想，用不同的数字表示状态的变化
    // 2: 从活细胞变为死细胞
    // 3: 从死细胞变为活细胞
    
    // 遍历每个细胞
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 统计周围活细胞的数量
            int liveNeighbors = countLiveNeighbors(board, i, j);
            
            // 根据规则更新状态
            if (board[i][j] == 1) {
                // 当前是活细胞
                if (liveNeighbors < 2 || liveNeighbors > 3) {
                    // 规则 1 和规则 3：活细胞死亡
                    board[i][j] = 2;
                }
            } else {
                // 当前是死细胞
                if (liveNeighbors == 3) {
                    // 规则 4：死细胞复活
                    board[i][j] = 3;
                }
            }
        }
    }
    
    // 更新最终状态
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            board[i][j] = board[i][j] % 2;
        }
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(m×n)，其中 m 和 n 分别是矩阵的行数和列数。需要遍历矩阵两次。
- **空间复杂度**：O(1)，只使用了常数额外空间。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 