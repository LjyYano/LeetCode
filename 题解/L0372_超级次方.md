---
title: 超级次方
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[超级次方](https://leetcode.cn/problems/super-pow/)  
**🏷️ 标签**：`数学` `分治`  
**🟡 难度**：`中等`  

你的任务是计算 a^b 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。

示例 1：
```
输入：a = 2, b = [3]
输出：8
```

示例 2：
```
输入：a = 2, b = [1,0]
输出：1024
```

示例 3：
```
输入：a = 1, b = [4,3,3,8,5,2]
输出：1
```

示例 4：
```
输入：a = 2147483647, b = [2,0,0]
输出：1198
```

提示：
- 1 <= a <= 2³¹ - 1
- 1 <= b.length <= 2000
- 0 <= b[i] <= 9
- b 不含前导 0

---

## 解题思路
### 欧拉定理 + 快速幂

#### 📝 核心思想
这道题的难点在于指数 b 是以数组形式给出的大数。直接计算会导致数值溢出，因此我们需要用到一些数论知识来优化计算：

1. **欧拉定理**：对于互质的正整数 a 和 n，有 a^φ(n) ≡ 1 (mod n)
   - 其中 φ(n) 是欧拉函数，表示小于 n 且与 n 互质的正整数的个数
   - 这意味着我们可以将指数对 φ(n) 取模，从而大大减小计算量

2. **模数分析**：
   - 本题中模数 1337 = 7 × 191
   - φ(1337) = φ(7) × φ(191) = 6 × 190 = 1140
   - 因此，对于任意与 1337 互质的数 a，都有 a^1140 ≡ 1 (mod 1337)

3. **快速幂**：
   - 使用二进制的思想，将幂运算的时间复杂度从 O(n) 优化到 O(log n)
   - 在计算过程中不断取模，避免中间结果溢出

#### 🛠️ 实现步骤
1. 预处理：
   - 将 a 对 1337 取模，减小初始值
   - 计算数组 b 表示的数对 1140 取模的结果

2. 使用快速幂计算最终结果：
   - 将指数转换为二进制表示
   - 按位计算，每一位都进行平方操作
   - 如果当前位为 1，则额外乘以底数

#### 🧩 示例分析
以 a = 2, b = [1,0] 为例，说明计算过程：

1. 预处理：
```
a = 2 % 1337 = 2
b = [1,0] 表示数字 10
exp = 10 % 1140 = 10
```

2. 快速幂计算 2^10 mod 1337：
```
n = 10 的二进制表示：1010

初始：result = 1, x = 2
第 1 步：n = 1010
        x = (2 × 2) % 1337 = 4
        result = 1

第 2 步：n = 101
        x = (4 × 4) % 1337 = 16
        result = (1 × 4) % 1337 = 4

第 3 步：n = 10
        x = (16 × 16) % 1337 = 256
        result = 4

第 4 步：n = 1
        x = (256 × 256) % 1337 = 65536 % 1337 = 1024
        result = (4 × 256) % 1337 = 1024
```

最终结果为 1024。

为什么这样做是正确的？
1. 根据欧拉定理，我们可以将指数对 φ(1337) = 1140 取模
2. 使用快速幂可以高效计算大数的幂
3. 在计算过程中不断取模，避免了中间结果溢出

---

## 代码实现

完整的可运行代码：[L0372_SuperPow.java](../src/main/java/L0372_SuperPow.java)

```java
public int superPow(int a, int[] b) {
    // 处理 a，先对 1337 取模
    a %= MOD;
    
    // 计算 b 数组表示的数对 1140 取模的结果
    int exp = 0;
    for (int digit : b) {
        exp = (exp * 10 + digit) % 1140;
    }
    
    // 使用快速幂计算结果
    return quickPow(a, exp);
}

/**
 * 快速幂算法计算 (x^n) % MOD
 */
private int quickPow(int x, int n) {
    int result = 1;
    // 在计算过程中不断对 MOD 取模，防止溢出
    x %= MOD;
    
    while (n > 0) {
        if ((n & 1) == 1) {
            result = (result * x) % MOD;
        }
        x = (x * x) % MOD;
        n >>= 1;
    }
    
    return result;
}
```

---

## 复杂度分析

- **时间复杂度**：O(log n)
  - 处理数组 b 需要 O(len) 时间，其中 len 是数组 b 的长度
  - 快速幂算法的时间复杂度是 O(log n)，其中 n 是指数的大小
  - 总体时间复杂度为 O(len + log n)

- **空间复杂度**：O(1)
  - 只使用了几个变量来存储中间结果
  - 不需要额外的空间

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 