---
title: 按要求补充数组
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[按要求补充数组](https://leetcode.cn/problems/patching-array/)  
**🏷️ 标签**：`贪心` `数组`  
**🔴 难度**：`困难`  

给定一个已排序的正整数数组 nums 和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。

请返回满足上述要求的最少需要补充的数字个数。

示例 1:
```
输入: nums = [1,3], n = 6
输出: 1 
解释:
nums 数组为 [1, 3]，其中 [1, 3] 能组成的和有 1、3、4。
补充数字 2，之后能组成的和有 1、2、3、4、5、6。
所以最少需要补充 1 个数字。
```

示例 2:
```
输入: nums = [1,5,10], n = 20
输出: 2
解释: nums 数组为 [1, 5, 10]，其中 [1, 5, 10] 能组成的和有 1、5、6、10、11、15、16。
补充数字 2 和 4，之后能组成的和有 1、2、3、4、5、6、7、8、9、10、11、12、13、14、15、16、17、18、19、20。
所以最少需要补充 2 个数字。
```

示例 3:
```
输入: nums = [1,2,2], n = 5
输出: 0
```

提示：
- 1 <= nums.length <= 1000
- 1 <= nums[i] <= 10⁴
- nums 按升序排列
- 1 <= n <= 2³¹ - 1

---

## 解题思路
### 贪心算法

#### 📝 核心思想
这道题可以使用贪心算法来解决。我们需要维护一个变量 miss，表示当前能够表示的数字范围是 [1, miss)。对于数组中的每个数字，我们都需要判断是否需要在其之前补充一个数字。

关键点：
1. 如果当前数字 nums[i] <= miss，说明可以扩展当前的范围到 [1, miss + nums[i])
2. 如果当前数字 nums[i] > miss，说明在范围内有数字无法表示，需要补充一个数字 miss
3. 每次补充数字时，都选择补充当前无法表示的最小数字，这样可以保证补充的数字最少

#### 🛠️ 实现步骤
1. 初始化：
   - patches = 0（需要补充的数字个数）
   - miss = 1（当前能表示的范围是 [1, miss)）
   - i = 0（数组下标）

2. 当 miss <= n 时，循环处理：
   - 如果 i < nums.length 且 nums[i] <= miss：
     - 更新范围：miss += nums[i]
     - i++
   - 否则：
     - 补充数字 miss
     - 更新范围：miss += miss
     - patches++

3. 返回 patches

#### 🧩 示例分析
以示例 1 为例，nums = [1,3], n = 6：

| 步骤 | 当前范围 [1,miss) | 操作 | 新范围 | 补充数字 | 说明 |
|-----|-----------------|------|--------|---------|-----|
| 1 | [1,1) | 使用 1 | [1,2) | - | 使用数组中的 1 |
| 2 | [1,2) | 补充 2 | [1,4) | 2 | 需要补充 2 |
| 3 | [1,4) | 使用 3 | [1,7) | - | 使用数组中的 3 |
| 4 | [1,7) | 结束 | - | - | 已经覆盖 [1,6] |

最终需要补充的数字个数为 1。

以示例 2 为例，nums = [1,5,10], n = 20：

| 步骤 | 当前范围 [1,miss) | 操作 | 新范围 | 补充数字 | 说明 |
|-----|-----------------|------|--------|---------|-----|
| 1 | [1,1) | 使用 1 | [1,2) | - | 使用数组中的 1 |
| 2 | [1,2) | 补充 2 | [1,4) | 2 | 需要补充 2 |
| 3 | [1,4) | 补充 4 | [1,8) | 4 | 需要补充 4 |
| 4 | [1,8) | 使用 5 | [1,13) | - | 使用数组中的 5 |
| 5 | [1,13) | 使用 10 | [1,23) | - | 使用数组中的 10 |
| 6 | [1,23) | 结束 | - | - | 已经覆盖 [1,20] |

最终需要补充的数字个数为 2。

---

## 代码实现

完整的可运行代码：[L0330_PatchingArray.java](../src/main/java/L0330_PatchingArray.java)

```java
public int minPatches(int[] nums, int n) {
    // 记录需要补充的数字个数
    int patches = 0;
    // 当前能够表示的数字范围是 [1, miss)
    long miss = 1;
    int i = 0;
    
    while (miss <= n) {
        if (i < nums.length && nums[i] <= miss) {
            // 如果当前数字小于等于 miss，则可以扩展范围
            miss += nums[i];
            i++;
        } else {
            // 需要补充一个数字（补充 miss）
            miss += miss;
            patches++;
        }
    }
    
    return patches;
}
```

---

## 复杂度分析

- **时间复杂度**：O(m + logn)
  - m 是数组 nums 的长度
  - 每次循环要么处理数组中的一个数字，要么补充一个数字
  - 补充数字的次数是 O(logn)，因为每次补充后范围会翻倍

- **空间复杂度**：O(1)
  - 只使用了常数个变量来存储状态
  - 不需要额外的数据结构

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 