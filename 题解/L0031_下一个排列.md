# 31. 下一个排列

## 题目

给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。

示例 1：
```text
输入：nums = [1,2,3]
输出：[1,3,2]
```

示例 2：
```text
输入：nums = [3,2,1]
输出：[1,2,3]
```

示例 3：
```text
输入：nums = [1,1,5]
输出：[1,5,1]
```

提示：
- 1 <= nums.length <= 100
- 0 <= nums[i] <= 100

## 解题思路

这道题要求我们找出给定数组的下一个排列，即在所有可能的排列中，找到一个比当前排列大的最小排列。如果不存在下一个更大的排列，则将数组重排为字典序最小的排列（即升序排列）。

### 思路分析

1. 要得到一个大于当前序列的新序列，我们需要将一个较小数与它后面的一个较大数交换，这样才能让序列变大。
2. 同时，我们要让增大的幅度尽可能小，所以：
   - 我们需要从后向前找第一个相邻的升序对 (i,i+1)，使得 nums[i] < nums[i+1]。此时 i+1 到最后的这段序列一定是降序的。
   - 在 i+1 到最后的范围内，从后向前找第一个大于 nums[i] 的数字，记为 nums[j]，将 nums[i] 与 nums[j] 交换。
   - 此时可以证明从位置 i+1 到最后的这段序列仍然是降序的。
   - 最后，我们将 i+1 到最后的这段序列反转，使其变为升序，以确保新序列增大的幅度最小。

### 具体步骤

1. 从后向前遍历，找到第一个相邻升序对 (i,i+1)，满足 nums[i] < nums[i+1]。
2. 如果找到了这样的升序对：
   - 从后向前找到第一个大于 nums[i] 的数 nums[j]。
   - 交换 nums[i] 和 nums[j]。
3. 将位置 i+1 到末尾的子数组进行反转（因为这部分一定是降序的，反转后变为升序）。

### 举例说明

以 [1,2,7,4,3,1] 为例：

1. 从后向前找，发现 2 < 7，此时 i = 1。
2. 在 [7,4,3,1] 中从后向前找第一个大于 2 的数，找到 3。
3. 交换 2 和 3，得到 [1,3,7,4,2,1]。
4. 将 i+1 后面的部分反转，即将 [7,4,2,1] 反转为 [1,2,4,7]。
5. 最终得到 [1,3,1,2,4,7]。

## 复杂度分析

- 时间复杂度：O(n)，其中 n 为数组长度。我们最多需要扫描数组两次。
- 空间复杂度：O(1)，只需要常数级别的额外空间。

## 代码实现

```java
public void nextPermutation(int[] nums) {
    // 1. 从后向前找到第一个相邻升序对 (i,i+1)，满足 nums[i] < nums[i+1]
    int i = nums.length - 2;
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }

    // 2. 如果找到了升序对
    if (i >= 0) {
        // 从后向前找到第一个大于 nums[i] 的数
        int j = nums.length - 1;
        while (j >= 0 && nums[j] <= nums[i]) {
            j--;
        }
        // 交换 i 和 j 位置的数
        swap(nums, i, j);
    }

    // 3. 将 i 之后的数进行反转（变为升序）
    reverse(nums, i + 1);
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

private void reverse(int[] nums, int start) {
    int left = start, right = nums.length - 1;
    while (left < right) {
        swap(nums, left, right);
        left++;
        right--;
    }
}
``` 