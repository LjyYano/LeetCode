---
title: 下一个排列
date: 2025-02-08
---

## 题目描述

**🔗 题目**：[下一个排列](https://leetcode.cn/problems/next-permutation/)  
**🏷️ 标签**：`数组` `双指针`  
**🟡 难度**：`中等`  

整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。

例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须 **原地** 修改，只允许使用额外常数空间。

**示例 1：**
```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**
```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**
```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**提示：**
- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

---

## 解题思路

### 字典序算法

#### 📝 核心思想
要找到下一个排列，我们需要找到一个比当前排列大的数，而且要尽可能小。关键是从后向前找到第一个相邻的升序对，然后进行适当的交换和反转操作。

#### 🛠️ 实现步骤
1. 从后向前遍历数组，找到第一个相邻的升序对 (i-1, i)，此时 i 及其后面的元素为降序。
2. 如果找到了这样的升序对：
   - 从后向前找到第一个大于 nums[i-1] 的数 nums[j]
   - 交换 nums[i-1] 和 nums[j]
3. 将位置 i 及其后面的所有元素反转，使其变为升序。

#### 🧩 示例分析
以示例 1：nums = [1,2,3] 为例，演示整个过程：

1. 从后向前找第一个升序对：
   ```
   [1,2,3]
      ↑ ↑
   找到升序对 (2,3)
   ```

2. 从后向前找第一个大于 2 的数：
   ```
   [1,2,3]
      ↑ ↑
   找到 3 大于 2
   ```

3. 交换 2 和 3：
   ```
   [1,2,3] → [1,3,2]
      ↑ ↑
   ```

4. 将位置 i 后面的元素反转（此例中只有一个元素，无需反转）：
   ```
   [1,3,2]
   ```

以示例 2：nums = [3,2,1] 为例：

1. 从后向前找升序对：
   ```
   [3,2,1]
   没有找到升序对
   ```

2. 直接将整个数组反转：
   ```
   [3,2,1] → [1,2,3]
   ```

---

## 代码实现

完整的可运行代码：[L0031_NextPermutation.java](../src/main/java/L0031_NextPermutation.java)

```java
public void nextPermutation(int[] nums) {
    // 从后向前找到第一个相邻升序对 (i-1, i)，此时 i 及其后面的元素为降序
    int i = nums.length - 1;
    while (i > 0 && nums[i - 1] >= nums[i]) {
        i--;
    }

    if (i > 0) {
        // 从后向前找到第一个大于 nums[i-1] 的数
        int j = nums.length - 1;
        while (j >= i && nums[j] <= nums[i - 1]) {
            j--;
        }
        // 交换 nums[i-1] 和 nums[j]
        swap(nums, i - 1, j);
    }

    // 将 i 及其后面的元素反转
    reverse(nums, i);
}

// 交换数组中的两个元素
private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

// 反转数组中从 start 开始的部分
private void reverse(int[] nums, int start) {
    int left = start, right = nums.length - 1;
    while (left < right) {
        swap(nums, left, right);
        left++;
        right--;
    }
}
```

---

## 复杂度分析

- **时间复杂度**：`O(n)`，其中 n 是数组的长度。最坏情况下，需要遍历数组两次。
- **空间复杂度**：`O(1)`，只使用了常数额外空间。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 