---
title: 最大数
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[最大数](https://leetcode.cn/problems/largest-number/)  
**🏷️ 标签**：`贪心` `字符串` `排序`  
**🟡 难度**：`中等`  

给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。

示例 1：
```
输入：nums = [10,2]
输出："210"
```

示例 2：
```
输入：nums = [3,30,34,5,9]
输出："9534330"
```

提示：
- 1 <= nums.length <= 100
- 0 <= nums[i] <= 10⁹

---

## 解题思路

### 自定义排序

#### 📝 核心思想

这道题的关键在于如何确定两个数字的排序顺序。对于两个数字 a 和 b，我们需要判断 ab 和 ba 哪个组合更大。例如：
1. 对于 3 和 30，我们需要比较 "330" 和 "303"
2. 对于 34 和 3，我们需要比较 "343" 和 "334"

通过这种比较方式，我们可以得到一个最优的排序结果。这是一个贪心的策略，因为我们每次都选择当前最优的组合。

#### 🛠️ 实现步骤

1. 将整数数组转换为字符串数组，便于后续拼接和比较
2. 使用自定义比较器对字符串数组进行排序：
   - 对于任意两个字符串 s1 和 s2，比较 s2+s1 和 s1+s2 的大小
   - 如果 s2+s1 > s1+s2，则 s2 应该排在 s1 前面
3. 处理特殊情况：如果排序后第一个数字是 "0"，说明所有数字都是 0，直接返回 "0"
4. 将排序后的字符串数组拼接成最终结果

#### 🧩 示例分析

以示例 2 为例，nums = [3,30,34,5,9]：

1. 首先将数组转换为字符串：["3", "30", "34", "5", "9"]

2. 对数组进行排序，需要两两比较：

   | 比较的数字对 | 拼接方式 1 | 拼接方式 2 | 选择 | 当前数组 |
   |------------|-----------|-----------|------|---------|
   | 3 和 30    | "330"     | "303"     | 3    | [3,34,5,9,30] |
   | 3 和 34    | "334"     | "343"     | 34   | [34,3,5,9,30] |
   | 34 和 5    | "345"     | "534"     | 5    | [5,34,3,9,30] |
   | 5 和 9     | "59"      | "95"      | 9    | [9,5,34,3,30] |

3. 最终排序结果：["9", "5", "34", "3", "30"]

4. 拼接得到最终结果："9534330"

特殊情况示例：nums = [0,0]
1. 转换为字符串：["0", "0"]
2. 排序后仍然是：["0", "0"]
3. 发现第一个数字是 "0"，直接返回 "0"

---

## 代码实现

完整的可运行代码：[L0179_LargestNumber.java](../src/main/java/L0179_LargestNumber.java)

```java
public String largestNumber(int[] nums) {
    // 将整数数组转换为字符串数组
    String[] strs = new String[nums.length];
    for (int i = 0; i < nums.length; i++) {
        strs[i] = String.valueOf(nums[i]);
    }
    
    // 自定义排序规则：比较 s1+s2 和 s2+s1 的大小
    // 例如：对于 3 和 30，比较 "330" 和 "303"
    java.util.Arrays.sort(strs, (s1, s2) -> (s2 + s1).compareTo(s1 + s2));
    
    // 处理特殊情况：如果排序后第一个数字是 0，说明所有数字都是 0
    if (strs[0].equals("0")) {
        return "0";
    }
    
    // 拼接所有数字
    StringBuilder result = new StringBuilder();
    for (String str : strs) {
        result.append(str);
    }
    
    return result.toString();
}
```

---

## 复杂度分析

- **时间复杂度**：O(n log n)，其中 n 是数组的长度。主要时间消耗在排序上，Java 的 Arrays.sort() 使用的是改进的快速排序，时间复杂度为 O(n log n)。字符串比较的时间复杂度是 O(k)，其中 k 是拼接后字符串的最大长度，但由于题目限制了数字的范围，k 可以视为常数。

- **空间复杂度**：O(n)，需要创建一个字符串数组来存储数字的字符串形式。排序过程中也需要 O(log n) 的栈空间。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 