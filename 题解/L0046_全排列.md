# 46. 全排列

[题目链接](https://leetcode.cn/problems/permutations/)

## 题目描述

给定一个不含重复数字的数组 nums ，返回其所有可能的全排列。你可以按任意顺序返回答案。

示例 1：
```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

示例 2：
```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

示例 3：
```
输入：nums = [1]
输出：[[1]]
```

提示：
* 1 <= nums.length <= 6
* -10 <= nums[i] <= 10
* nums 中的所有整数 互不相同

## 解题思路

本题是一个典型的回溯算法问题。回溯算法的核心思想是：从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到不满足条件的状态时，就回溯到上一个状态，继续尝试其他可能的解决方案。

对于全排列问题，我们可以这样思考：
1. 每次从数组中选择一个没有被使用过的数字
2. 将这个数字加入到当前正在构建的排列中
3. 继续递归地构建剩余数字的排列
4. 当前排列构建完成后，将最后添加的数字移除，尝试其他可能的数字

具体实现步骤：
1. 使用一个列表 tempList 来存储当前正在构建的排列
2. 使用一个列表 result 来存储所有已经构建好的排列
3. 当 tempList 的大小等于输入数组的长度时，说明找到了一个完整的排列，将其加入到 result 中
4. 在每一步中，遍历输入数组，如果当前数字还没有被使用（不在 tempList 中），就将其加入到 tempList 中
5. 递归调用回溯函数，继续构建排列
6. 递归调用结束后，将最后添加的数字从 tempList 中移除，继续尝试其他数字

## 代码实现

```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    backtrack(result, new ArrayList<>(), nums);
    return result;
}

private void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums) {
    // 当临时列表的大小等于数组长度时，说明找到了一个排列
    if (tempList.size() == nums.length) {
        result.add(new ArrayList<>(tempList));
        return;
    }
    
    // 尝试将每个数字加入临时列表
    for (int i = 0; i < nums.length; i++) {
        // 如果临时列表已经包含了这个数字，跳过
        if (tempList.contains(nums[i])) {
            continue;
        }
        // 将当前数字加入临时列表
        tempList.add(nums[i]);
        // 递归调用
        backtrack(result, tempList, nums);
        // 回溯，移除最后添加的数字
        tempList.remove(tempList.size() - 1);
    }
}
```

## 复杂度分析

* 时间复杂度：O(n!)，其中 n 是数组的长度。对于长度为 n 的数组，第一次选择有 n 种可能，第二次选择有 (n-1) 种可能，依此类推，所以总的时间复杂度是 O(n!)。

* 空间复杂度：O(n)，其中 n 是数组的长度。这里的空间复杂度不考虑存储答案所需的空间，只考虑递归调用栈的空间。递归调用栈的深度最大为 n。如果考虑存储答案所需的空间，空间复杂度为 O(n * n!)，因为一共有 n! 个排列，每个排列需要 O(n) 的空间。

## 优化思路

1. 可以使用一个布尔数组来标记数字是否被使用过，这样可以将 contains 操作的时间复杂度从 O(n) 降低到 O(1)。

2. 如果题目允许修改输入数组，可以通过交换数组元素的方式来生成排列，这样可以避免使用额外的空间来存储临时排列。

3. 如果需要按照字典序生成排列，可以先对输入数组进行排序，然后使用"下一个排列"的算法来生成所有排列。 