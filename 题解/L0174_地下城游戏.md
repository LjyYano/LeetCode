---
title: 地下城游戏
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[地下城游戏](https://leetcode.cn/problems/dungeon-game/)  
**🏷️ 标签**：`数组` `动态规划` `矩阵`  
**🔴 难度**：`困难`  

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

```
-2(K)  -3     3
-5     -10    1
10     30     -5(P)
```

说明:
- 骑士的健康点数没有上限。
- 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

---

## 解题思路
### 动态规划（从右下到左上）

#### 📝 核心思想
这道题乍看是从左上到右下的路径问题，但实际上我们需要从右下角往左上角进行动态规划。原因是：
1. 骑士需要在任何时刻都保持生存（健康点数 > 0）
2. 我们需要知道到达终点时的最低健康点数要求
3. 从终点往回推，可以确保每个位置都满足最低健康点数的要求

#### 🛠️ 实现步骤
1. 创建动态规划数组 dp[m][n]，dp[i][j] 表示从位置 (i,j) 到达右下角所需的最小初始健康点数
2. 初始化右下角位置：
   - dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])
3. 初始化最后一行和最后一列
4. 从右下角向左上角进行动态规划：
   - 对于每个位置 (i,j)，选择右边和下边中所需健康点数较小的路径
   - 确保当前位置的健康点数至少为 1

#### 🧩 示例分析
以示例中的地下城为例：
```
-2(K)  -3     3
-5     -10    1
10     30     -5(P)
```

1. 初始化右下角：
   ```
   dp[2][2] = max(1, 1 - (-5)) = 6
   ```
   说明：到达终点时至少需要 6 点健康值才能抵消 -5 的伤害并保持存活（至少 1 点健康值）

2. 初始化最后一行和最后一列：
   ```
   最后一行：
   dp[2][1] = max(1, 6 - 30) = 1
   dp[2][0] = max(1, 1 - 10) = 1

   最后一列：
   dp[1][2] = max(1, 6 - 1) = 5
   dp[0][2] = max(1, 5 - 3) = 2
   ```

3. 填充其他位置：
   | 位置 | 计算过程 | 结果 |
   |-----|---------|------|
   | (1,1) | min(5,1) - (-10) = 15 | dp[1][1] = 15 |
   | (1,0) | min(15,1) - (-5) = 6 | dp[1][0] = 6 |
   | (0,1) | min(15,2) - (-3) = 5 | dp[0][1] = 5 |
   | (0,0) | min(5,6) - (-2) = 7 | dp[0][0] = 7 |

4. 最终结果：
   - 骑士在起点 (0,0) 需要至少 7 点健康值才能确保成功救出公主
   - 这个结果考虑了所有可能的路径，并选择了所需初始健康点数最小的路径

---

## 代码实现

完整的可运行代码：[L0174_DungeonGame.java](../src/main/java/L0174_DungeonGame.java)

```java
public int calculateMinimumHP(int[][] dungeon) {
    if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) {
        return 1;
    }
    
    int m = dungeon.length;
    int n = dungeon[0].length;
    
    // dp[i][j] 表示从位置 (i,j) 到达右下角所需的最小初始健康点数
    int[][] dp = new int[m][n];
    
    // 初始化右下角的位置
    dp[m - 1][n - 1] = Math.max(1, 1 - dungeon[m - 1][n - 1]);
    
    // 初始化最后一列
    for (int i = m - 2; i >= 0; i--) {
        dp[i][n - 1] = Math.max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]);
    }
    
    // 初始化最后一行
    for (int j = n - 2; j >= 0; j--) {
        dp[m - 1][j] = Math.max(1, dp[m - 1][j + 1] - dungeon[m - 1][j]);
    }
    
    // 从右下角向左上角进行动态规划
    for (int i = m - 2; i >= 0; i--) {
        for (int j = n - 2; j >= 0; j--) {
            int minHealth = Math.min(dp[i + 1][j], dp[i][j + 1]);
            dp[i][j] = Math.max(1, minHealth - dungeon[i][j]);
        }
    }
    
    return dp[0][0];
}
```

---

## 复杂度分析

- **时间复杂度**：O(m×n)，其中 m 和 n 分别是地下城的行数和列数。我们需要遍历整个地下城一次。
- **空间复杂度**：O(m×n)，需要一个与地下城大小相同的 dp 数组来存储中间结果。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 