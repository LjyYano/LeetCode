---
title: 最大回文数乘积
date: 2024-02-12
---

## 题目描述

**🔗 题目**：[479. 最大回文数乘积](https://leetcode.cn/problems/largest-palindrome-product/)  
**🏷️ 标签**：`数学` `回溯`  
**🔴 难度**：`困难`  

给定一个整数 n ，返回 可表示为两个 `n` 位整数乘积的 最大回文整数 。因为答案可能非常大，所以返回它对 `1337` 取余 。

**示例 1：**
```
输入：n = 2
输出：987
解释：99 x 91 = 9009, 9009 % 1337 = 987
```

**示例 2：**
```
输入：n = 1
输出：9
解释：9 x 9 = 81, 9 是回文数, 81 % 1337 = 9
```

**提示：**
- `1 <= n <= 8`

---

## 解题思路

### 枚举回文数法

#### 📝 核心思想
与其枚举所有可能的两个 n 位数的乘积，不如直接枚举回文数。从最大的回文数开始，检查是否能分解为两个 n 位数的乘积。

对于 n 位数，最大值是 10^n - 1，最小值是 10^(n-1)。
- 最大可能的回文数是 (10^n - 1)²
- 我们可以通过枚举回文数的左半部分来构造完整的回文数

#### 🛠️ 实现步骤
1. 确定 n 位数的范围：[10^(n-1), 10^n - 1]
2. 从最大的回文数开始枚举（构造回文数的左半部分，然后镜像得到右半部分）
3. 对于每个回文数，检查是否能分解为两个 n 位数的乘积
4. 找到第一个满足条件的回文数即为答案

#### 🧩 示例分析
以 n = 2 为例：
- 两位数范围：[10, 99]
- 最大可能的乘积：99 × 99 = 9801
- 从 9999 开始枚举回文数（虽然它超过了 9801，但我们从大到小枚举）
- 9999 不能分解为两个两位数的乘积
- 9889、9779... 继续检查
- 9009 = 99 × 91 ✓

### 特殊情况处理
对于 n = 1，答案是 9（9 = 9 × 1，但 1 是一位数）

---

## 代码实现

```java
public class L0479_LargestPalindromeProduct {
    public int largestPalindrome(int n) {
        // 特殊情况
        if (n == 1) {
            return 9;
        }
        
        // n 位数的最大值和最小值
        long max = (long) Math.pow(10, n) - 1;
        long min = (long) Math.pow(10, n - 1);
        
        // 从最大可能的回文数开始枚举
        // 枚举回文数的左半部分
        for (long left = max; left >= min; left--) {
            // 构造回文数
            long palindrome = createPalindrome(left);
            
            // 检查是否能分解为两个 n 位数的乘积
            for (long i = max; i * i >= palindrome; i--) {
                if (palindrome % i == 0) {
                    long j = palindrome / i;
                    if (j <= max && j >= min) {
                        return (int) (palindrome % 1337);
                    }
                }
            }
        }
        
        return -1;
    }
    
    // 根据左半部分构造回文数
    private long createPalindrome(long left) {
        String s = String.valueOf(left);
        String reversed = new StringBuilder(s).reverse().toString();
        return Long.parseLong(s + reversed);
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(10^n)，需要枚举回文数的左半部分。
- **空间复杂度**：O(n)，用于存储数字字符串。

---

## 相关题目

- [🔗 9. 回文数](https://leetcode.cn/problems/palindrome-number/)
- [🔗 125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)
- [🔗 564. 寻找最近的回文数](https://leetcode.cn/problems/find-the-closest-palindrome/)

---

## 总结

这道题是一道数学题，结合了回文数和因数分解。解题的关键在于：
1. 从最大的回文数开始枚举，而不是枚举所有可能的乘积
2. 巧妙地构造回文数（通过镜像左半部分）
3. 高效地检查回文数是否能分解为两个 n 位数的乘积

通过这道题，我们可以学习到：
1. 如何优化暴力枚举
2. 回文数的构造方法
3. 数学问题中的剪枝技巧

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 