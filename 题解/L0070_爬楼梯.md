---
title: 爬楼梯
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[爬楼梯](https://leetcode.cn/problems/climbing-stairs/)  
**🏷️ 标签**：`数学` `动态规划` `记忆化搜索`  
**🟢 难度**：`简单`  

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**
```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**
```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**提示：**
- 1 <= n <= 45

---

## 解题思路
### 动态规划

#### 📝 核心思想
这道题可以使用动态规划来解决。关键在于发现：要到达第 i 阶楼梯，只能从第 i-1 阶或第 i-2 阶楼梯爬上来。因此，到达第 i 阶楼梯的方法数就是到达第 i-1 阶和第 i-2 阶楼梯的方法数之和。这实际上形成了一个斐波那契数列。

#### 🛠️ 实现步骤
1. 处理特殊情况：
   - 如果 n ≤ 2，直接返回 n

2. 创建动态规划数组：
   - dp[i] 表示爬到第 i 阶楼梯的方法数
   - 初始化 dp[1] = 1 和 dp[2] = 2

3. 动态规划过程：
   - 从第 3 阶开始，dp[i] = dp[i-1] + dp[i-2]

4. 空间优化：
   - 由于每次只需要前两个状态，可以使用滚动数组优化空间复杂度

#### 🧩 示例分析
以 n = 5 为例，演示动态规划的过程：

| 阶数 | 方法数 | 计算过程 | 所有可能的方法 |
|-----|--------|---------|--------------|
| 1 | 1 | 基础情况 | [1] |
| 2 | 2 | 基础情况 | [1,1], [2] |
| 3 | 3 | dp[3] = dp[2] + dp[1] = 2 + 1 | [1,1,1], [1,2], [2,1] |
| 4 | 5 | dp[4] = dp[3] + dp[2] = 3 + 2 | [1,1,1,1], [1,1,2], [1,2,1], [2,1,1], [2,2] |
| 5 | 8 | dp[5] = dp[4] + dp[3] = 5 + 3 | [1,1,1,1,1], [1,1,1,2], [1,1,2,1], [1,2,1,1], [2,1,1,1], [1,2,2], [2,1,2], [2,2,1] |

空间优化版本的状态变化：
```
n = 5 的计算过程：
初始状态：prev = 1, curr = 2
第 3 步：next = 1 + 2 = 3    prev = 2, curr = 3
第 4 步：next = 2 + 3 = 5    prev = 3, curr = 5
第 5 步：next = 3 + 5 = 8    prev = 5, curr = 8
```

这个问题可以看作是斐波那契数列的变体：
```
n:     1, 2, 3, 4, 5, 6,  7,  8,  9, ...
方法数: 1, 2, 3, 5, 8, 13, 21, 34, 55, ...
```

---

## 代码实现

完整的可运行代码：[L0070_ClimbingStairs.java](../src/main/java/L0070_ClimbingStairs.java)

```java
public int climbStairs(int n) {
    // 特殊情况处理
    if (n <= 2) {
        return n;
    }

    // dp[i] 表示爬到第 i 阶楼梯的方法数
    int[] dp = new int[n + 1];
    
    // 初始化基础情况
    dp[1] = 1; // 爬到第 1 阶楼梯只有 1 种方法
    dp[2] = 2; // 爬到第 2 阶楼梯有 2 种方法
    
    // 从第 3 阶开始计算
    for (int i = 3; i <= n; i++) {
        // 爬到第 i 阶的方法数等于爬到第 i-1 阶的方法数加上爬到第 i-2 阶的方法数
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

// 空间优化版本
public int climbStairsOptimized(int n) {
    if (n <= 2) {
        return n;
    }

    int prev = 1;  // dp[i-2]
    int curr = 2;  // dp[i-1]
    
    for (int i = 3; i <= n; i++) {
        int next = prev + curr;
        prev = curr;
        curr = next;
    }
    
    return curr;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是楼梯的阶数。我们需要计算每一阶楼梯的方法数。
- **空间复杂度**：
  * 原始动态规划版本：O(n)，需要一个数组存储所有状态
  * 优化版本：O(1)，只需要两个变量记录状态

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 