---
title: 阶乘后的零
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[阶乘后的零](https://leetcode.cn/problems/factorial-trailing-zeroes/)  
**🏷️ 标签**：`数学`  
**🟢 难度**：`中等`  

给定一个整数 n ，返回 n! 结果中尾随零的数量。

提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1

示例 1：
```
输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
```

示例 2：
```
输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
```

示例 3：
```
输入：n = 0
输出：0
```

提示：
- 0 <= n <= 10⁴

---

## 解题思路

### 因子分析法

#### 📝 核心思想

要计算阶乘结果中尾随零的数量，我们需要分析能产生尾随零的因子。在阶乘计算中：

1. 尾随零是由因子 2 和 5 相乘产生的
2. 在阶乘序列中，2 的数量总是比 5 多（因为每个偶数都包含因子 2）
3. 因此，尾随零的数量仅取决于因子 5 的数量

#### 🛠️ 实现步骤

1. 初始化计数器 count = 0
2. 对于给定的 n，计算其中包含的因子 5 的数量：
   - 首先计算 n/5（包含一个因子 5 的数的数量）
   - 然后计算 n/25（包含两个因子 5 的数的数量）
   - 继续计算 n/125（包含三个因子 5 的数的数量）
   - 直到 n/5ᵏ < 1
3. 返回计数器的值

#### 🧩 示例分析

以 n = 25 为例，让我们逐步分析：

| 步骤 | 操作 | 计算 | 累计结果 | 说明 |
|-----|------|-----|---------|-----|
| 1 | n/5 | 25/5 = 5 | count = 5 | 计算包含一个因子 5 的数的数量 |
| 2 | n/25 | 25/25 = 1 | count = 6 | 计算包含两个因子 5 的数的数量 |
| 3 | n/125 | 25/125 = 0 | count = 6 | 不再继续，因为商为 0 |

所以 25! 中有 6 个尾随零。

为什么这样计算是正确的？让我们详细分析 25! 中的因子 5：
- 5, 10, 15, 20, 25 各贡献一个 5（共 5 个）
- 25 额外贡献一个 5（因为 25 = 5 × 5）
- 总共 6 个因子 5，所以有 6 个尾随零

---

## 代码实现

完整的可运行代码：[L0172_FactorialTrailingZeroes.java](../src/main/java/L0172_FactorialTrailingZeroes.java)

```java
public int trailingZeroes(int n) {
    // 计算阶乘后尾随零的数量
    // 尾随零由 2 和 5 的因子产生，而 2 的数量总是比 5 多
    // 所以只需要计算 5 的因子数量
    int count = 0;
    while (n > 0) {
        n /= 5;
        count += n;
    }
    return count;
}
```

---

## 复杂度分析

- **时间复杂度**：O(log n)
  - 每次循环 n 都会除以 5，所以循环次数是 log₅n
- **空间复杂度**：O(1)
  - 只使用了常数额外空间

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 