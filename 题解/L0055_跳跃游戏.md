---
title: 跳跃游戏
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[跳跃游戏](https://leetcode.cn/problems/jump-game/)  
**🏷️ 标签**：`贪心` `数组` `动态规划`  
**🟡 难度**：`中等`  

给你一个非负整数数组 nums ，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

示例 1：
```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

示例 2：
```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

提示：
- 1 <= nums.length <= 10⁴
- 0 <= nums[i] <= 10⁵

---

## 解题思路
### 贪心算法

#### 📝 核心思想
维护一个变量 maxReach，表示当前能够到达的最远位置。遍历数组时，不断更新这个最远位置。如果在遍历过程中发现当前位置已经超出了能到达的最远位置，说明无法到达终点。

#### 🛠️ 实现步骤
1. 初始化 maxReach 为第一个位置能跳到的最远距离（nums[0]）
2. 遍历数组中的每个位置 i：
   - 如果 i 已经超出了 maxReach，说明无法到达该位置，返回 false
   - 更新 maxReach = max(maxReach, i + nums[i])
   - 如果 maxReach 已经可以到达最后一个位置，返回 true
3. 如果遍历结束后仍然无法到达最后一个位置，返回 false

#### 🧩 示例分析
以示例 1 为例，nums = [2,3,1,1,4]：

| 位置 i | nums[i] | 当前可跳范围 | maxReach | 说明 |
|-------|---------|------------|-----------|-----|
| 0 | 2 | [0,2] | 2 | 初始位置，可以跳到索引 1 或 2 |
| 1 | 3 | [1,4] | 4 | 从位置 1 可以跳到索引 2、3 或 4 |
| 2 | 1 | [2,3] | 4 | maxReach 已经是 4，不需要更新 |
| 3 | 1 | [3,4] | 4 | maxReach 已经是 4，不需要更新 |
| 4 | 4 | - | 4 | 已到达终点 |

跳跃过程示意图：
```
位置：  0   1   2   3   4
数值：  2   3   1   1   4
        ↓   ↓
        |   |
        |   +---+---+---+
        |           最远可达位置 = 4
        +---+
            最远可达位置 = 2
```

以示例 2 为例，nums = [3,2,1,0,4]：

| 位置 i | nums[i] | 当前可跳范围 | maxReach | 说明 |
|-------|---------|------------|-----------|-----|
| 0 | 3 | [0,3] | 3 | 初始位置，可以跳到索引 1、2 或 3 |
| 1 | 2 | [1,3] | 3 | maxReach 仍为 3 |
| 2 | 1 | [2,3] | 3 | maxReach 仍为 3 |
| 3 | 0 | [3,3] | 3 | 到达位置 3，但无法前进 |
| 4 | 4 | - | 3 | 无法到达位置 4 |

跳跃过程示意图：
```
位置：  0   1   2   3   4
数值：  3   2   1   0   4
        ↓
        |
        +---+---+---+
                    |
                    x 无法到达
```

---

## 代码实现

完整的可运行代码：[L0055_JumpGame.java](../src/main/java/L0055_JumpGame.java)

```java
public boolean canJump(int[] nums) {
    // 如果数组为空或只有一个元素，直接返回 true
    if (nums == null || nums.length <= 1) {
        return true;
    }
    
    // 记录当前能够到达的最远位置
    int maxReach = nums[0];
    
    // 遍历数组中的每个位置
    for (int i = 0; i <= maxReach && i < nums.length; i++) {
        // 更新最远可以到达的位置
        // 当前位置是 i，从这个位置最远可以跳 nums[i] 步
        // 所以从当前位置能到达的最远距离是 i + nums[i]
        maxReach = Math.max(maxReach, i + nums[i]);
        
        // 如果最远可达位置已经超过或等于最后一个位置，返回 true
        if (maxReach >= nums.length - 1) {
            return true;
        }
    }
    
    // 如果遍历结束后仍然无法到达最后一个位置，返回 false
    return false;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组的长度。我们只需要遍历一次数组就可以得到结果。
- **空间复杂度**：O(1)，只使用了常数级别的额外空间。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 