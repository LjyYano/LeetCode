---
title: 验证二叉树的前序序列化
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[验证二叉树的前序序列化](https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/)  
**🏷️ 标签**：`栈` `树` `字符串`  
**🟡 难度**：`中等`  

序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。

例如，上面的二叉树可以被序列化为字符串 "9,3,4,#,#,1,#,#,2,#,6,#,#"，其中 # 代表一个空节点。

![img](https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg)

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

保证 每个以逗号分隔的字符或为一个整数或为一个表示 null 指针的 '#' 。

示例 1:
```
输入: preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"
输出: true
```

示例 2:
```
输入: preorder = "1,#"
输出: false
```

示例 3:
```
输入: preorder = "9,#,#,1"
输出: false
```

提示：
- 1 <= preorder.length <= 10⁴
- preorder 由以逗号 "," 分隔的 [0-9] 和 "#" 组成

---

## 解题思路
### 槽位计数法

#### 📝 核心思想
这道题可以使用槽位计数的思想来解决。我们可以把二叉树的每个位置看作一个槽位：
1. 初始时有一个槽位（根节点的位置）
2. 遇到非空节点时，消耗一个槽位，但会产生两个新的槽位（左右子节点）
3. 遇到空节点（#）时，只消耗一个槽位
4. 遍历结束时，所有槽位都应该被消耗完

关键点：
1. 任何时候槽位数都不能小于 0
2. 遍历结束时槽位数必须正好为 0
3. 如果序列未结束但槽位数已经为 0，说明序列无效

#### 🛠️ 实现步骤
1. 初始化：
   - slots = 1（初始槽位数，根节点的位置）

2. 遍历序列中的每个节点：
   - 如果当前槽位数为 0 但序列未结束，返回 false
   - 遇到逗号，跳过
   - 遇到 #，消耗一个槽位（slots--）
   - 遇到数字，消耗一个槽位但产生两个新槽位（slots++）

3. 返回最终槽位数是否为 0

#### 🧩 示例分析
以示例 1 为例，preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"：

| 步骤 | 节点 | 操作 | 槽位变化 | 剩余槽位 | 说明 |
|-----|-----|------|---------|---------|-----|
| 初始 | - | - | - | 1 | 初始一个槽位 |
| 1 | 9 | 消耗 1 产生 2 | +1 | 2 | 根节点 |
| 2 | 3 | 消耗 1 产生 2 | +1 | 3 | 左子节点 |
| 3 | 4 | 消耗 1 产生 2 | +1 | 4 | 左左子节点 |
| 4 | # | 消耗 1 | -1 | 3 | 左左左子节点 |
| 5 | # | 消耗 1 | -1 | 2 | 左左右子节点 |
| 6 | 1 | 消耗 1 产生 2 | +1 | 3 | 左右子节点 |
| 7 | # | 消耗 1 | -1 | 2 | 左右左子节点 |
| 8 | # | 消耗 1 | -1 | 1 | 左右右子节点 |
| 9 | 2 | 消耗 1 产生 2 | +1 | 2 | 右子节点 |
| 10 | # | 消耗 1 | -1 | 1 | 右左子节点 |
| 11 | 6 | 消耗 1 产生 2 | +1 | 2 | 右右子节点 |
| 12 | # | 消耗 1 | -1 | 1 | 右右左子节点 |
| 13 | # | 消耗 1 | -1 | 0 | 右右右子节点 |

最终槽位数为 0，说明序列有效。

以示例 2 为例，preorder = "1,#"：

| 步骤 | 节点 | 操作 | 槽位变化 | 剩余槽位 | 说明 |
|-----|-----|------|---------|---------|-----|
| 初始 | - | - | - | 1 | 初始一个槽位 |
| 1 | 1 | 消耗 1 产生 2 | +1 | 2 | 根节点 |
| 2 | # | 消耗 1 | -1 | 1 | 左子节点 |

序列结束时槽位数不为 0，说明序列无效。

---

## 代码实现

完整的可运行代码：[L0331_VerifyPreorderSerializationOfABinaryTree.java](../src/main/java/L0331_VerifyPreorderSerializationOfABinaryTree.java)

```java
public boolean isValidSerialization(String preorder) {
    // 初始槽位数为 1（根节点的位置）
    int slots = 1;
    
    // 遍历序列中的每个节点
    int i = 0;
    while (i < preorder.length()) {
        // 如果没有剩余槽位，但序列还未结束，则无效
        if (slots == 0) {
            return false;
        }
        
        // 根据逗号分隔处理每个节点
        if (preorder.charAt(i) == ',') {
            i++;
        } else if (preorder.charAt(i) == '#') {
            // 遇到空节点，消耗一个槽位
            slots--;
            i++;
        } else {
            // 遇到数字节点，消耗一个槽位，但产生两个新槽位（左右子节点）
            while (i < preorder.length() && preorder.charAt(i) != ',') {
                i++;
            }
            slots++; // -1 + 2 = 1（消耗一个，产生两个）
        }
    }
    
    // 序列结束时，槽位数应该正好为 0
    return slots == 0;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)
  - 其中 n 是字符串的长度
  - 我们只需要遍历一次字符串
  - 每个字符最多被访问一次

- **空间复杂度**：O(1)
  - 只使用了常数个变量来存储状态
  - 不需要额外的数据结构

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 