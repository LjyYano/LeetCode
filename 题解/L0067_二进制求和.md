---
title: 二进制求和
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[二进制求和](https://leetcode.cn/problems/add-binary/)  
**🏷️ 标签**：`字符串` `数学` `位运算` `模拟`  
**🟢 难度**：`简单`  

给你两个二进制字符串 `a` 和 `b` ，以二进制字符串的形式返回它们的和。

**示例 1：**
```
输入：a = "11", b = "1"
输出："100"
```

**示例 2：**
```
输入：a = "1010", b = "1011"
输出："10101"
```

**提示：**
- 1 <= a.length, b.length <= 104
- a 和 b 仅由字符 '0' 或 '1' 组成
- 字符串如果不是 "0" ，就不含前导零

---

## 解题思路
### 模拟二进制加法

#### 📝 核心思想
这道题的核心思想是模拟人工计算二进制加法的过程。在二进制加法中，我们需要从右往左逐位相加，并处理进位。每一位的计算结果可能是 0、1 或需要进位的情况。

#### 🛠️ 实现步骤
1. 创建一个 StringBuilder 用于存储结果
2. 从右往左同时遍历两个字符串
3. 对于每一位：
   - 获取两个字符串对应位置的数字（如果已经遍历完则补 0）
   - 计算当前位的和（需要加上上一位的进位）
   - 更新进位值
   - 将当前位的结果插入到结果字符串的开头
4. 如果最后还有进位，需要在结果字符串开头插入 1
5. 返回结果字符串

#### 🧩 示例分析
以示例 1 为例，演示计算过程：

| 步骤 | 当前处理位置 | 计算过程 | 进位 | 当前结果 | 说明 |
|-----|------------|---------|------|---------|-----|
| 初始状态 | - | - | 0 | "" | 开始计算 |
| 1 | 最右一位 | 1 + 1 = 2 | 1 | "0" | 1 + 1 = 2，写 0 进 1 |
| 2 | 第二位 | 1 + 0 + 1 = 2 | 1 | "00" | 1 + 0 + 进位 1 = 2，写 0 进 1 |
| 3 | 第三位 | 0 + 0 + 1 = 1 | 0 | "100" | 0 + 0 + 进位 1 = 1，写 1 不进位 |

以示例 2 为例：
```
  1010
+ 1011
------
 10101
```

| 步骤 | 当前处理位置 | 计算过程 | 进位 | 当前结果 | 说明 |
|-----|------------|---------|------|---------|-----|
| 初始状态 | - | - | 0 | "" | 开始计算 |
| 1 | 最右一位 | 0 + 1 = 1 | 0 | "1" | 0 + 1 = 1，不进位 |
| 2 | 第二位 | 1 + 1 = 2 | 1 | "01" | 1 + 1 = 2，写 0 进 1 |
| 3 | 第三位 | 0 + 0 + 1 = 1 | 0 | "101" | 0 + 0 + 进位 1 = 1，不进位 |
| 4 | 第四位 | 1 + 1 = 2 | 1 | "0101" | 1 + 1 = 2，写 0 进 1 |
| 5 | 第五位 | 0 + 0 + 1 = 1 | 0 | "10101" | 0 + 0 + 进位 1 = 1，不进位 |

---

## 代码实现

完整的可运行代码：[L0067_AddBinary.java](../src/main/java/L0067_AddBinary.java)

```java
public String addBinary(String a, String b) {
    // 结果字符串
    StringBuilder result = new StringBuilder();
    // 进位
    int carry = 0;
    // 从右往左遍历两个字符串
    int i = a.length() - 1;
    int j = b.length() - 1;

    // 只要还有数字需要相加，就继续循环
    while (i >= 0 || j >= 0 || carry > 0) {
        // 获取当前位的值，如果已经遍历完了字符串，就用 0 代替
        int digitA = i >= 0 ? a.charAt(i) - '0' : 0;
        int digitB = j >= 0 ? b.charAt(j) - '0' : 0;

        // 计算当前位的和
        int sum = digitA + digitB + carry;
        // 更新进位
        carry = sum / 2;
        // 当前位的结果
        result.insert(0, sum % 2);

        // 移动指针
        i--;
        j--;
    }

    return result.toString();
}
```

---

## 复杂度分析

- **时间复杂度**：O(max(n, m))，其中 n 和 m 分别是两个字符串的长度。我们需要遍历两个字符串的每一位。
- **空间复杂度**：O(max(n, m))，需要一个 StringBuilder 来存储结果。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 