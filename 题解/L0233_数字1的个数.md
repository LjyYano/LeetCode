---
title: 数字 1 的个数
date: 2025-02-10
---

## 题目描述

**🔗 题目**：[数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/)  
**🏷️ 标签**：`数学` `动态规划`  
**🔴 难度**：`困难`  

给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

示例 1：
```
输入：n = 13
输出：6
解释：数字 1 出现在以下数字中: 1, 10, 11, 12, 13 中（共出现 6 次）
```

示例 2：
```
输入：n = 0
输出：0
```

提示：
- 0 <= n <= 10⁹

---

## 解题思路
### 数位统计法

#### 📝 核心思想
对于一个数字 n，我们可以分别计算每一位上数字 1 出现的次数，然后将所有位数上的 1 的个数相加。对于每一位，我们需要考虑：
1. 当前位的数字（可能是 0、1 或大于 1）
2. 当前位前面的数字（更高位）
3. 当前位后面的数字（更低位）

这三部分共同决定了当前位上 1 出现的次数。

#### 🛠️ 实现步骤
1. 从个位开始，依次处理每一位（乘以 10 移动到下一位）
2. 对于每一位，计算：
   - 前缀：当前位前面的数字
   - 当前位的数字
   - 后缀：当前位后面的数字
3. 根据当前位的数字分三种情况：
   - 当前位是 0：1 的个数由更高位决定
   - 当前位是 1：1 的个数由更高位和更低位共同决定
   - 当前位大于 1：1 的个数由更高位决定，且要加上当前位的单位值

#### 🧩 示例分析
以 n = 234 为例，我们逐位分析数字 1 出现的次数：

1. 个位（i = 1）：
```
前缀 = 23
当前位 = 4
后缀 = 0
因为当前位 > 1，所以个位上 1 出现的次数是：(23 + 1) * 1 = 24 次
```

2. 十位（i = 10）：
```
前缀 = 2
当前位 = 3
后缀 = 4
因为当前位 > 1，所以十位上 1 出现的次数是：(2 + 1) * 10 = 30 次
```

3. 百位（i = 100）：
```
前缀 = 0
当前位 = 2
后缀 = 34
因为当前位 > 1，所以百位上 1 出现的次数是：(0 + 1) * 100 = 100 次
```

总的 1 的个数 = 24 + 30 + 100 = 154 次

再以 n = 123 为例：

| 位数 | 前缀 | 当前位 | 后缀 | 计算方式 | 1 的个数 |
|-----|------|-------|------|---------|---------|
| 个位 | 12 | 3 | 0 | (12 + 1) * 1 | 13 |
| 十位 | 1 | 2 | 3 | (1 + 1) * 10 | 20 |
| 百位 | 0 | 1 | 23 | 0 * 100 + 23 + 1 | 24 |
| 总计 | - | - | - | 13 + 20 + 24 | 57 |

---

## 代码实现

完整的可运行代码：[L0233_NumberOfDigitOne.java](../src/main/java/L0233_NumberOfDigitOne.java)

```java
public int countDigitOne(int n) {
    // 记录最终的 1 的个数
    int count = 0;
    
    // 从个位开始，依次处理每一位
    for (long i = 1; i <= n; i *= 10) {
        // 计算当前位的前面的数字和后面的数字
        long prefix = n / (i * 10);
        long digit = (n / i) % 10;
        long suffix = n % i;
        
        // 根据当前位的数字，计算当前位上 1 出现的次数
        if (digit == 0) {
            // 如果当前位是 0，那么当前位上 1 出现的次数只由更高位决定
            count += prefix * i;
        } else if (digit == 1) {
            // 如果当前位是 1，那么当前位上 1 出现的次数由更高位和更低位共同决定
            count += prefix * i + suffix + 1;
        } else {
            // 如果当前位大于 1，那么当前位上 1 出现的次数由更高位决定，且要加上 i
            count += (prefix + 1) * i;
        }
    }
    
    return count;
}
```

---

## 复杂度分析

- **时间复杂度**：O(log n)
  - 需要遍历数字的每一位
  - 一个数字的位数是 log₁₀n
  - 因此时间复杂度是 O(log n)

- **空间复杂度**：O(1)
  - 只使用了几个变量来存储中间结果
  - 不需要额外的空间

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 