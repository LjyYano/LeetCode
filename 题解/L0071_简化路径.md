---
title: 简化路径
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[简化路径](https://leetcode.cn/problems/simplify-path/)  
**🏷️ 标签**：`栈` `字符串`  
**🟡 难度**：`中等`  

给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。

请注意，返回的 规范路径 必须遵循下述格式：
- 始终以斜杠 '/' 开头。
- 两个目录名之间必须只有一个斜杠 '/' 。
- 最后一个目录名（如果存在）不能 以 '/' 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。

返回简化后得到的 规范路径 。

**示例 1：**
```
输入：path = "/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。 
```

**示例 2：**
```
输入：path = "/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。
```

**示例 3：**
```
输入：path = "/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

**示例 4：**
```
输入：path = "/a/./b/../../c/"
输出："/c"
```

**提示：**
- 1 <= path.length <= 3000
- path 由英文字母，数字，'.'，'/' 或 '_' 组成。
- path 是一个有效的 Unix 风格绝对路径。

---

## 解题思路
### 栈的应用

#### 📝 核心思想
这道题的核心思想是使用栈来处理路径组件。我们需要：
1. 将路径按照 "/" 分割成多个组件
2. 遍历这些组件，根据不同情况进行处理：
   - 空字符串或 "."：跳过
   - ".."：弹出栈顶元素（返回上一级目录）
   - 其他：将组件入栈
3. 最后将栈中的元素拼接成规范路径

#### 🛠️ 实现步骤
1. 使用 split("/") 将路径分割成组件数组
2. 创建一个栈（这里使用数组模拟）来存储有效的目录名
3. 遍历每个组件：
   - 如果是空字符串或 "."，跳过
   - 如果是 ".."，且栈不为空，弹出栈顶元素
   - 如果是其他有效目录名，入栈
4. 最后将栈中的元素用 "/" 连接，构建规范路径

#### 🧩 示例分析
以 "/a/./b/../../c/" 为例，演示处理过程：

| 步骤 | 当前组件 | 操作 | 栈的内容 | 说明 |
|-----|---------|------|---------|------|
| 1 | "" | 跳过 | [] | 分割后的第一个空字符串 |
| 2 | "a" | 入栈 | ["a"] | 有效目录名 |
| 3 | "." | 跳过 | ["a"] | 当前目录，忽略 |
| 4 | "b" | 入栈 | ["a", "b"] | 有效目录名 |
| 5 | ".." | 出栈 | ["a"] | 返回上一级，移除 "b" |
| 6 | ".." | 出栈 | [] | 返回上一级，移除 "a" |
| 7 | "c" | 入栈 | ["c"] | 有效目录名 |
| 8 | "" | 跳过 | ["c"] | 最后的空字符串 |

最终结果：将栈中的元素用 "/" 连接，得到 "/c"

---

## 代码实现

完整的可运行代码：[L0071_SimplifyPath.java](../src/main/java/L0071_SimplifyPath.java)

```java
public String simplifyPath(String path) {
    // 使用 StringBuilder 来构建结果
    StringBuilder result = new StringBuilder();
    // 将路径按 "/" 分割成数组
    String[] components = path.split("/");
    // 使用 StringBuilder 数组作为栈来存储有效的目录名
    StringBuilder[] stack = new StringBuilder[components.length];
    int top = -1;  // 栈顶指针

    // 处理每个路径组件
    for (String component : components) {
        // 跳过空字符串和当前目录符号
        if (component.isEmpty() || component.equals(".")) {
            continue;
        }
        // 处理父目录符号
        if (component.equals("..")) {
            // 如果栈不为空，弹出栈顶元素（返回上一级目录）
            if (top >= 0) {
                top--;
            }
        } else {
            // 将有效的目录名入栈
            stack[++top] = new StringBuilder(component);
        }
    }

    // 如果栈为空，返回根目录
    if (top == -1) {
        return "/";
    }

    // 构建规范路径
    for (int i = 0; i <= top; i++) {
        result.append("/").append(stack[i]);
    }

    return result.toString();
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是路径字符串的长度。我们需要遍历整个字符串一次来分割路径，然后遍历所有路径组件。
- **空间复杂度**：O(n)，需要存储分割后的路径组件和栈中的目录名。在最坏情况下，路径中的每个字符都是一个有效的目录名。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 