---
title: 计算各个位数不同的数字个数
date: 2025-02-11
---

## 题目描述

**🔗 题目**：[计算各个位数不同的数字个数](https://leetcode.cn/problems/count-numbers-with-unique-digits/)  
**🏷️ 标签**：`数学` `动态规划` `回溯`  
**🟡 难度**：`中等`  

给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 <= x < 10^n 。

示例 1：
```
输入：n = 2
输出：91
解释：答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x < 100 范围内的所有数字。
```

示例 2：
```
输入：n = 0
输出：1
```

提示：
- 0 <= n <= 8

---

## 解题思路
### 排列组合法

#### 📝 核心思想
本题可以使用排列组合的思想来解决。对于一个 n 位数，我们需要考虑：
1. 每一位上的数字都必须不同
2. 第一位不能为 0（除非是单个数字 0）
3. 结果包含所有位数小于等于 n 的符合条件的数字

关键是要理解每一位数字的选择范围：
- 第一位：1-9（9 种选择）
- 第二位：可以是 0-9 中除第一位外的数字（9 种选择）
- 第三位：可以是 0-9 中除前两位外的数字（8 种选择）
- 依此类推...

#### 🛠️ 实现步骤
1. 处理特殊情况：
   - n = 0 时，只有 0 这一个数字
   - n = 1 时，有 10 个数字（0-9）

2. 对于 n > 1 的情况：
   - 初始结果为 10（包含了 n = 1 的所有情况）
   - 使用乘法原理计算每一位的组合数
   - 累加每一位的结果

3. 注意事项：
   - 当 n > 10 时，由于只有 10 个数字可选，结果与 n = 10 时相同
   - 需要考虑所有位数小于 n 的数字

#### 🧩 示例分析
以 n = 3 为例，我们来分析各个位数的情况：

1. 一位数（1-9）和零：
```
可能的数字：0, 1, 2, 3, 4, 5, 6, 7, 8, 9
总数：10
```

2. 两位数（10-99）：
| 位数 | 可选数字 | 选择数 | 累积组合数 |
|-----|---------|--------|-----------|
| 第一位 | 1-9 | 9 | 9 |
| 第二位 | 0-9 除去第一位 | 9 | 9 × 9 = 81 |

3. 三位数（100-999）：
| 位数 | 可选数字 | 选择数 | 累积组合数 |
|-----|---------|--------|-----------|
| 第一位 | 1-9 | 9 | 9 |
| 第二位 | 0-9 除去第一位 | 9 | 9 × 9 = 81 |
| 第三位 | 0-9 除去前两位 | 8 | 9 × 9 × 8 = 648 |

总结：
- 一位数及零：10 个
- 两位数：81 个
- 三位数：648 个
- 总计：10 + 81 + 648 = 739 个

对于更大的 n，我们可以继续这个模式：
- n = 4：9 × 9 × 8 × 7 个四位数
- n = 5：9 × 9 × 8 × 7 × 6 个五位数
依此类推...

---

## 代码实现

完整的可运行代码：[L0357_CountNumbersWithUniqueDigits.java](../src/main/java/L0357_CountNumbersWithUniqueDigits.java)

```java
public int countNumbersWithUniqueDigits(int n) {
    // n = 0 的情况
    if (n == 0) {
        return 1;
    }
    
    // n = 1 的情况
    if (n == 1) {
        return 10;
    }
    
    // 对于 n > 1 的情况
    // result 初始为 10，包含了 n = 1 的所有情况
    int result = 10;
    // 当前可用的数字个数（从 9 开始，因为第一位不能是 0）
    int availableNumbers = 9;
    // 当前数字的选择数（从 9 开始，因为第二位可以使用 0）
    int currentNumber = 9;
    
    // 从 n = 2 开始计算
    for (int i = 2; i <= n && i <= 10; i++) {
        currentNumber *= availableNumbers;
        result += currentNumber;
        availableNumbers--;
    }
    
    return result;
}
```

---

## 复杂度分析

- **时间复杂度**：O(min(n, 10))
  - 需要遍历从 2 到 min(n, 10) 的数字
  - 每次遍历只需要进行简单的乘法和加法运算
  - 当 n > 10 时，结果与 n = 10 时相同

- **空间复杂度**：O(1)
  - 只使用了几个变量来存储中间结果
  - 不需要额外的空间

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 