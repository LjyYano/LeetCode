---
title: 摆动序列
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)  
**🏷️ 标签**：`贪心` `动态规划`  
**🟡 难度**：`中等`  

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个摆动序列，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给你一个整数数组 nums ，返回 nums 中作为摆动序列的最长子序列的长度。

示例 1：
```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

示例 2：
```
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
```

示例 3：
```
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
```

提示：
- 1 <= nums.length <= 1000
- 0 <= nums[i] <= 1000

---

## 解题思路

### 动态规划

#### 📝 核心思想

摆动序列的关键在于相邻元素的差值正负交替。我们可以用动态规划的思想来解决这个问题：
1. 对于每个位置 i，我们需要知道以它结尾的最长摆动序列的长度
2. 由于差值要正负交替，我们需要分别记录以当前位置结尾的上升摆动序列和下降摆动序列的长度
3. 当遇到一个新的数字时，我们可以根据它与前一个数字的大小关系来更新这两个状态

#### 🛠️ 实现步骤

1. 初始化状态：
   - up：表示以当前位置结尾的最长上升摆动序列的长度
   - down：表示以当前位置结尾的最长下降摆动序列的长度
   - 初始值都为 1（单个元素也是摆动序列）

2. 状态转移：
   - 如果当前数字大于前一个数字：可以接在一个下降序列后面形成上升序列
   - 如果当前数字小于前一个数字：可以接在一个上升序列后面形成下降序列
   - 如果相等：保持不变

3. 返回结果：
   - 返回 up 和 down 中的较大值

#### 🧩 示例分析

以输入序列 [1,7,4,9,2,5] 为例：

| 位置 | 数字 | 与前一个数的关系 | up | down | 说明 |
|-----|-----|---------------|-----|------|-----|
| 0 | 1 | - | 1 | 1 | 初始状态 |
| 1 | 7 | 上升 | 2 | 1 | 可以形成上升序列 |
| 2 | 4 | 下降 | 2 | 3 | 可以接在上升序列后形成下降序列 |
| 3 | 9 | 上升 | 4 | 3 | 可以接在下降序列后形成上升序列 |
| 4 | 2 | 下降 | 4 | 5 | 可以接在上升序列后形成下降序列 |
| 5 | 5 | 上升 | 6 | 5 | 可以接在下降序列后形成上升序列 |

最终结果为 max(up, down) = 6。

---

## 代码实现

完整的可运行代码：[L0376_WiggleSubsequence.java](../src/main/java/L0376_WiggleSubsequence.java)

```java
public int wiggleMaxLength(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    if (nums.length == 1) {
        return 1;
    }
    
    // up[i] 表示以 nums[i] 结尾的最长上升摆动序列的长度
    // down[i] 表示以 nums[i] 结尾的最长下降摆动序列的长度
    int up = 1, down = 1;
    
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > nums[i - 1]) {
            // 当前数字大于前一个数字，可以接在一个下降序列后面形成上升序列
            up = down + 1;
        } else if (nums[i] < nums[i - 1]) {
            // 当前数字小于前一个数字，可以接在一个上升序列后面形成下降序列
            down = up + 1;
        }
    }
    
    return Math.max(up, down);
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组的长度。我们只需要遍历一次数组。
- **空间复杂度**：O(1)，只使用了两个变量来存储状态。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 