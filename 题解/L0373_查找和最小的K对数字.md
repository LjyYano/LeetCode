---
title: 查找和最小的 K 对数字
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)  
**🏷️ 标签**：`数组` `堆（优先队列）`  
**🟡 难度**：`中等`  

给定两个以 非递减顺序 排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。

请找到和最小的 k 个数对 (u1,v1), (u2,v2) ... (uk,vk) 。

示例 1:
```
输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [[1,2],[1,4],[1,6]]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```

示例 2:
```
输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出: [[1,1],[1,1]]
解释: 返回序列中的前 2 对数：
     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
```

示例 3:
```
输入: nums1 = [1,2], nums2 = [3], k = 3
输出: [[1,3],[2,3]]
解释: 也可能序列中所有的数对都被返回: [[1,3],[2,3]]
```

提示:
- 1 <= nums1.length, nums2.length <= 10⁵
- -10⁹ <= nums1[i], nums2[i] <= 10⁹
- nums1 和 nums2 均为升序排列
- 1 <= k <= 10⁴

---

## 解题思路
### 优先队列（小顶堆）

#### 📝 核心思想
本题的关键是利用两个数组已经排序的特性，使用优先队列（小顶堆）来维护当前可能的最小和的数对。我们可以观察到：

1. 由于两个数组都是升序的，对于 nums1[i]，与 nums2[0] 组成的数对一定是该行最小的
2. 每次从优先队列中取出最小和的数对后，我们只需要考虑将该数对对应的下一个数对加入队列
3. 使用优先队列可以保证每次都能获取到当前最小和的数对

#### 🛠️ 实现步骤
1. 初始化：
   - 创建一个小顶堆（优先队列），用于存储三元组 (sum, i, j)
   - 将 nums1 中的每个数与 nums2[0] 组成的数对加入队列

2. 循环处理：
   - 每次从队列中取出和最小的数对
   - 将该数对加入结果集
   - 如果该数对对应的 nums2 还有下一个数，将新的数对加入队列

3. 终止条件：
   - 找到 k 个数对
   - 或者队列为空（所有可能的数对都已处理）

#### 🧩 示例分析
以示例 1 为例，nums1 = [1,7,11], nums2 = [2,4,6], k = 3：

1. 初始化优先队列：
```
队列：[(3,0,0), (9,1,0), (13,2,0)]
解释：(和,i,j) = (1+2,0,0), (7+2,1,0), (11+2,2,0)
结果：[]
```

2. 第一次取出 (3,0,0)：
```
加入结果：[1,2]
加入队列：(5,0,1) // 1+4
队列：[(5,0,1), (9,1,0), (13,2,0)]
```

3. 第二次取出 (5,0,1)：
```
加入结果：[1,4]
加入队列：(7,0,2) // 1+6
队列：[(7,0,2), (9,1,0), (13,2,0)]
```

4. 第三次取出 (7,0,2)：
```
加入结果：[1,6]
队列：[(9,1,0), (13,2,0)]
完成：已找到 3 个数对
```

最终结果：[[1,2], [1,4], [1,6]]

为什么这样做是正确的？
1. 由于数组是升序的，对于每个 nums1[i]，其与 nums2 组成的数对的和也是升序的
2. 使用优先队列可以保证每次都能取到当前最小的和
3. 只有当取出一个数对时，才需要考虑该位置的下一个数对，这样可以避免生成所有可能的数对

---

## 代码实现

完整的可运行代码：[L0373_FindKPairsWithSmallestSums.java](../src/main/java/L0373_FindKPairsWithSmallestSums.java)

```java
public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
    List<List<Integer>> result = new ArrayList<>();
    if (nums1 == null || nums2 == null || nums1.length == 0 || nums2.length == 0 || k <= 0) {
        return result;
    }
    
    // 使用优先队列（小顶堆）存储三元组 (sum, i, j)
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
    
    // 将所有 nums1 中的数和 nums2[0] 的组合加入队列
    for (int i = 0; i < nums1.length && i < k; i++) {
        pq.offer(new int[]{nums1[i] + nums2[0], i, 0});
    }
    
    // 循环 k 次或直到队列为空
    while (k > 0 && !pq.isEmpty()) {
        int[] curr = pq.poll();
        int i = curr[1];
        int j = curr[2];
        
        // 将当前组合加入结果集
        result.add(Arrays.asList(nums1[i], nums2[j]));
        
        // 如果还有下一个数，将新组合加入队列
        if (j + 1 < nums2.length) {
            pq.offer(new int[]{nums1[i] + nums2[j + 1], i, j + 1});
        }
        
        k--;
    }
    
    return result;
}
```

---

## 复杂度分析

- **时间复杂度**：O(k log k)
  - 初始化优先队列需要 O(min(k, n) log k) 时间，其中 n 是 nums1 的长度
  - 每次从队列中取出和插入元素需要 O(log k) 时间
  - 总共需要进行 k 次操作
  - 因此总时间复杂度为 O(k log k)

- **空间复杂度**：O(k)
  - 优先队列中最多存储 k 个元素
  - 结果数组需要存储 k 个数对
  - 因此总空间复杂度为 O(k)

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 