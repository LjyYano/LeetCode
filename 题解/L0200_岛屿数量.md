---
title: 岛屿数量
date: 2024-03-27
---

## 题目描述

**🔗 题目**：[岛屿数量](https://leetcode.cn/problems/number-of-islands/)  
**🏷️ 标签**：`深度优先搜索` `广度优先搜索` `并查集` `数组` `矩阵`  
**🟡 难度**：`中等`  

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。

**示例 1：**
```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**
```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示：**
- m == grid.length
- n == grid[i].length
- 1 <= m, n <= 300
- grid[i][j] 的值为 '0' 或 '1'

---

## 解题思路

### 深度优先搜索（DFS）

#### 📝 核心思想
这是一道经典的图论问题，可以使用深度优先搜索（DFS）来解决。核心思想是：遍历整个二维网格，每当遇到一个陆地（'1'）时，就从这个位置开始进行 DFS，将所有相连的陆地都标记为已访问（改为 '0'），这样一次 DFS 就能覆盖一整个岛屿。每次开始新的 DFS 时，岛屿数量就加 1。

#### 🛠️ 实现步骤
1. 遍历整个二维网格：
   - 使用双层循环遍历每个位置

2. 遇到陆地时进行 DFS：
   - 如果当前位置是 '1'（陆地），岛屿计数加 1
   - 从当前位置开始进行 DFS，将所有相连的陆地标记为 '0'

3. DFS 递归过程：
   - 检查边界条件和当前位置是否为陆地
   - 将当前位置标记为 '0'（已访问）
   - 递归访问上下左右四个方向

4. 返回结果：
   - 返回岛屿计数

#### 🧩 示例分析
以示例 1 为例：
```
初始网格：
1 1 1 1 0
1 1 0 1 0
1 1 0 0 0
0 0 0 0 0
```

遍历过程：
1. 在 (0,0) 位置发现陆地 '1'，岛屿计数 = 1
2. 从 (0,0) 开始 DFS，访问所有相连的 '1'：
   ```
   访问 (0,0) -> (0,1) -> (0,2) -> (0,3) -> (1,0) -> (1,1) -> (2,0) -> (2,1) -> (1,3)
   ```
3. DFS 完成后，所有相连的陆地都被标记为 '0'：
   ```
   0 0 0 0 0
   0 0 0 0 0
   0 0 0 0 0
   0 0 0 0 0
   ```
4. 继续遍历剩余网格，没有发现新的陆地
5. 最终返回岛屿数量 = 1

### 其他解法

#### 广度优先搜索（BFS）
使用队列实现 BFS，每次遇到陆地时，将其加入队列，然后不断从队列中取出元素，访问其上下左右四个方向的相邻位置。

#### 并查集
将每个陆地作为并查集中的一个节点，相邻的陆地合并到同一个集合中，最后统计集合的数量即为岛屿数量。

---

## 代码实现

完整的可运行代码：[L0200_NumberOfIslands.java](../src/main/java/L0200_NumberOfIslands.java)

```java
public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) {
        return 0;
    }
    
    int rows = grid.length;
    int cols = grid[0].length;
    int count = 0;
    
    // 遍历整个网格
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            // 如果当前位置是陆地，进行 DFS
            if (grid[i][j] == '1') {
                count++;
                dfs(grid, i, j);
            }
        }
    }
    
    return count;
}

private void dfs(char[][] grid, int i, int j) {
    int rows = grid.length;
    int cols = grid[0].length;
    
    // 边界检查
    if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == '0') {
        return;
    }
    
    // 标记当前位置为已访问
    grid[i][j] = '0';
    
    // 递归访问四个方向
    dfs(grid, i - 1, j); // 上
    dfs(grid, i + 1, j); // 下
    dfs(grid, i, j - 1); // 左
    dfs(grid, i, j + 1); // 右
}
```

---

## 复杂度分析

- **时间复杂度**：O(m × n)
  - 其中 m 和 n 分别是网格的行数和列数
  - 最坏情况下，整个网格都是陆地，需要访问每个格子一次

- **空间复杂度**：O(m × n)
  - 最坏情况下，递归深度可以达到 m × n（整个网格都是陆地且呈现蛇形排列）
  - 实际情况下，递归深度取决于最大岛屿的大小

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。
