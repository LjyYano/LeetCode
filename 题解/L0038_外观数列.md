---
title: 外观数列
date: 2024-03-26
---

## 题目描述

**🔗 题目**：[外观数列](https://leetcode.cn/problems/count-and-say/)  
**🏷️ 标签**：`字符串`  
**🟡 难度**：`中等`  

「外观数列」是一个数位字符串序列，由递归公式定义：

- countAndSay(1) = "1"
- countAndSay(n) 是 countAndSay(n-1) 的行程长度编码。

行程长度编码（RLE）是一种字符串压缩方法，其工作原理是通过连续相同字符（重复两次或更多次）替换为字符重复次数（这行长度）和字符的组合。例如，要压缩字符串 "3322251"，我们将 "33" 用 "23" 替换，将 "222" 用 "32" 替换，将 "5" 用 "15" 替换并将 "1" 用 "11" 替换。因此压缩后的字符串变为 "23321511"。

给定一个整数 n，返回外观数列的第 n 项。

**示例 1：**
```
输入：n = 4
输出："1211"
解释：
countAndSay(1) = "1"
countAndSay(2) = "1" 的行程长度编码 = "11"
countAndSay(3) = "11" 的行程长度编码 = "21"
countAndSay(4) = "21" 的行程长度编码 = "1211"
```

**示例 2：**
```
输入：n = 1
输出："1"
解释：这是一个基本情况。
```

**提示：**
- `1 <= n <= 30`

---

## 解题思路

### 递归算法

#### 📝 核心思想

外观数列的核心在于对前一项进行描述。我们可以使用递归的方法来解决这个问题：
1. 基础情况是 n = 1 时返回 "1"
2. 对于其他情况，我们需要先得到前一项，然后对其进行描述
3. 描述的规则是：统计连续相同的数字个数，然后用"个数+数字"的形式表示

#### 🛠️ 实现步骤

1. 处理基础情况：n = 1 时返回 "1"
2. 递归获取 n-1 项的字符串
3. 遍历前一项字符串，统计连续相同字符的个数：
   - 使用计数器记录当前字符出现的次数
   - 当遇到不同的字符时，将当前计数和字符加入结果
   - 重置计数器，更新当前字符
4. 处理最后一组字符的计数

#### 🧩 示例分析

让我们以 n = 4 为例，看看算法是如何工作的：

1. 第一步：n = 1
   ```
   直接返回 "1"
   ```

2. 第二步：n = 2，描述 "1"
   ```
   当前字符串：1
   统计：一个 1
   结果："11"
   ```

3. 第三步：n = 3，描述 "11"
   ```
   当前字符串：11
   统计：两个 1
   结果："21"
   ```

4. 第四步：n = 4，描述 "21"
   ```
   当前字符串：21
   统计：一个 2，一个 1
   结果："1211"
   ```

---

## 代码实现

完整的可运行代码：[L0038_CountAndSay.java](../src/main/java/L0038_CountAndSay.java)

```java
public String countAndSay(int n) {
    // 基本情况
    if (n == 1) {
        return "1";
    }
    
    // 递归获取前一个字符串
    String prev = countAndSay(n - 1);
    StringBuilder result = new StringBuilder();
    
    // 计数当前字符出现次数
    int count = 1;
    char currentChar = prev.charAt(0);
    
    // 遍历前一个字符串
    for (int i = 1; i < prev.length(); i++) {
        if (prev.charAt(i) == currentChar) {
            count++;
        } else {
            // 添加当前字符的计数和字符本身
            result.append(count).append(currentChar);
            // 重置计数器，更新当前字符
            currentChar = prev.charAt(i);
            count = 1;
        }
    }
    
    // 添加最后一组字符的计数
    result.append(count).append(currentChar);
    
    return result.toString();
}
```

---

## 复杂度分析

- **时间复杂度**：O(2ⁿ)，因为每一项的长度可能是前一项的两倍。
- **空间复杂度**：O(2ⁿ)，需要存储递归调用的字符串。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 