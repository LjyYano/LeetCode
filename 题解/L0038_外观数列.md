# 38. 外观数列

- 难度：中等
- 标签：字符串
- 链接：https://leetcode.cn/problems/count-and-say/

## 题目描述

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：

1. 1
2. 11
3. 21
4. 1211
5. 111221

第一项是数字 1 
描述前一项，这个数是 1 即 "一个 1 "，记作 "11"
描述前一项，这个数是 11 即 "二个 1 " ，记作 "21"
描述前一项，这个数是 21 即 "一个 2 + 一个 1" ，记作 "1211"
描述前一项，这个数是 1211 即 "一个 1 + 一个 2 + 二个 1" ，记作 "111221"

给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。

## 解题思路

这道题可以使用递归的方法来解决。关键点在于理解每一项都是对前一项的描述，我们需要：

1. 首先获取前一项的字符串（通过递归）
2. 然后统计前一项字符串中连续相同字符的个数
3. 最后按照"个数+字符"的格式生成当前项

具体步骤：

1. 基本情况：当 n = 1 时，直接返回 "1"
2. 递归获取 n-1 项的字符串
3. 遍历 n-1 项的字符串，统计连续相同字符的个数：
   - 使用计数器记录当前字符出现的次数
   - 当遇到不同的字符时，将当前计数和字符加入结果
   - 重置计数器，更新当前字符
4. 最后不要忘记处理最后一组字符

时间复杂度：O(2^n)，因为每一项的长度可能是前一项的两倍
空间复杂度：O(2^n)，需要存储递归调用的字符串

## 代码实现

```java
public class L0038_CountAndSay {
    public String countAndSay(int n) {
        // 基本情况
        if (n == 1) {
            return "1";
        }
        
        // 递归获取前一个字符串
        String prev = countAndSay(n - 1);
        StringBuilder result = new StringBuilder();
        
        // 计数当前字符出现次数
        int count = 1;
        char currentChar = prev.charAt(0);
        
        // 遍历前一个字符串
        for (int i = 1; i < prev.length(); i++) {
            if (prev.charAt(i) == currentChar) {
                count++;
            } else {
                // 添加当前字符的计数和字符本身
                result.append(count).append(currentChar);
                // 重置计数器，更新当前字符
                currentChar = prev.charAt(i);
                count = 1;
            }
        }
        
        // 添加最后一组字符的计数
        result.append(count).append(currentChar);
        
        return result.toString();
    }
}
```

## 示例分析

以 n = 4 为例，让我们看看代码是如何工作的：

1. n = 1: 返回 "1"
2. n = 2: 描述 "1" => "11" (1个1)
3. n = 3: 描述 "11" => "21" (2个1)
4. n = 4: 描述 "21" => "1211" (1个2,1个1)

每一步都是对前一个数的描述，通过递归和字符计数，我们可以正确生成序列中的每一项。 