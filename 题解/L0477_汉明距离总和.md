---
title: 汉明距离总和
date: 2024-02-12
---

## 题目描述

**🔗 题目**：[477. 汉明距离总和](https://leetcode.cn/problems/total-hamming-distance/)  
**🏷️ 标签**：`位运算` `数组` `数学`  
**🟡 难度**：`中等`  

两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。

给你一个整数数组 `nums`，请你计算并返回 `nums` 中任意两个数之间 汉明距离的总和 。

**示例 1：**
```
输入：nums = [4,14,2]
输出：6
解释：在二进制表示中，4 表示为 0100 ，14 表示为 1110 ，2表示为 0010 。（这样表示是为了体现后四位之间关系）
所以答案为：
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6
```

**示例 2：**
```
输入：nums = [4,14,4]
输出：4
```

**提示：**
- `1 <= nums.length <= 10^4`
- `0 <= nums[i] <= 10^9`

---

## 解题思路

### 按位统计法

#### 📝 核心思想
如果暴力计算每两个数之间的汉明距离，时间复杂度会达到 O(n²)，这对于大数据量来说是不可接受的。

关键观察：对于某一位，如果这一位上有 `k` 个 1 和 `(n-k)` 个 0，那么这一位对总汉明距离的贡献就是 `k * (n-k)`。

#### 🛠️ 实现步骤
1. 遍历 32 位（因为整数最大为 10^9，不超过 32 位）
2. 对于每一位，统计数组中有多少个数在这一位上是 1
3. 如果有 k 个 1，那么就有 (n-k) 个 0，这一位的贡献就是 k * (n-k)
4. 累加所有位的贡献

#### 🧩 示例分析
以示例 1 为例：`nums = [4,14,2]`

```
数字    二进制表示
4      0100
14     1110
2      0010
```

- 第 0 位（从右往左）：0个1，3个0，贡献 = 0 * 3 = 0
- 第 1 位：3个1，0个0，贡献 = 3 * 0 = 0
- 第 2 位：1个1，2个0，贡献 = 1 * 2 = 2
- 第 3 位：1个1，2个0，贡献 = 1 * 2 = 2
- 第 4 位及以上：均为0

总和 = 0 + 0 + 2 + 2 = 4... 等等，让我重新计算：

```
4  = 0100
14 = 1110
2  = 0010

第0位：0,0,0 -> 0个1, 3个0 -> 0*3=0
第1位：0,1,1 -> 2个1, 1个0 -> 2*1=2
第2位：1,1,0 -> 2个1, 1个0 -> 2*1=2
第3位：0,1,0 -> 1个1, 2个0 -> 1*2=2
```

总和 = 0 + 2 + 2 + 2 = 6 ✓

---

## 代码实现

```java
public class L0477_TotalHammingDistance {
    public int totalHammingDistance(int[] nums) {
        int n = nums.length;
        int ans = 0;
        
        // 遍历 32 位
        for (int i = 0; i < 32; i++) {
            int count1 = 0;
            // 统计第 i 位上有多少个 1
            for (int num : nums) {
                count1 += (num >> i) & 1;
            }
            // 第 i 位的贡献：count1 个 1 和 (n - count1) 个 0
            ans += count1 * (n - count1);
        }
        
        return ans;
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(32n) = O(n)，其中 n 是数组长度。需要遍历 32 位，每位需要遍历一次数组。
- **空间复杂度**：O(1)，只使用了常数额外空间。

---

## 相关题目

- [🔗 461. 汉明距离](https://leetcode.cn/problems/hamming-distance/)
- [🔗 191. 位1的个数](https://leetcode.cn/problems/number-of-1-bits/)

---

## 总结

这道题是位运算的经典应用。解题的关键在于：
1. 避免暴力计算所有数对的汉明距离（会超时）
2. 观察到可以按位统计，每一位独立计算贡献
3. 理解组合数学：k 个 1 和 (n-k) 个 0 配对的次数

通过这道题，我们可以学习到：
1. 如何优化暴力算法，从 O(n²) 降到 O(n)
2. 位运算在处理二进制问题时的技巧
3. 按位处理的思想在其他问题中也很常见

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 