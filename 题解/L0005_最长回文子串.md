---
title: 最长回文子串
date: 2024-02-06
---

## 题目描述

**🔗 题目**：[最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)  
**🏷️ 标签**：`字符串` `动态规划`  
**🟡 难度**：`中等`  

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

**示例 1：**
```
输入：s = "babad"
输出："bab"
解释："aba" 也是一个有效答案。
```

**示例 2：**
```
输入：s = "cbbd"
输出："bb"
```

**提示：**
- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成

---

## 解题思路

### 中心扩展法

#### 📝 核心思想
从字符串的每个位置开始，向两边扩展，寻找以该位置为中心的最长回文子串。需要考虑回文串长度为奇数和偶数两种情况。

#### 🛠️ 实现步骤
1. 特殊情况处理：字符串为空或长度小于 2 时，直接返回原字符串
2. 遍历字符串的每个字符，以其为中心：
   - 处理奇数长度的回文串：以当前字符为中心向两边扩展
   - 处理偶数长度的回文串：以当前字符和下一个字符为中心向两边扩展
3. 记录并更新最长回文子串的起始位置和长度
4. 返回最长的回文子串

#### 🧩 示例分析
以 `s = "babad"` 为例：

```text
遍历位置 i = 0 ('b'):
  奇数扩展：[b] -> 长度 1
  偶数扩展：[b|a] -> 不是回文串

遍历位置 i = 1 ('a'):
  奇数扩展：[bab] -> 长度 3
  偶数扩展：[a|b] -> 不是回文串

遍历位置 i = 2 ('b'):
  奇数扩展：[aba] -> 长度 3
  偶数扩展：[b|a] -> 不是回文串

遍历位置 i = 3 ('a'):
  奇数扩展：[a] -> 长度 1
  偶数扩展：[a|d] -> 不是回文串

遍历位置 i = 4 ('d'):
  奇数扩展：[d] -> 长度 1
  偶数扩展：超出范围

最长回文子串："bab" 或 "aba"，长度为 3
```

---

## 代码实现

完整的可运行代码：[L0005_LongestPalindromicSubstring.java](../src/main/java/L0005_LongestPalindromicSubstring.java)

```java
public String longestPalindrome(String s) {
    if (s == null || s.length() < 2) {
        return s;
    }
    
    // 记录最长回文子串的起始位置和长度
    int start = 0;
    int maxLength = 1;
    
    // 遍历每个可能的中心点
    for (int i = 0; i < s.length(); i++) {
        // 以当前字符为中心的奇数长度回文串
        int len1 = expandAroundCenter(s, i, i);
        // 以当前字符和下一个字符为中心的偶数长度回文串
        int len2 = expandAroundCenter(s, i, i + 1);
        
        // 更新最长回文子串的信息
        int len = Math.max(len1, len2);
        if (len > maxLength) {
            start = i - (len - 1) / 2;
            maxLength = len;
        }
    }
    
    return s.substring(start, start + maxLength);
}

/**
 * 从中心向两边扩展，寻找最长回文子串
 * @param s 原始字符串
 * @param left 左边界
 * @param right 右边界
 * @return 以 left 和 right 为中心的最长回文子串的长度
 */
private int expandAroundCenter(String s, int left, int right) {
    // 当左右指针都在有效范围内，且对应的字符相等时，继续扩展
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        left--;
        right++;
    }
    // 返回回文串的长度
    return right - left - 1;
}
```

---

## 复杂度分析

- **时间复杂度**：`O(n²)`，其中 n 是字符串的长度。对于每个中心位置，我们需要进行中心扩展，最坏情况下需要扩展到字符串的两端。
- **空间复杂度**：`O(1)`，我们只需要常数级别的额外空间来存储变量。

---

## LeetCode 题解

[LeetCode 最全题解](https://github.com/LjyYano/LeetCode) 