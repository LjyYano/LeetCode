---
title: 合并K个升序链表
date: 2025-02-08
---

## 题目描述

**🔗 题目**：[合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)  
**🏷️ 标签**：`链表` `分治` `堆（优先队列）` `归并排序`  
**🔴 难度**：`困难`  

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**
```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**
```
输入：lists = []
输出：[]
```

**示例 3：**
```
输入：lists = [[]]
输出：[]
```

**提示：**
- `k == lists.length`
- `0 <= k <= 10⁴`
- `0 <= lists[i].length <= 500`
- `-10⁴ <= lists[i][j] <= 10⁴`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10⁴`

---

## 解题思路

### 优先队列法

#### 📝 核心思想
使用最小堆（优先队列）来维护 k 个链表的当前最小节点。每次从堆中取出最小的节点加入结果链表，并将该节点的下一个节点（如果存在）加入堆中。

#### 🛠️ 实现步骤
1. 创建一个最小堆，用于存储节点，按节点值排序
2. 将 k 个链表的头节点加入堆中
3. 循环执行以下操作直到堆为空：
   - 取出堆顶节点（最小值）加入结果链表
   - 如果该节点有下一个节点，将其加入堆中
4. 返回结果链表

#### 🧩 示例分析
以示例 1 为例，展示合并过程：

**1. 初始状态**
```text
链表 1：[1] -> 4 -> 5
链表 2：[1] -> 3 -> 4
链表 3：[2] -> 6

最小堆：[1, 1, 2]
结果链表：null
```

**2. 合并过程**

| 步骤 | 最小堆 | 出堆节点 | 入堆节点 | 结果链表 | 说明 |
|-----|--------|---------|----------|----------|-----|
| 1 | [1,1,2] | 1 | 4 | 1 | 取链表 1 的 1，加入 4 |
| 2 | [1,2,4] | 1 | 3 | 1->1 | 取链表 2 的 1，加入 3 |
| 3 | [2,3,4] | 2 | 6 | 1->1->2 | 取链表 3 的 2，加入 6 |
| 4 | [3,4,4,6] | 3 | 4 | 1->1->2->3 | 取链表 2 的 3，加入 4 |
| 5 | [4,4,4,6] | 4 | 5 | 1->1->2->3->4 | 取链表 1 的 4，加入 5 |
| 6 | [4,5,6] | 4 | null | 1->1->2->3->4->4 | 取链表 2 的 4 |
| 7 | [5,6] | 5 | null | 1->1->2->3->4->4->5 | 取链表 1 的 5 |
| 8 | [6] | 6 | null | 1->1->2->3->4->4->5->6 | 取链表 3 的 6 |

**3. 图形化展示**
```text
步骤 1：
堆顶：1 (来自链表 1)
链表 1：1 -> [4] -> 5     ↘
链表 2：[1] -> 3 -> 4      → 1
链表 3：[2] -> 6          ↗

步骤 2：
堆顶：1 (来自链表 2)
链表 1：4 -> [5]          ↘
链表 2：1 -> [3] -> 4      → 1 -> 1
链表 3：[2] -> 6          ↗

步骤 3：
堆顶：2 (来自链表 3)
链表 1：[4] -> 5          ↘
链表 2：[3] -> 4           → 1 -> 1 -> 2
链表 3：2 -> [6]          ↗

... 以此类推
```

这个合并过程展示了：
1. 最小堆始终维护当前可选的最小节点
2. 每次从堆中取出最小值，加入结果链表
3. 取出节点后，将其下一个节点加入堆中
4. 重复这个过程直到所有节点都被处理

---

## 代码实现

完整的可运行代码：[L0023_MergeKSortedLists.java](../src/main/java/L0023_MergeKSortedLists.java)

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }
        
        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);
        for (ListNode list : lists) {
            if (list != null) {
                minHeap.offer(list);
            }
        }
        
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        while (!minHeap.isEmpty()) {
            ListNode node = minHeap.poll();
            curr.next = node;
            curr = curr.next;
            
            if (node.next != null) {
                minHeap.offer(node.next);
            }
        }
        
        return dummy.next;
    }
}
```

---

## 复杂度分析

- **时间复杂度**：`O(N log k)`，其中 N 是所有节点的总数，k 是链表的数量。每个节点都要经过一次入堆和出堆操作，每次堆操作的时间复杂度是 O(log k)
- **空间复杂度**：`O(k)`，优先队列中最多存储 k 个节点

---

## LeetCode 题解

[LeetCode 最全题解](https://github.com/LjyYano/LeetCode) 