# 80. 删除有序数组中的重复项 II

## 题目描述

给你一个有序数组 nums ，请你原地删除重复出现的元素，使得出现次数超过两次的元素只出现两次，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

## 解题思路

这道题是 [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/) 的变种，区别在于本题允许重复元素最多出现两次，而不是一次。

我们可以使用双指针的方法来解决：
1. 使用快慢指针，慢指针 slow 指向当前可以放置元素的位置，快指针 fast 用于遍历数组
2. 由于允许重复元素最多出现两次，我们可以从索引 2 开始遍历数组
3. 对于每个位置，我们将当前元素与 slow-2 位置的元素进行比较：
   - 如果它们不相同，说明当前元素最多只会是第二次出现，可以放置到 slow 位置
   - 如果它们相同，说明当前元素已经出现了两次，应该跳过
4. 最后返回 slow，即为新数组的长度

### 为什么从索引 2 开始？
- 因为数组是有序的，且允许元素最多出现两次
- 前两个元素必然是有效的（即使它们相同），所以我们可以从第三个元素开始处理
- 通过比较当前元素与 slow-2 位置的元素，我们可以判断当前元素是否是第三次出现

## 复杂度分析

- 时间复杂度：O(n)，其中 n 是数组的长度。我们只需要遍历一次数组。
- 空间复杂度：O(1)，我们只使用了常数额外空间。

## 代码实现

```java
public int removeDuplicates(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    // 数组长度小于等于 2，不需要处理
    if (nums.length <= 2) {
        return nums.length;
    }
    // 慢指针，指向当前可以放置元素的位置
    int slow = 2;
    // 快指针，用于遍历数组
    for (int fast = 2; fast < nums.length; fast++) {
        // 如果当前元素与倒数第二个元素不同，说明可以放置
        if (nums[fast] != nums[slow - 2]) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    return slow;
}
```

## 示例分析

以输入数组 `nums = [1,1,1,2,2,3]` 为例，执行过程如下：

1. 初始状态：
   - nums = [1,1,1,2,2,3]
   - slow = 2, fast = 2

2. fast = 2 时：
   - nums[2] = 1, nums[0] = 1
   - 由于相等，跳过

3. fast = 3 时：
   - nums[3] = 2, nums[1] = 1
   - 不相等，将 2 放入 slow 位置
   - nums = [1,1,2,2,2,3]
   - slow = 3

4. fast = 4 时：
   - nums[4] = 2, nums[2] = 2
   - 由于相等，跳过

5. fast = 5 时：
   - nums[5] = 3, nums[3] = 2
   - 不相等，将 3 放入 slow 位置
   - nums = [1,1,2,2,3,3]
   - slow = 4

6. 最终返回 slow = 5，表示新数组长度为 5
   - 结果数组前 5 个元素为：[1,1,2,2,3]

## 相关题目

- [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)
- [27. 移除元素](https://leetcode.cn/problems/remove-element/)

## GitHub LeetCode 题解

[LeetCode 题解仓库](https://github.com/LjyYano/LeetCode) 