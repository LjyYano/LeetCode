---
title: 删除有序数组中的重复项 II
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)  
**🏷️ 标签**：`数组` `双指针`  
**🟡 难度**：`中等`  

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

示例 1：
```
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。不需要考虑数组中超出新长度后面的元素。
```

示例 2：
```
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。
```

提示：
- 1 <= nums.length <= 3 * 10⁴
- -10⁴ <= nums[i] <= 10⁴
- nums 已按升序排列

---

## 解题思路
### 双指针法

#### 📝 核心思想
本题使用双指针法来解决。由于数组已经排序，我们可以使用快慢指针来处理重复元素。关键是要保证每个元素最多出现两次。

主要思路如下：
1. 使用快慢指针，慢指针 slow 指向当前可以放置元素的位置
2. 从索引 2 开始遍历数组（因为前两个元素一定是有效的）
3. 通过比较当前元素与 slow-2 位置的元素来判断是否可以放置新元素

#### 🛠️ 实现步骤
1. 处理边界情况：
   - 如果数组为空或长度为 0，返回 0
   - 如果数组长度小于等于 2，直接返回数组长度

2. 初始化指针：
   - 慢指针 slow 从索引 2 开始
   - 快指针 fast 也从索引 2 开始

3. 遍历数组：
   - 比较 nums[fast] 和 nums[slow-2]
   - 如果不相等，说明当前元素可以放置
   - 将当前元素放入 slow 位置，并移动 slow 指针

4. 返回结果：
   - 返回 slow，即为新数组的长度

#### 🧩 示例分析
以示例 1 为例，分析整个过程：
```
输入：nums = [1,1,1,2,2,3]
```

| 步骤 | 数组状态 | slow | fast | nums[fast] | nums[slow-2] | 操作 |
|-----|---------|------|------|------------|--------------|------|
| 1 | [1,1,1,2,2,3] | 2 | 2 | 1 | 1 | 跳过 |
| 2 | [1,1,1,2,2,3] | 2 | 3 | 2 | 1 | 放置 2 |
| 3 | [1,1,2,2,2,3] | 3 | 4 | 2 | 1 | 放置 2 |
| 4 | [1,1,2,2,2,3] | 4 | 5 | 3 | 2 | 放置 3 |
| 5 | [1,1,2,2,3,3] | 5 | 6 | - | - | 结束 |

最终返回 slow = 5，表示新数组的前 5 个元素为 [1,1,2,2,3]。

---

## 代码实现

完整的可运行代码：[L0080_RemoveDuplicatesFromSortedArrayII.java](../src/main/java/L0080_RemoveDuplicatesFromSortedArrayII.java)

```java
public int removeDuplicates(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    // 数组长度小于等于 2，不需要处理
    if (nums.length <= 2) {
        return nums.length;
    }
    // 慢指针，指向当前可以放置元素的位置
    int slow = 2;
    // 快指针，用于遍历数组
    for (int fast = 2; fast < nums.length; fast++) {
        // 如果当前元素与倒数第二个元素不同，说明可以放置
        if (nums[fast] != nums[slow - 2]) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    return slow;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组的长度。我们只需要遍历一次数组。
- **空间复杂度**：O(1)，只使用了常数额外空间。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 