---
title: 缺失的第一个正数
date: 2025-02-08
---

## 题目描述

**🔗 题目**：[缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)  
**🏷️ 标签**：`数组` `原地哈希`  
**🔴 难度**：`困难`  

给你一个未排序的整数数组 nums，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

示例 1：
```
输入：nums = [1,2,0]
输出：3
解释：数字 1 和 2 都出现了，所以最小的缺失正数是 3
```

示例 2：
```
输入：nums = [3,4,-1,1]
输出：2
解释：数字 1、3、4 都出现了，所以最小的缺失正数是 2
```

示例 3：
```
输入：nums = [7,8,9,11,12]
输出：1
解释：最小的正数 1 没有出现，所以返回 1
```

---

## 解题思路
### 原地哈希

#### 📝 核心思想
1. 对于长度为 n 的数组，缺失的第一个正数一定在 [1, n+1] 范围内
2. 利用数组的索引作为哈希表，将数字放到正确的位置上
3. 通过正负号标记数字的出现情况，避免使用额外空间

#### 🛠️ 实现步骤
1. 第一步：将所有负数和零修改为 n+1
   - 因为我们只关心 1 到 n 范围内的数
   - n+1 作为一个标记值，表示这个位置原来是负数或零

2. 第二步：将数组中的每个数对应的位置标记为负数
   - 遍历数组，对于每个数 x，将 nums[x-1] 标记为负数
   - 如果 nums[x-1] 已经是负数，说明 x 已经出现过
   - 只处理 1 到 n 范围内的数

3. 第三步：找到第一个正数的位置
   - 再次遍历数组，找到第一个正数的位置 i
   - 返回 i+1，因为这说明数字 i+1 没有出现过
   - 如果所有数都是负数，说明 1 到 n 都出现了，返回 n+1

#### 🧩 示例分析
以 nums = [3,4,-1,1] 为例：

| 步骤 | 操作 | 数组状态 | 说明 |
|-----|------|---------|-----|
| 初始 | - | [3,4,-1,1] | 原始数组 |
| 第一步 | 替换负数和零 | [3,4,5,1] | -1 被替换为 n+1=5 |
| 第二步 | 标记位置 3 | [3,4,-5,1] | 3 对应的位置 nums[2] 标记为负数 |
| | 标记位置 4 | [3,-4,-5,1] | 4 对应的位置 nums[3] 标记为负数 |
| | 标记位置 1 | [-3,-4,-5,1] | 1 对应的位置 nums[0] 标记为负数 |
| 第三步 | 查找正数 | [-3,-4,-5,1] | nums[3] > 0，说明 2 没出现过 |

详细分析：
1. 数组长度 n = 4，所以我们关心的范围是 [1,4]
2. 第一步将 -1 替换为 5（n+1）
3. 第二步遍历数组：
   - 3：将 nums[2] 标记为负
   - 4：将 nums[3] 标记为负
   - 5：超出范围，跳过
   - 1：将 nums[0] 标记为负
4. 第三步遍历，发现 nums[3] 是正数
5. 返回 3+1 = 2，表示 2 是缺失的第一个正数

---

## 代码实现

完整的可运行代码：[L0041_FirstMissingPositive.java](../src/main/java/L0041_FirstMissingPositive.java)

```java
public int firstMissingPositive(int[] nums) {
    int n = nums.length;
    
    // 第一步：将负数和零修改为 n+1
    // 因为我们只关心 1 到 n 范围内的数
    for (int i = 0; i < n; i++) {
        if (nums[i] <= 0) {
            nums[i] = n + 1;
        }
    }
    
    // 第二步：将数组中的每个数对应的位置标记为负数
    // 例如，如果遇到数字 5，就将 nums[4] 标记为负数
    for (int i = 0; i < n; i++) {
        int num = Math.abs(nums[i]);
        if (num <= n) {
            nums[num - 1] = -Math.abs(nums[num - 1]);
        }
    }
    
    // 第三步：找到第一个正数的位置
    // 如果位置 i 上的数是正数，说明数字 i+1 没有出现过
    for (int i = 0; i < n; i++) {
        if (nums[i] > 0) {
            return i + 1;
        }
    }
    
    // 如果所有位置都是负数，说明 1 到 n 都出现了
    // 那么缺失的最小正数就是 n+1
    return n + 1;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)
  - 三个步骤都只需要遍历一次数组
  - 每个步骤的时间复杂度都是 O(n)
  - 总的时间复杂度是 O(n)

- **空间复杂度**：O(1)
  - 只使用了常数个额外变量
  - 原地修改数组，不需要额外空间
  - 利用正负号标记，节省了空间

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 