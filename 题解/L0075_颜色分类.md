---
title: 颜色分类
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[颜色分类](https://leetcode.cn/problems/sort-colors/)  
**🏷️ 标签**：`数组` `双指针` `排序`  
**🟡 难度**：`中等`  

给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、1 和 2 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

示例 1：
```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

示例 2：
```
输入：nums = [2,0,1]
输出：[0,1,2]
```

提示：
- n == nums.length
- 1 <= n <= 300
- nums[i] 为 0、1 或 2

进阶：
- 你能想出一个仅使用常数空间的一趟扫描算法吗？

---

## 解题思路

### 双指针（三指针）法

#### 📝 核心思想
这道题是经典的"荷兰国旗问题"，可以使用双指针（或三指针）的方法来解决。我们可以将数组分成三个区域：[0, p0) 存放 0（红色），[p0, curr) 存放 1（白色），(p2, n-1] 存放 2（蓝色）。通过一次遍历，将所有的 0 交换到左边，2 交换到右边，1 自然就在中间了。

#### 🛠️ 实现步骤
1. 使用三个指针：
   - p0：指向 0 的最右边界
   - curr：当前遍历的位置
   - p2：指向 2 的最左边界

2. 遍历数组，根据当前元素的值进行不同的操作：
   - 如果是 0：与 p0 位置交换，p0 和 curr 都向右移动
   - 如果是 2：与 p2 位置交换，p2 向左移动（curr 不动，因为交换来的数字还需要继续判断）
   - 如果是 1：curr 向右移动

#### 🧩 示例分析
以输入 nums = [2,0,2,1,1,0] 为例：

| 步骤 | 操作 | 数组状态 | p0 | curr | p2 | 说明 |
|-----|------|---------|-----|------|-----|-----|
| 初始 | - | [2,0,2,1,1,0] | 0 | 0 | 5 | 初始状态 |
| 1 | 交换 2 | [0,0,2,1,1,2] | 0 | 0 | 4 | curr=2，与 p2 交换 |
| 2 | 交换 0 | [0,0,2,1,1,2] | 1 | 1 | 4 | curr=0，与 p0 交换 |
| 3 | 交换 0 | [0,0,2,1,1,2] | 2 | 2 | 4 | curr=0，与 p0 交换 |
| 4 | 交换 2 | [0,0,1,1,2,2] | 2 | 2 | 3 | curr=2，与 p2 交换 |
| 5 | 跳过 1 | [0,0,1,1,2,2] | 2 | 3 | 3 | curr=1，直接跳过 |
| 6 | 跳过 1 | [0,0,1,1,2,2] | 2 | 4 | 3 | curr=1，直接跳过 |

---

## 代码实现

完整的可运行代码：[L0075_SortColors.java](../src/main/java/L0075_SortColors.java)

```java
public void sortColors(int[] nums) {
    // 使用双指针法，一个指针 p0 指向 0 的最右边界，一个指针 p2 指向 2 的最左边界
    int p0 = 0;  // 指向 0 的最右边界
    int p2 = nums.length - 1;  // 指向 2 的最左边界
    int curr = 0;  // 当前遍历的位置

    while (curr <= p2) {
        if (nums[curr] == 0) {
            // 如果当前数字是 0，就和 p0 指向的数字交换
            swap(nums, curr, p0);
            p0++;
            curr++;
        } else if (nums[curr] == 2) {
            // 如果当前数字是 2，就和 p2 指向的数字交换
            swap(nums, curr, p2);
            p2--;
            // 注意这里不需要 curr++，因为交换过来的数字还需要继续判断
        } else {
            // 如果当前数字是 1，就直接跳过
            curr++;
        }
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)，其中 n 是数组的长度。我们只需要遍历一次数组。
- **空间复杂度**：O(1)，我们只使用了常数空间。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 