---
title: 合并区间
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[合并区间](https://leetcode.cn/problems/merge-intervals/)  
**🏷️ 标签**：`数组` `排序`  
**🟡 难度**：`中等`  

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

示例 1：
```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

示例 2：
```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

提示：
- 1 <= intervals.length <= 10⁴
- intervals[i].length == 2
- 0 <= starti <= endi <= 10⁴

---

## 解题思路
### 排序 + 合并

#### 📝 核心思想
1. 首先按照区间的起始位置对所有区间进行排序
2. 然后遍历排序后的区间，判断相邻区间是否重叠
3. 如果重叠，则合并区间；如果不重叠，则将当前区间加入结果集

#### 🛠️ 实现步骤
1. 对区间数组按照起始位置进行排序
2. 创建一个列表存储合并后的区间，并将第一个区间加入
3. 遍历剩余的区间：
   - 如果当前区间的起始位置小于等于上一个区间的结束位置，说明有重叠，进行合并
   - 否则，将当前区间直接加入结果集
4. 将列表转换为数组返回

#### 🧩 示例分析
以示例 1 为例，intervals = [[1,3],[2,6],[8,10],[15,18]]：

1. 首先按照起始位置排序（本例已经排序）：
```
[1,3] [2,6] [8,10] [15,18]
```

2. 合并过程：

| 步骤 | 当前区间 | 结果集 | 说明 |
|-----|---------|-------|------|
| 初始状态 | - | [[1,3]] | 将第一个区间加入结果集 |
| 步骤 1 | [2,6] | [[1,6]] | [2,6] 与 [1,3] 重叠，合并为 [1,6] |
| 步骤 2 | [8,10] | [[1,6], [8,10]] | [8,10] 与 [1,6] 不重叠，直接加入 |
| 步骤 3 | [15,18] | [[1,6], [8,10], [15,18]] | [15,18] 与 [8,10] 不重叠，直接加入 |

区间合并示意图：
```
步骤 1：合并 [1,3] 和 [2,6]
1   2   3   4   5   6   7   8   9   10  ... 15  16  17  18
|───────|
    |───────────────|
|───────────────────|  ← 合并后

步骤 2：处理 [8,10]
1   2   3   4   5   6   7   8   9   10  ... 15  16  17  18
|───────────────────|      |───────|

步骤 3：处理 [15,18]
1   2   3   4   5   6   7   8   9   10  ... 15  16  17  18
|───────────────────|      |───────|          |───────────|
```

以示例 2 为例，intervals = [[1,4],[4,5]]：

| 步骤 | 当前区间 | 结果集 | 说明 |
|-----|---------|-------|------|
| 初始状态 | - | [[1,4]] | 将第一个区间加入结果集 |
| 步骤 1 | [4,5] | [[1,5]] | [4,5] 与 [1,4] 重叠（端点相等也算重叠），合并为 [1,5] |

区间合并示意图：
```
合并 [1,4] 和 [4,5]
1   2   3   4   5
|───────────|
            |───|
|───────────────|  ← 合并后
```

特殊情况分析：
1. 完全不重叠的区间：
```
[1,2] [4,5] [7,8]
不需要合并，直接加入结果集
```

2. 完全重叠的区间：
```
[1,5] [2,3]
第二个区间完全被第一个区间包含，合并后仍为 [1,5]
```

3. 单个区间：
```
[1,2]
直接返回原数组
```

---

## 代码实现

完整的可运行代码：[L0056_MergeIntervals.java](../src/main/java/L0056_MergeIntervals.java)

```java
public int[][] merge(int[][] intervals) {
    // 如果数组为空或只有一个区间，直接返回
    if (intervals == null || intervals.length <= 1) {
        return intervals;
    }
    
    // 按照区间的起始位置排序
    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
    
    // 用于存储合并后的区间
    List<int[]> merged = new ArrayList<>();
    // 将第一个区间加入结果集
    merged.add(intervals[0]);
    
    // 遍历剩余的区间
    for (int i = 1; i < intervals.length; i++) {
        // 获取当前区间
        int[] current = intervals[i];
        // 获取结果集中的最后一个区间
        int[] last = merged.get(merged.size() - 1);
        
        // 如果当前区间的起始位置小于等于最后一个区间的结束位置
        // 说明两个区间重叠，需要合并
        if (current[0] <= last[1]) {
            // 更新最后一个区间的结束位置
            last[1] = Math.max(last[1], current[1]);
        } else {
            // 如果不重叠，直接将当前区间加入结果集
            merged.add(current);
        }
    }
    
    // 将 List 转换为数组返回
    return merged.toArray(new int[merged.size()][]);
}
```

---

## 复杂度分析

- **时间复杂度**：O(n log n)，其中 n 是区间的数量。排序需要 O(n log n) 的时间，遍历区间需要 O(n) 的时间。
- **空间复杂度**：O(n)，需要存储合并后的区间。如果不考虑返回值的空间，则空间复杂度为 O(1)。

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 