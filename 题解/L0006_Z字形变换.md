---
title: Z 字形变换
date: 2024-02-06
---

## 题目描述

**🔗 题目**：[Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/)  
**🏷️ 标签**：`字符串`  
**🟡 难度**：`中等`  

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"PAYPALISHIRING"` 行数为 3 时，排列如下：
```
P   A   H   N
A P L S I I G
Y   I   R
```
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

**示例 1：**
```
输入：s = "PAYPALISHIRING", numRows = 3
输出："PAHNAPLSIIGYIR"
```

**示例 2：**
```
输入：s = "PAYPALISHIRING", numRows = 4
输出："PINALSIGYAHRPI"
解释：
P     I    N
A   L S  I G
Y A   H R
P     I
```

**示例 3：**
```
输入：s = "A", numRows = 1
输出："A"
```

**提示：**
- `1 <= s.length <= 1000`
- `s` 由英文字母（小写和大写）、',' 和 '.' 组成
- `1 <= numRows <= 1000`

---

## 解题思路

### 模拟法

#### 📝 核心思想
使用多个 StringBuilder 来模拟 Z 字形变换的过程，每个 StringBuilder 对应一行，通过控制移动方向来实现字符的正确放置。

#### 🛠️ 实现步骤
1. 特殊情况处理：
   - 如果行数为 1 或字符串长度小于等于行数，直接返回原字符串
2. 创建 numRows 个 StringBuilder，每个对应一行
3. 遍历字符串的每个字符：
   - 将字符添加到当前行的 StringBuilder 中
   - 在第一行或最后一行时改变移动方向
   - 根据移动方向更新当前行号
4. 合并所有行的 StringBuilder 得到最终结果

#### 🧩 示例分析
以 `s = "PAYPALISHIRING"`, `numRows = 3` 为例：

```text
初始状态：
row[0] = ""
row[1] = ""
row[2] = ""

遍历字符：
P: currentRow = 0, goingDown = true
   row[0] = "P"
   row[1] = ""
   row[2] = ""

A: currentRow = 1, goingDown = true
   row[0] = "P"
   row[1] = "A"
   row[2] = ""

Y: currentRow = 2, goingDown = false
   row[0] = "P"
   row[1] = "A"
   row[2] = "Y"

P: currentRow = 1, goingDown = false
   row[0] = "P"
   row[1] = "AP"
   row[2] = "Y"

... 继续遍历直到结束

最终状态：
row[0] = "PAHN"
row[1] = "APLSIIG"
row[2] = "YIR"

合并结果："PAHNAPLSIIGYIR"
```

---

## 代码实现

完整的可运行代码：[L0006_ZigzagConversion.java](../src/main/java/L0006_ZigzagConversion.java)

```java
public String convert(String s, int numRows) {
    // 特殊情况处理
    if (numRows == 1 || s.length() <= numRows) {
        return s;
    }
    
    // 使用 StringBuilder 数组，每个元素对应一行
    StringBuilder[] rows = new StringBuilder[numRows];
    for (int i = 0; i < numRows; i++) {
        rows[i] = new StringBuilder();
    }
    
    // 当前行号
    int currentRow = 0;
    // 是否向下移动
    boolean goingDown = false;
    
    // 遍历字符串中的每个字符
    for (char c : s.toCharArray()) {
        // 将字符添加到当前行
        rows[currentRow].append(c);
        
        // 在第一行或最后一行时改变方向
        if (currentRow == 0 || currentRow == numRows - 1) {
            goingDown = !goingDown;
        }
        
        // 根据方向移动当前行号
        currentRow += goingDown ? 1 : -1;
    }
    
    // 合并所有行
    StringBuilder result = new StringBuilder();
    for (StringBuilder row : rows) {
        result.append(row);
    }
    
    return result.toString();
}
```

---

## 复杂度分析

- **时间复杂度**：`O(n)`，其中 n 是字符串的长度。我们需要遍历字符串一次，然后遍历所有的行一次。
- **空间复杂度**：`O(n)`，我们需要 O(n) 的空间来存储每一行的字符。虽然我们使用了 numRows 个 StringBuilder，但每个 StringBuilder 的总长度加起来不会超过 n。

---

## LeetCode 题解

[LeetCode 最全题解](https://github.com/LjyYano/LeetCode) 