---
title: 括号生成
date: 2025-02-08
---

## 题目描述

**🔗 题目**：[括号生成](https://leetcode.cn/problems/generate-parentheses/)  
**🏷️ 标签**：`字符串` `动态规划` `回溯`  
**🟡 难度**：`中等`  

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**
```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**
```
输入：n = 1
输出：["()"]
```

**提示：**
- `1 <= n <= 8`

---

## 解题思路

### 回溯法

#### 📝 核心思想
使用回溯法生成所有可能的括号组合。在生成过程中，我们需要确保括号的有效性，这可以通过跟踪剩余的左括号和右括号数量来实现。

#### 🛠️ 实现步骤
1. 创建一个结果列表用于存储所有有效的括号组合
2. 从空字符串开始，使用回溯法生成括号组合
3. 在回溯过程中，遵循以下规则：
   - 如果还有左括号可用，可以添加左括号
   - 如果右括号剩余数量大于左括号剩余数量，可以添加右括号
4. 当左右括号都用完时，将当前生成的字符串加入结果列表

#### 🧩 示例分析
以 `n = 2` 为例，分析回溯过程：

```text
初始状态：current = "", left = 2, right = 2

第一步：添加左括号
current = "(", left = 1, right = 2

第二步：可以选择添加左括号或右括号
1) 添加左括号：
   current = "((", left = 0, right = 2
   只能添加右括号：
   current = "(()", left = 0, right = 1
   继续添加右括号：
   current = "(())", left = 0, right = 0 ✓

2) 添加右括号：
   current = "()", left = 1, right = 1
   继续添加左括号：
   current = "()(", left = 0, right = 1
   最后添加右括号：
   current = "()()", left = 0, right = 0 ✓
```

---

## 代码实现

完整的可运行代码：[L0022_GenerateParentheses.java](../src/main/java/L0022_GenerateParentheses.java)

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        backtrack(result, "", n, n);
        return result;
    }

    private void backtrack(List<String> result, String current, int left, int right) {
        if (left == 0 && right == 0) {
            result.add(current);
            return;
        }

        if (left > 0) {
            backtrack(result, current + "(", left - 1, right);
        }
        if (right > left) {
            backtrack(result, current + ")", left, right - 1);
        }
    }
}
```

---

## 复杂度分析

- **时间复杂度**：`O(4ⁿ/√n)`，这是第 n 个卡特兰数的渐近复杂度
- **空间复杂度**：`O(n)`，递归调用栈的深度最大为 2n

---

## LeetCode 题解

[LeetCode 最全题解](https://github.com/LjyYano/LeetCode) 