---
title: 括号生成
date: 2025-02-08
---

## 题目描述

**🔗 题目**：[括号生成](https://leetcode.cn/problems/generate-parentheses/)  
**🏷️ 标签**：`字符串` `动态规划` `回溯`  
**🟡 难度**：`中等`  

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例 1：**
```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**
```
输入：n = 1
输出：["()"]
```

**提示：**
- `1 <= n <= 8`

---

## 解题思路

### 回溯法

#### 📝 核心思想
使用回溯法生成所有可能的括号组合。在生成过程中，我们需要确保括号的有效性，这可以通过跟踪剩余的左括号和右括号数量来实现。

#### 🛠️ 实现步骤
1. 创建一个结果列表用于存储所有有效的括号组合
2. 从空字符串开始，使用回溯法生成括号组合
3. 在回溯过程中，遵循以下规则：
   - 如果还有左括号可用，可以添加左括号
   - 如果右括号剩余数量大于左括号剩余数量，可以添加右括号
4. 当左右括号都用完时，将当前生成的字符串加入结果列表

#### �� 示例分析
以 `n = 2` 为例，让我们详细分析回溯的过程。

**1. 决策树展示**
```text
                        ""
                        ↓
                       (•)
                     ↙     ↘
                  ((•)     (•)
                   ↓       ↙
                ((•))   (•)(
                   ↓       ↓
               ((•))    (•)()
                ✅        ✅
```
注：(•) 表示当前添加的括号

**2. 详细状态分析**

| 步骤 | 当前字符串 | 剩余左括号 | 剩余右括号 | 可选操作 | 原因 |
|-----|-----------|-----------|------------|---------|------|
| 1 | `""` | 2 | 2 | 只能添加 `(` | 必须先添加左括号 |
| 2 | `"("` | 1 | 2 | 可添加 `(` 或 `)` | 左右括号都满足条件 |
| 3a | `"(("` | 0 | 2 | 只能添加 `)` | 左括号已用完 |
| 3b | `"()"` | 1 | 1 | 只能添加 `(` | 剩余左右括号数相等 |
| 4a | `"(())"` | 0 | 0 | 完成 ✅ | 括号已用完 |
| 4b | `"()()"` | 0 | 0 | 完成 ✅ | 括号已用完 |

**3. 生成过程分析**

路径一：`"" → "(" → "((" → "(())" → "(())"` ✅
```text
步骤 1: [ ]           → 添加左括号
步骤 2: [(]           → 添加左括号
步骤 3: [((]          → 添加右括号
步骤 4: [(()] → (())  → 完成
```

路径二：`"" → "(" → "()" → "()(" → "()()"` ✅
```text
步骤 1: [ ]           → 添加左括号
步骤 2: [(]           → 添加右括号
步骤 3: [()]          → 添加左括号
步骤 4: [()(] → ()()  → 完成
```

**4. 关键规则说明**
1. 任何时候都必须保证：已使用的右括号数量 ≤ 已使用的左括号数量
2. 当剩余左括号数量 > 0 时，可以添加左括号
3. 当剩余右括号数量 > 剩余左括号数量时，可以添加右括号
4. 当左右括号都用完时（都为 0），得到一个有效组合

这样的分析方式展示了：
- 通过决策树直观展示了所有可能的路径
- 通过状态表格清晰地展示了每一步的状态和可选操作
- 通过生成过程分析展示了具体的括号添加位置
- 最后通过关键规则总结了生成有效括号组合的核心要点

---

## 代码实现

完整的可运行代码：[L0022_GenerateParentheses.java](../src/main/java/L0022_GenerateParentheses.java)

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        backtrack(result, "", n, n);
        return result;
    }

    private void backtrack(List<String> result, String current, int left, int right) {
        if (left == 0 && right == 0) {
            result.add(current);
            return;
        }

        if (left > 0) {
            backtrack(result, current + "(", left - 1, right);
        }
        if (right > left) {
            backtrack(result, current + ")", left, right - 1);
        }
    }
}
```

---

## 复杂度分析

- **时间复杂度**：`O(4ⁿ/√n)`，这是第 n 个卡特兰数的渐近复杂度
- **空间复杂度**：`O(n)`，递归调用栈的深度最大为 2n

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。