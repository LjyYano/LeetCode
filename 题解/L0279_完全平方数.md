---
title: 完全平方数
date: 2024-03-24
---

## 题目描述

**🔗 题目**：[完全平方数](https://leetcode.cn/problems/perfect-squares/)  
**🏷️ 标签**：`数学` `动态规划` `广度优先搜索`  
**🟡 难度**：`中等`  

给你一个整数 n ，返回和为 n 的完全平方数的最少数量。

完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

**示例 1：**
```
输入：n = 12
输出：3
解释：12 = 4 + 4 + 4
```

**示例 2：**
```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

**提示：**
- 1 <= n <= 10⁴

---

## 解题思路

### 动态规划

#### 📝 核心思想

这道题可以使用动态规划来解决。对于任意一个数 n，我们需要找到最少的完全平方数的和来表示它。我们可以通过以下步骤来思考：

1. 对于任意一个数 i，它可以由一个完全平方数 j² 加上一个更小的数 i - j² 组成
2. 因此，dp[i] 表示数字 i 最少需要多少个完全平方数来表示
3. 状态转移方程：dp[i] = min(dp[i], dp[i - j²] + 1)，其中 j² ≤ i

#### 🛠️ 实现步骤

1. 创建一个长度为 n + 1 的 dp 数组，dp[i] 表示数字 i 的完全平方数的最少数量
2. 初始化 dp[i] = i，因为最坏的情况下，i 可以由 i 个 1 组成
3. 对于每个数字 i，遍历所有小于等于 i 的完全平方数 j²
4. 使用状态转移方程更新 dp[i]
5. 最终返回 dp[n]

#### 🧩 示例分析

以 n = 12 为例，我们来看看动态规划的过程：

| i | 可选的完全平方数 | dp[i] 的计算过程 | 最终的 dp[i] |
|---|----------------|-----------------|-------------|
| 1 | 1 | dp[1] = min(1) = 1 | 1 |
| 2 | 1 | dp[2] = min(2, dp[1] + 1) = 2 | 2 |
| 3 | 1 | dp[3] = min(3, dp[2] + 1) = 3 | 3 |
| 4 | 1, 4 | dp[4] = min(4, dp[3] + 1, dp[0] + 1) = 1 | 1 |
| 5 | 1, 4 | dp[5] = min(5, dp[4] + 1, dp[1] + 1) = 2 | 2 |
| 6 | 1, 4 | dp[6] = min(6, dp[5] + 1, dp[2] + 1) = 3 | 3 |
| 7 | 1, 4 | dp[7] = min(7, dp[6] + 1, dp[3] + 1) = 4 | 4 |
| 8 | 1, 4 | dp[8] = min(8, dp[7] + 1, dp[4] + 1) = 2 | 2 |
| 9 | 1, 4, 9 | dp[9] = min(9, dp[8] + 1, dp[5] + 1, dp[0] + 1) = 1 | 1 |
| 10 | 1, 4, 9 | dp[10] = min(10, dp[9] + 1, dp[6] + 1, dp[1] + 1) = 2 | 2 |
| 11 | 1, 4, 9 | dp[11] = min(11, dp[10] + 1, dp[7] + 1, dp[2] + 1) = 3 | 3 |
| 12 | 1, 4, 9 | dp[12] = min(12, dp[11] + 1, dp[8] + 1, dp[3] + 1) = 3 | 3 |

对于 12，最终得到的结果是 3，表示最少需要 3 个完全平方数（4 + 4 + 4）。

---

## 代码实现

完整的可运行代码：[L0279_PerfectSquares.java](../src/main/java/L0279_PerfectSquares.java)

```java
public int numSquares(int n) {
    // dp[i] 表示数字 i 的完全平方数的最少数量
    int[] dp = new int[n + 1];
    
    // 初始化 dp 数组
    for (int i = 1; i <= n; i++) {
        // 最坏的情况就是每个数都由 1 组成
        dp[i] = i;
        
        // 尝试每个小于等于 i 的平方数
        for (int j = 1; j * j <= i; j++) {
            // 当前平方数
            int square = j * j;
            // 更新 dp[i]，等于 dp[i - square] + 1
            dp[i] = Math.min(dp[i], dp[i - square] + 1);
        }
    }
    
    return dp[n];
}
```

---

## 复杂度分析

- **时间复杂度**：O(n * √n)
  - 外层循环需要遍历 1 到 n，复杂度为 O(n)
  - 内层循环需要遍历所有小于等于 i 的完全平方数，复杂度为 O(√n)
  - 因此总的时间复杂度为 O(n * √n)

- **空间复杂度**：O(n)
  - 需要一个长度为 n + 1 的 dp 数组来存储中间状态

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 