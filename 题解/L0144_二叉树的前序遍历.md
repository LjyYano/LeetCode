---
title: 二叉树的前序遍历
date: 2024-03-26
---

## 题目描述

**🔗 题目**：[二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)  
**🏷️ 标签**：`栈` `树` `深度优先搜索` `二叉树`  
**🟢 难度**：`简单`  

给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

**示例 1：**
```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

**示例 2：**
```
输入：root = []
输出：[]
```

**示例 3：**
```
输入：root = [1]
输出：[1]
```

**提示：**
- 树中节点数目在范围 [0, 100] 内
- -100 <= Node.val <= 100

进阶：递归算法很简单，你可以通过迭代算法完成吗？

---

## 解题思路

### 递归和迭代两种方法

#### 📝 核心思想
二叉树的前序遍历是一种深度优先搜索（DFS）的遍历方式，遍历顺序为：根节点 -> 左子树 -> 右子树。本题可以使用递归和迭代两种方法来实现：

1. 递归方法：
   - 访问根节点
   - 递归遍历左子树
   - 递归遍历右子树

2. 迭代方法：
   - 使用栈来模拟递归过程
   - 先访问当前节点
   - 然后将右子节点入栈（因为后访问）
   - 最后将左子节点入栈（因为先访问）

#### 🛠️ 实现步骤

1. 递归实现：
   - 定义递归函数，参数为当前节点和结果列表
   - 递归终止条件：当前节点为空
   - 按照前序遍历顺序递归处理根节点、左子树、右子树

2. 迭代实现：
   - 使用栈来存储节点
   - 将根节点入栈
   - 循环处理，直到栈为空：
     * 弹出栈顶节点并访问
     * 将右子节点入栈（如果存在）
     * 将左子节点入栈（如果存在）

#### 🧩 示例分析
以示例 1 为例，分析遍历过程：
```
     1
      \
       2
      /
     3
```

递归方法的遍历过程：
1. 访问根节点 1，添加到结果：[1]
2. 递归左子树（空）
3. 递归右子树（节点 2）：
   - 访问节点 2，添加到结果：[1,2]
   - 递归左子树（节点 3）：
     * 访问节点 3，添加到结果：[1,2,3]
   - 递归右子树（空）

迭代方法的遍历过程表格说明：

| 步骤 | 栈内容 | 当前节点 | 结果数组 | 操作说明 |
|-----|--------|---------|----------|----------|
| 1 | [1] | - | [] | 初始化，将根节点入栈 |
| 2 | [] | 1 | [1] | 弹出并访问节点 1 |
| 3 | [2] | 1 | [1] | 将右子节点 2 入栈 |
| 4 | [] | 2 | [1,2] | 弹出并访问节点 2 |
| 5 | [3] | 2 | [1,2] | 将左子节点 3 入栈 |
| 6 | [] | 3 | [1,2,3] | 弹出并访问节点 3 |

---

## 代码实现

完整的可运行代码：[L0144_BinaryTreePreorderTraversal.java](../src/main/java/L0144_BinaryTreePreorderTraversal.java)

```java
/**
 * 递归解法
 */
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    preorderRecursive(root, result);
    return result;
}

private void preorderRecursive(TreeNode node, List<Integer> result) {
    if (node == null) {
        return;
    }
    // 前序遍历：根节点 -> 左子树 -> 右子树
    result.add(node.val);
    preorderRecursive(node.left, result);
    preorderRecursive(node.right, result);
}

/**
 * 迭代解法
 */
public List<Integer> preorderTraversalIterative(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        result.add(node.val);
        
        // 注意：因为栈是后进先出，所以先压入右子节点，再压入左子节点
        if (node.right != null) {
            stack.push(node.right);
        }
        if (node.left != null) {
            stack.push(node.left);
        }
    }
    
    return result;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)
  - 无论是递归还是迭代方法，每个节点都只会被访问一次
  - n 是二叉树中节点的数量

- **空间复杂度**：
  - 递归方法：O(h)，h 是树的高度
    * 最好情况：O(log n)，平衡二叉树
    * 最坏情况：O(n)，树退化为链表
  - 迭代方法：O(h)，h 是树的高度
    * 最好情况：O(log n)，平衡二叉树
    * 最坏情况：O(n)，树退化为链表

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 