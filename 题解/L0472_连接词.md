---
date: 2024-03-19
title: 连接词
---

# 连接词

## 题目描述

[连接词](https://leetcode.cn/problems/concatenated-words/)

给你一个 **不含重复** 单词的字符串数组 `words`，请你找出并返回 `words` 中的所有 **连接词**。

**连接词** 定义为：一个完全由给定数组中的至少两个较短单词（不一定是不同的两个单词）组成的字符串。

示例 1：
```
输入：words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
输出：["catsdogcats","dogcatsdog","ratcatdogcat"]
解释："catsdogcats" 由 "cats", "dog" 和 "cats" 组成; 
     "dogcatsdog" 由 "dog", "cats" 和 "dog" 组成; 
     "ratcatdogcat" 由 "rat", "cat", "dog" 和 "cat" 组成。
```

示例 2：
```
输入：words = ["cat","dog","catdog"]
输出：["catdog"]
```

提示：
- `1 <= words.length <= 10⁴`
- `1 <= words[i].length <= 30`
- `words[i]` 仅由小写英文字母组成
- `words` 中的所有字符串都是 **唯一** 的
- `1 <= sum(words[i].length) <= 10⁵`

## 解题思路

这道题目可以使用字典树（Trie）或动态规划来解决。这里我们使用字典树的解决方案，因为它在处理字符串查找和前缀匹配时非常高效。

### 核心思路

1. 首先，我们需要将所有单词按长度排序，这样可以确保在检查一个单词是否为连接词时，所有可能组成它的较短单词都已经在字典树中。

2. 对于每个单词，我们需要：
   - 检查它是否可以由字典树中已有的单词组成（如果可以，它就是一个连接词）
   - 将它添加到字典树中（这样它可以用来组成后面的连接词）

3. 使用字典树来存储单词，并使用递归来检查一个单词是否可以由其他单词组成。

### 实现步骤

1. 创建字典树节点类 `TrieNode`：
```java
class TrieNode {
    TrieNode[] children;
    boolean isEnd;

    public TrieNode() {
        children = new TrieNode[26];
        isEnd = false;
    }
}
```

2. 实现向字典树中添加单词的方法：
```java
private void addWord(String word) {
    TrieNode node = root;
    for (char c : word.toCharArray()) {
        if (node.children[c - 'a'] == null) {
            node.children[c - 'a'] = new TrieNode();
        }
        node = node.children[c - 'a'];
    }
    node.isEnd = true;
}
```

3. 实现检查单词是否可以由其他单词组成的方法：
```java
private boolean canForm(String word, int start) {
    if (start == word.length()) {
        return true;
    }
    TrieNode node = root;
    for (int i = start; i < word.length(); i++) {
        char c = word.charAt(i);
        node = node.children[c - 'a'];
        if (node == null) {
            return false;
        }
        // 如果找到一个单词的结尾，递归检查剩余部分
        if (node.isEnd && canForm(word, i + 1)) {
            return true;
        }
    }
    return false;
}
```

4. 主方法中，按长度排序并处理每个单词：
```java
public List<String> findAllConcatenatedWordsInADict(String[] words) {
    List<String> result = new ArrayList<>();
    if (words == null || words.length == 0) {
        return result;
    }

    Arrays.sort(words, (a, b) -> a.length() - b.length());
    root = new TrieNode();

    for (String word : words) {
        if (word.length() == 0) {
            continue;
        }
        if (canForm(word, 0)) {
            result.add(word);
        }
        addWord(word);
    }

    return result;
}
```

### 复杂度分析

- 时间复杂度：O(N × L²)，其中 N 是单词数组的长度，L 是最长单词的长度。
  - 对于每个单词，我们需要检查它是否可以由其他单词组成，这需要 O(L²) 的时间
  - 我们需要处理所有 N 个单词
  - 排序需要 O(N log N) 的时间

- 空间复杂度：O(N × L)
  - 字典树需要存储所有单词，每个单词最多需要 L 个节点
  - 递归调用栈的深度最多为 L

## 总结

这道题目是字典树（Trie）的一个典型应用。通过使用字典树，我们可以高效地存储和查找单词，并且可以方便地检查一个单词是否可以由其他单词组成。关键点在于：

1. 按长度排序确保了在检查一个单词时，所有可能组成它的较短单词都已经在字典树中
2. 使用递归来检查单词的不同切分方式
3. 字典树的结构使得我们可以高效地进行前缀匹配和查找

这个解决方案在实际应用中也很有用，比如：
- 自动补全系统
- 拼写检查器
- 文本分词
- 搜索引擎的查询建议 