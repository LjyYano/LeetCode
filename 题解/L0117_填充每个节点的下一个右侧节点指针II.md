---
title: 填充每个节点的下一个右侧节点指针 II
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)  
**🏷️ 标签**：`树` `深度优先搜索` `广度优先搜索` `链表` `二叉树`  
**🟡 难度**：`中等`  

给定一个二叉树：

```c
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

示例 1：
```
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。
```

示例 2：
```
输入：root = []
输出：[]
```

提示：
- 树中的节点数在范围 [0, 6000] 内
- -100 <= Node.val <= 100

进阶：
- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

---

## 解题思路
### 常量空间解法

#### 📝 核心思想
本题是 [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/) 的进阶版本。主要区别在于：
1. 不再限制是完美二叉树
2. 树可以是任意形状
3. 需要处理更多的边界情况

我们采用层序遍历的思想，但不使用队列，而是利用已经建立的 next 指针来遍历每一层，同时为下一层建立 next 指针。

#### 🛠️ 实现步骤
1. 处理特殊情况：
   - 如果根节点为空，直接返回

2. 遍历每一层：
   - 使用 levelStart 指针指向当前层的第一个节点
   - 使用虚拟头节点 dummyNext 来帮助构建下一层的 next 指针
   - 使用 current 指针在下一层移动并建立 next 连接

3. 对于当前层的每个节点：
   - 如果有左子节点，将其连接到 current.next
   - 如果有右子节点，将其连接到 current.next
   - 移动到当前层的下一个节点

4. 移动到下一层：
   - 将 levelStart 更新为 dummyNext.next（下一层的第一个节点）

#### 🧩 示例分析
以输入 `[1,2,3,4,5,null,7]` 为例：

初始状态：
```
       1
      / \
     2   3
    / \   \
   4   5   7
```

第一步：处理第一层（根节点）
```
       1 → #
      / \
     2   3
    / \   \
   4   5   7
```

第二步：处理第二层
```
       1 → #
      / \
     2 → 3 → #
    / \   \
   4   5   7
```

第三步：处理第三层
```
       1 → #
      / \
     2 → 3 → #
    / \   \
   4 → 5 → 7 → #
```

---

## 代码实现

完整的可运行代码：[L0117_PopulatingNextRightPointersInEachNodeII.java](../src/main/java/L0117_PopulatingNextRightPointersInEachNodeII.java)

```java
public Node connect(Node root) {
    if (root == null) {
        return null;
    }
    
    // 当前层的第一个节点
    Node levelStart = root;
    
    while (levelStart != null) {
        // 下一层的虚拟头节点
        Node dummyNext = new Node(0);
        // 用于构建下一层 next 指针的指针
        Node current = dummyNext;
        
        // 遍历当前层的节点
        Node node = levelStart;
        while (node != null) {
            // 处理左子节点
            if (node.left != null) {
                current.next = node.left;
                current = current.next;
            }
            // 处理右子节点
            if (node.right != null) {
                current.next = node.right;
                current = current.next;
            }
            // 移动到当前层的下一个节点
            node = node.next;
        }
        
        // 移动到下一层的第一个节点
        levelStart = dummyNext.next;
    }
    
    return root;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)
  - 每个节点只被访问一次
  - n 为二叉树中的节点个数

- **空间复杂度**：O(1)
  - 只使用了常量级的额外空间
  - 虚拟头节点和几个指针变量的空间是常量级的

---

## 相关题目

- [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)
- [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)
- [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

---

## 总结

这道题的关键是理解如何在不使用额外空间的情况下进行层序遍历。通过使用虚拟头节点和已建立的 next 指针，我们可以巧妙地完成这个任务。相比第 116 题，本题需要处理更多的边界情况，因为树的结构不再是完美的。

这个解法的优点是：
1. 空间复杂度为 O(1)，满足进阶要求
2. 代码结构清晰，易于理解
3. 可以处理任意形状的二叉树

需要注意的是：
1. 要正确处理节点为空的情况
2. 要正确维护下一层的连接关系
3. 要正确找到下一层的起始节点

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 