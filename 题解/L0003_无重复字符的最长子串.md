---
title: 无重复字符的最长子串
date: 2024-02-06
---

## 题目描述

**🔗 题目**：[无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)  
**🏷️ 标签**：`哈希表` `字符串` `滑动窗口`  
**🟡 难度**：`中等`  

给定一个字符串 `s`，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**
```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**
```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**
```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**
- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

---

## 解题思路

### 滑动窗口 + 哈希表

#### 📝 核心思想
使用滑动窗口来维护当前无重复字符的子串，同时使用哈希表记录每个字符最后出现的位置，实现快速判断和更新窗口。

#### 🛠️ 实现步骤
1. 使用 HashMap 存储字符及其最后出现的位置
2. 使用两个指针 start 和 end 维护滑动窗口：
   - start 表示当前无重复子串的起始位置
   - end 表示当前遍历到的位置
3. 遍历字符串，对于每个字符：
   - 如果字符已在窗口中出现（即其上次出现位置 >= start），更新 start 为该字符上次出现位置的下一个位置
   - 更新字符的最新位置
   - 更新最长子串的长度

#### 🧩 示例分析
以 `s = "abcabcbb"` 为例：

```text
初始状态：start = 0, maxLength = 0, charMap = {}

Step 1: end = 0, char = 'a'
   charMap = {a:0}
   maxLength = 1
   窗口：[a]

Step 2: end = 1, char = 'b'
   charMap = {a:0, b:1}
   maxLength = 2
   窗口：[a,b]

Step 3: end = 2, char = 'c'
   charMap = {a:0, b:1, c:2}
   maxLength = 3
   窗口：[a,b,c]

Step 4: end = 3, char = 'a'
   发现重复字符 'a'，其上次位置为 0
   start = 0 + 1 = 1
   charMap = {a:3, b:1, c:2}
   maxLength = 3
   窗口：[b,c,a]

... 继续遍历直到结束
```

---

## 代码实现

完整的可运行代码：[L0003_LongestSubstringWithoutRepeatingCharacters.java](../src/main/java/L0003_LongestSubstringWithoutRepeatingCharacters.java)

```java
public int lengthOfLongestSubstring(String s) {
    // 特殊情况处理
    if (s == null || s.length() == 0) {
        return 0;
    }
    
    // 使用 HashMap 存储字符及其最后出现的位置
    Map<Character, Integer> charMap = new HashMap<>();
    // 最长子串的长度
    int maxLength = 0;
    // 当前无重复子串的起始位置
    int start = 0;
    
    // 遍历字符串
    for (int end = 0; end < s.length(); end++) {
        char currentChar = s.charAt(end);
        
        // 如果当前字符已经在 map 中，并且其位置大于等于 start
        // 说明在当前窗口中存在重复字符，需要更新窗口的起始位置
        if (charMap.containsKey(currentChar) && charMap.get(currentChar) >= start) {
            start = charMap.get(currentChar) + 1;
        }
        
        // 更新当前字符的位置
        charMap.put(currentChar, end);
        // 更新最长子串的长度
        maxLength = Math.max(maxLength, end - start + 1);
    }
    
    return maxLength;
}
```

---

## 复杂度分析

- **时间复杂度**：`O(n)`，其中 n 是字符串的长度。我们只需要遍历一次字符串，而哈希表的查找和插入操作的时间复杂度为 O(1)。
- **空间复杂度**：`O(min(m,n))`，其中 m 是字符集的大小，n 是字符串的长度。我们需要用哈希表存储字符的位置，而哈希表的大小取决于字符集的大小和字符串的长度中的较小值。

---

## LeetCode 题解

[LeetCode 最全题解](https://github.com/LjyYano/LeetCode) 