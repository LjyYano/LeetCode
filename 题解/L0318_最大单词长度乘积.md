---
title: 最大单词长度乘积
date: 2024-02-10
---

## 题目描述

**🔗 题目**：[最大单词长度乘积](https://leetcode.cn/problems/maximum-product-of-word-lengths/)  
**🏷️ 标签**：`位运算` `数组` `字符串`  
**🟡 难度**：`中等`  

给你一个字符串数组 words ，找出并返回 length(words[i]) * length(words[j]) 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 0 。

示例 1：
```
输入：words = ["abcw","baz","foo","bar","xtfn","abcdef"]
输出：16 
解释：这两个单词为 "abcw", "xtfn"。
```

示例 2：
```
输入：words = ["a","ab","abc","d","cd","bcd","abcd"]
输出：4 
解释：这两个单词为 "ab", "cd"。
```

示例 3：
```
输入：words = ["a","aa","aaa","aaaa"]
输出：0 
解释：不存在这样的两个单词。
```

提示：
- 2 <= words.length <= 1000
- 1 <= words[i].length <= 1000
- words[i] 仅包含小写字母

---

## 解题思路
### 位运算优化

#### 📝 核心思想
本题的关键是如何高效地判断两个单词是否有公共字母。我们可以使用位运算来优化这个过程：
1. 使用一个整数的二进制位来表示一个单词包含的字母
2. 每个字母对应一个二进制位，如果单词包含该字母，则将对应位置为 1
3. 两个单词是否有公共字母可以通过对它们的位表示进行按位与运算来判断

#### 🛠️ 实现步骤
1. 预处理每个单词：
   - 遍历单词中的每个字母
   - 将对应的二进制位设置为 1
   - 得到每个单词的位掩码表示

2. 寻找最大乘积：
   - 遍历所有单词对
   - 对每对单词的位掩码进行按位与运算
   - 如果结果为 0，说明没有公共字母
   - 计算并更新最大乘积

#### 🧩 示例分析
以示例 1 中的单词 "abcw" 和 "xtfn" 为例：

1. 计算 "abcw" 的位掩码：
```
a -> 1 << 0  = 000...000001
b -> 1 << 1  = 000...000010
c -> 1 << 2  = 000...000100
w -> 1 << 22 = 010...000000
最终掩码     = 010...000111
```

2. 计算 "xtfn" 的位掩码：
```
x -> 1 << 23 = 100...000000
t -> 1 << 19 = 000...100000
f -> 1 << 5  = 000...100000
n -> 1 << 13 = 001...000000
最终掩码     = 101...100000
```

3. 判断是否有公共字母：
```
abcw 的掩码：010...000111
xtfn 的掩码：101...100000
按位与结果：000...000000（为 0，说明没有公共字母）
```

让我们用表格形式展示完整的处理过程：

| 步骤 | 单词对 | 掩码 1 | 掩码 2 | 按位与结果 | 长度乘积 | 是否更新最大值 |
|-----|--------|--------|--------|------------|----------|---------------|
| 1 | abcw, baz | 010...000111 | 000...000011 | ≠0 | 4×3=12 | 否（有公共字母） |
| 2 | abcw, foo | 010...000111 | 000...100000 | 0 | 4×3=12 | 是（更新为 12） |
| 3 | abcw, xtfn | 010...000111 | 101...100000 | 0 | 4×4=16 | 是（更新为 16） |
| ... | ... | ... | ... | ... | ... | ... |

通过位运算，我们可以：
1. 快速判断两个单词是否有公共字母
2. 避免使用集合或数组来存储字母
3. 大大提高判断的效率

---

## 代码实现

完整的可运行代码：[L0318_MaximumProductOfWordLengths.java](../src/main/java/L0318_MaximumProductOfWordLengths.java)

```java
public class L0318_MaximumProductOfWordLengths {
    
    public int maxProduct(String[] words) {
        int n = words.length;
        // 使用整数的二进制位表示每个单词包含的字母
        int[] masks = new int[n];
        
        // 计算每个单词的位掩码
        for (int i = 0; i < n; i++) {
            String word = words[i];
            for (char c : word.toCharArray()) {
                // 将字母对应的位设置为 1
                masks[i] |= 1 << (c - 'a');
            }
        }
        
        // 找出不含公共字母的两个单词，计算它们长度的乘积
        int maxProduct = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                // 如果两个单词的位掩码按位与为 0，说明没有公共字母
                if ((masks[i] & masks[j]) == 0) {
                    maxProduct = Math.max(maxProduct, words[i].length() * words[j].length());
                }
            }
        }
        
        return maxProduct;
    }
}
```

---

## 复杂度分析

- **时间复杂度**：O(n²)，其中 n 是单词数组的长度
  - 预处理每个单词需要 O(L) 时间，其中 L 是所有单词的总长度
  - 比较所有单词对需要 O(n²) 时间
  - 总的时间复杂度由比较单词对的部分主导，为 O(n²)

- **空间复杂度**：O(n)
  - 需要一个长度为 n 的数组存储每个单词的位掩码
  - 其他变量使用的空间是常数级的

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 