---
title: 填充每个节点的下一个右侧节点指针
date: 2025-02-09
---

## 题目描述

**🔗 题目**：[填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)  
**🏷️ 标签**：`树` `深度优先搜索` `广度优先搜索` `二叉树`  
**🟡 难度**：`中等`  

给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```c
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

示例 1：
```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

示例 2：
```
输入：root = []
输出：[]
```

提示：
- 树中节点的数量在 [0, 2¹² - 1] 范围内
- -1000 <= node.val <= 1000

进阶：
- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

---

## 解题思路
### 递归方法

#### 📝 核心思想
本题的关键是利用完美二叉树的特性，每个非叶子节点都有两个子节点。我们可以通过递归的方式，自顶向下地处理每个节点的 next 指针。对于每个节点，我们需要：

1. 将其左子节点的 next 指向右子节点
2. 将其右子节点的 next 指向父节点的 next 的左子节点（如果父节点的 next 存在）

这种方法的优点是不需要额外的空间，只需要利用递归栈空间即可。

#### 🛠️ 实现步骤
1. 处理根节点：
   - 如果根节点为空，直接返回
   - 如果根节点没有子节点，直接返回

2. 处理子节点的 next 指针：
   - 将左子节点的 next 指向右子节点
   - 如果当前节点的 next 不为空，将右子节点的 next 指向当前节点的 next 的左子节点

3. 递归处理左右子树：
   - 递归处理左子树
   - 递归处理右子树

4. 返回根节点

#### 🧩 示例分析
以输入 `[1,2,3,4,5,6,7]` 为例，让我们看看算法的执行过程：

初始状态：
```
       1
      / \
     2   3
    / \ / \
   4  5 6  7
```

第一步：处理根节点 1 的子节点
```
       1
      / \
     2→  3
    / \ / \
   4  5 6  7
```

第二步：处理节点 2 的子节点
```
       1
      / \
     2→  3
    / \ / \
   4→5→6  7
```

第三步：处理节点 3 的子节点
```
       1
      / \
     2→  3
    / \ / \
   4→5→6→7
```

最终结果：
```
       1→#
      / \
     2→  3→#
    / \ / \
   4→5→6→7→#
```

其中，→ 表示 next 指针的指向，# 表示 NULL。

---

## 代码实现

完整的可运行代码：[L0116_PopulatingNextRightPointersInEachNode.java](../src/main/java/L0116_PopulatingNextRightPointersInEachNode.java)

```java
public Node connect(Node root) {
    if (root == null) {
        return null;
    }
    
    // 处理左子节点
    if (root.left != null) {
        // 左子节点的 next 指向右子节点
        root.left.next = root.right;
        
        // 右子节点的 next 指向父节点的 next 的左子节点
        if (root.next != null) {
            root.right.next = root.next.left;
        }
    }
    
    // 递归处理左右子树
    connect(root.left);
    connect(root.right);
    
    return root;
}
```

---

## 复杂度分析

- **时间复杂度**：O(n)
  - 每个节点只被访问一次
  - n 为二叉树中的节点个数

- **空间复杂度**：O(h)
  - h 为树的高度
  - 在完美二叉树中，h = log n
  - 空间复杂度主要来自递归调用栈的深度
  - 根据题目说明，递归栈空间不计入额外空间复杂度

---

## 相关题目

- [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)
- [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)
- [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

---

## LeetCode 题解

本题解是 LeetCode 系列题解的一部分。该系列题解致力于帮助程序员更好地理解和掌握算法思维，内容包含详细的解题思路分析、图文并茂的示例讲解和完整的代码实现。

<img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="20" style="vertical-align: middle; margin-right: 5px"> [LeetCode 最全题解](https://github.com/LjyYano/LeetCode)：持续更新中，欢迎 Star ⭐️ 关注，一起探讨算法之美。 