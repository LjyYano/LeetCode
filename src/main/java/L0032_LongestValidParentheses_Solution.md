# 32. 最长有效括号

## 题目

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

示例 1：
```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

示例 2：
```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

示例 3：
```
输入：s = ""
输出：0
```

提示：
- 0 <= s.length <= 3 * 104
- s[i] 为 '(' 或 ')'

## 解题思路

这道题可以使用动态规划来解决。我们定义 dp[i] 表示以字符 s[i] 结尾的最长有效括号子串的长度。

对于每个位置 i，我们需要考虑以下情况：

1. 如果 s[i] 是 '('，那么以它结尾的子串一定不是有效括号串，因此 dp[i] = 0

2. 如果 s[i] 是 ')'，我们需要考虑两种情况：
   
   a) 如果 s[i-1] 是 '('，即形如 "....()"，那么：
      dp[i] = dp[i-2] + 2
      
   b) 如果 s[i-1] 是 ')'，即形如 "....))"，我们需要检查是否能和前面的括号匹配：
      - 首先找到前一个 ')' 对应的有效括号长度 dp[i-1]
      - 然后看这个长度之前的字符（即 s[i-dp[i-1]-1]）是否是 '('
      - 如果是 '('，则可以和当前的 ')' 匹配，此时：
        dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]
        
        其中：
        - dp[i-1] 是前一个位置的有效长度
        - 2 是当前新增的一对括号的长度
        - dp[i-dp[i-1]-2] 是匹配的 '(' 前面的有效长度（如果存在）

在遍历过程中，我们用一个变量 maxLen 记录所有 dp[i] 中的最大值，这就是最终答案。

## 复杂度分析

- 时间复杂度：O(n)，其中 n 是字符串的长度。我们只需要遍历一次字符串。
- 空间复杂度：O(n)，需要一个长度为 n 的数组来存储动态规划的状态。

## 代码实现的关键点

1. 初始条件的处理：
   - 如果字符串为空或长度小于 2，直接返回 0
   - dp 数组初始值都为 0

2. 状态转移时的边界检查：
   - 检查 i-2 是否越界
   - 检查 i-dp[i-1]-1 是否越界
   - 检查 i-dp[i-1]-2 是否越界

3. 只有当遇到 ')' 时才需要更新 dp 值，因为有效括号子串必须以 ')' 结尾 