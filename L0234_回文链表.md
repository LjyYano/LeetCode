---
title: 回文链表
date: 2024-02-10
---

## 题目描述

**🔗 题目**：[回文链表](https://leetcode.cn/problems/palindrome-linked-list/)  
**🏷️ 标签**：`链表` `双指针` `递归`  
**🔴 难度**：`简单`  

给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。

示例 1：
```
输入：head = [1,2,2,1]
输出：true
```

示例 2：
```
输入：head = [1,2]
输出：false
```

提示：
- 链表中节点数目在范围[1, 10^5] 内
- 0 <= Node.val <= 9

进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

---

## 解题思路

### 方法一：快慢指针 + 反转链表

#### 📝 核心思想

要判断一个链表是否为回文链表，我们需要从两端向中间比较节点值是否相等。但由于单链表只能从前向后遍历，我们可以：

1. 找到链表的中点
2. 反转后半部分链表
3. 比较前半部分和反转后的后半部分是否相同
4. 恢复链表（可选）

#### 🛠️ 实现步骤

1. **找到链表中点**：使用快慢指针
   - 慢指针每次移动一步，快指针每次移动两步
   - 当快指针到达末尾时，慢指针指向中点

2. **反转后半部分链表**：从中点后的节点开始反转
   - 使用三个指针（prev、curr、next）实现链表反转
   - 反转后得到反向的后半部分链表

3. **比较两部分**：
   - 从头节点和反转后的后半部分头节点开始比较
   - 依次比较对应节点的值是否相等

4. **恢复链表**（可选）：
   - 再次反转后半部分，恢复原始链表结构
   - 这一步不是必需的，但是保持了链表的原始结构

#### 💡 图解说明

以示例 `[1,2,2,1]` 为例：

1. 初始链表：
```
1 -> 2 -> 2 -> 1
```

2. 找到中点（第一个2）：
```
1 -> 2 -> | 2 -> 1
```

3. 反转后半部分：
```
1 -> 2 -> | 1 -> 2
```

4. 比较两部分：
```
1 -> 2    1 -> 2
比较相等，是回文链表
```

#### ⚡️ 复杂度分析

- **时间复杂度**：O(n)
  - 找中点需要 O(n/2)
  - 反转链表需要 O(n/2)
  - 比较需要 O(n/2)
  - 恢复链表需要 O(n/2)
  - 总体为 O(n)

- **空间复杂度**：O(1)
  - 只使用了几个指针变量
  - 没有使用额外的数据结构

### 方法二：递归（不符合进阶要求）

#### 📝 核心思想

利用递归的特性，可以实现从后向前遍历链表，同时用一个指针从前向后遍历，对比节点值是否相等。

#### 🚫 缺点

- 空间复杂度为 O(n)，不满足进阶要求
- 递归调用栈的开销较大

## 总结

1. 该题是一个典型的链表操作问题，结合了多个常见的链表操作技巧：
   - 快慢指针找中点
   - 反转链表
   - 链表遍历

2. 解法的关键在于：
   - 如何找到链表的中点（快慢指针）
   - 如何实现 O(1) 的空间复杂度（原地反转链表）

3. 注意事项：
   - 处理边界情况（空链表、单节点链表）
   - 是否需要恢复链表的原始结构
   - 链表节点数为奇数和偶数时的处理差异 